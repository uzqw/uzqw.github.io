[{"categories":["Database"],"content":"Implementing HNSW for a vector database project, hitting 0% recall on the first test, and systematically fixing six critical bugs: inverted heap semantics, distance/similarity confusion, lack of diversity heuristic in SelectNeighbors, and more. Each bug is traced back to the original HNSW paper.","date":"2026-02-16","objectID":"/posts/260216-hnsw-implementation/","tags":["HNSW","Vector Database","Go","ANN"],"title":"Six Pitfalls Implementing HNSW: A Debug Journal from 0% to 98%+ Recall","uri":"/posts/260216-hnsw-implementation/"},{"categories":["Database"],"content":"While implementing the HNSW algorithm for my vector database project vex (initial code AI-assisted, debugging and optimization done by hand), I ran my first Recall test — every single metric was 0%. Not 50%, not 30%. Zero. The HNSW results and BruteForce results had absolutely no overlap. This post documents the entire journey from 0% to 98%+ recall, cross-referencing each bug with the original HNSW paper. ","date":"2026-02-16","objectID":"/posts/260216-hnsw-implementation/:0:0","tags":["HNSW","Vector Database","Go","ANN"],"title":"Six Pitfalls Implementing HNSW: A Debug Journal from 0% to 98%+ Recall","uri":"/posts/260216-hnsw-implementation/"},{"categories":["Database"],"content":"1. HNSW Paper Core Ideas Before diving into debugging, let’s establish the foundational concepts from the HNSW paper (Malkov \u0026 Yashunin, 2018). Every bug we’ll encounter maps directly to a violation of these principles. ","date":"2026-02-16","objectID":"/posts/260216-hnsw-implementation/:1:0","tags":["HNSW","Vector Database","Go","ANN"],"title":"Six Pitfalls Implementing HNSW: A Debug Journal from 0% to 98%+ Recall","uri":"/posts/260216-hnsw-implementation/"},{"categories":["Database"],"content":"1.1 Layered Skip List + Proximity Graph HNSW is a multi-layer graph. Upper layers are sparse (for long-range jumps), lower layers are dense (for precise search). Search starts from the entry point at the highest layer and greedily descends. Layer 2: [A] ──────────────── [B] (sparse, long hops) │ │ Layer 1: [A] ── [C] ── [D] ── [B] ── [E] (medium density) │ │ │ │ │ Layer 0: [A]-[C]-[F]-[D]-[G]-[B]-[E]-[H]-... (all nodes) Intuition: like map navigation — first hop on the highway to get near the target city, then switch to local roads, then walk the streets to the exact address. ","date":"2026-02-16","objectID":"/posts/260216-hnsw-implementation/:1:1","tags":["HNSW","Vector Database","Go","ANN"],"title":"Six Pitfalls Implementing HNSW: A Debug Journal from 0% to 98%+ Recall","uri":"/posts/260216-hnsw-implementation/"},{"categories":["Database"],"content":"1.2 Five Key Parameters Parameter Meaning Paper Recommendation $M$ Max neighbors per node (non-zero layers) 12-48 $M_0$ Max neighbors at Layer 0, $M_0 = 2M$ Paper §4 explicitly requires this $ef_{Construction}$ Candidate set size during build 100-400 $ef$ Candidate set size during search (beam width) ≥ k, typically 100-800 $m_L$ Level assignment factor, $m_L = 1/\\ln(M)$ Computed automatically ","date":"2026-02-16","objectID":"/posts/260216-hnsw-implementation/:1:2","tags":["HNSW","Vector Database","Go","ANN"],"title":"Six Pitfalls Implementing HNSW: A Debug Journal from 0% to 98%+ Recall","uri":"/posts/260216-hnsw-implementation/"},{"categories":["Database"],"content":"1.3 Two Critical Heaps Algorithm 2 (search) defines two heaps with strict semantics: C = min-heap (candidates) -\u003e expand nearest candidate first W = max-heap (working set) -\u003e maintain top-ef results, evict worst Loop: 1. Pop nearest from C (min-heap pop) 2. If dist(c) \u003e worst in W -\u003e stop 3. For each neighbor e of c: 4. If dist(e) \u003c worst in W -\u003e add to C and W 5. If |W| \u003e ef -\u003e pop worst from W (max-heap pop) This is critical — inverting these heap semantics is the direct root cause of 0% recall. ","date":"2026-02-16","objectID":"/posts/260216-hnsw-implementation/:1:3","tags":["HNSW","Vector Database","Go","ANN"],"title":"Six Pitfalls Implementing HNSW: A Debug Journal from 0% to 98%+ Recall","uri":"/posts/260216-hnsw-implementation/"},{"categories":["Database"],"content":"1.4 Algorithm 4: Diversity Heuristic for SelectNeighbors The most overlooked contribution of the paper. Neighbor selection is not simply picking the M closest — it must consider spatial diversity: Algorithm 4: SELECT-NEIGHBORS-HEURISTIC(q, C, M) R ← ∅ (result set) W ← C (working set, sorted by distance) while |W| \u003e 0 AND |R| \u003c M: e ← extract nearest from W if dist(q, e) \u003c dist(e, r) for all r ∈ R: // e is not \"dominated\" R ← R ∪ {e} else: discard e (already covered by an existing neighbor) Intuition: if you’re placing cell towers, don’t cluster them all in the city center. Spread them across different directions so every area has coverage. ","date":"2026-02-16","objectID":"/posts/260216-hnsw-implementation/:1:4","tags":["HNSW","Vector Database","Go","ANN"],"title":"Six Pitfalls Implementing HNSW: A Debug Journal from 0% to 98%+ Recall","uri":"/posts/260216-hnsw-implementation/"},{"categories":["Database"],"content":"2. First Shock: 0% Recall Across the Board ","date":"2026-02-16","objectID":"/posts/260216-hnsw-implementation/:2:0","tags":["HNSW","Vector Database","Go","ANN"],"title":"Six Pitfalls Implementing HNSW: A Debug Journal from 0% to 98%+ Recall","uri":"/posts/260216-hnsw-implementation/"},{"categories":["Database"],"content":"2.1 Test Framework I built a Recall@K test. The idea is straightforward: insert the same vectors into both HNSW and BruteForce, query the same vectors, compute overlap: $$Recall@k = \\frac{|HNSW_{top\\text{-}k} \\cap BruteForce_{top\\text{-}k}|}{k}$$ func calculateRecallAtK(hnswResults, groundTruth []vector.SearchResult, k int) float64 { truthSet := make(map[string]bool, len(groundTruth)) for _, r := range groundTruth { truthSet[r.Key] = true } matches := 0 for _, r := range hnswResults { if truthSet[r.Key] { matches++ } } return float64(matches) / float64(k) } Test matrix: 6 configurations (1K/10K vectors × 128/256/512 dimensions). ","date":"2026-02-16","objectID":"/posts/260216-hnsw-implementation/:2:1","tags":["HNSW","Vector Database","Go","ANN"],"title":"Six Pitfalls Implementing HNSW: A Debug Journal from 0% to 98%+ Recall","uri":"/posts/260216-hnsw-implementation/"},{"categories":["Database"],"content":"2.2 Total Failure === RUN TestHNSWRecallAccuracy/1K-128D recall@1 = 0.0000 (0.00%) recall@5 = 0.0000 (0.00%) recall@10 = 0.0000 (0.00%) --- FAIL All 6 configurations, all k values: 0.0000. Debug output revealed the smoking gun: Query: test-query-0 HNSW top-5: [vec-933(-0.22), vec-071(-0.21), vec-445(-0.19), ...] BF top-5: [vec-236(+0.30), vec-560(+0.29), vec-112(+0.28), ...] Overlap: 0/5 (0%) Two observations: Zero overlap — not a sorting issue, entirely different vectors HNSW returned negative similarities (-0.22) while BF returned positive (+0.30) HNSW was returning the least similar vectors. ","date":"2026-02-16","objectID":"/posts/260216-hnsw-implementation/:2:2","tags":["HNSW","Vector Database","Go","ANN"],"title":"Six Pitfalls Implementing HNSW: A Debug Journal from 0% to 98%+ Recall","uri":"/posts/260216-hnsw-implementation/"},{"categories":["Database"],"content":"3. Bug #1: Distance vs. Similarity Confusion ","date":"2026-02-16","objectID":"/posts/260216-hnsw-implementation/:3:0","tags":["HNSW","Vector Database","Go","ANN"],"title":"Six Pitfalls Implementing HNSW: A Debug Journal from 0% to 98%+ Recall","uri":"/posts/260216-hnsw-implementation/"},{"categories":["Database"],"content":"3.1 Root Cause The heap comparison logic assumed lower distance = better (like Euclidean), but the actual metric was DotProduct similarity (higher = better). // Original — returns raw similarity func distanceBetween(vec1, vec2 []float32) (float32, error) { return vector.DotProduct(vec1, vec2) // range [-1, 1], higher = more similar } // Heap — assumes lower = better func (h candidateHeap) Less(i, j int) bool { return h[i].distance \u003e h[j].distance // max-heap: largest at root } The heap evicts the largest value — but the largest similarity is the best result. Search was expanding the worst candidates first. ","date":"2026-02-16","objectID":"/posts/260216-hnsw-implementation/:3:1","tags":["HNSW","Vector Database","Go","ANN"],"title":"Six Pitfalls Implementing HNSW: A Debug Journal from 0% to 98%+ Recall","uri":"/posts/260216-hnsw-implementation/"},{"categories":["Database"],"content":"3.2 Fix Convert similarity to distance by negation: func distanceBetween(vec1, vec2 []float32) (float32, error) { sim, err := vector.DotProduct(vec1, vec2) if err != nil { return 0, err } return -sim, nil // higher similarity -\u003e lower distance (more negative) } Result (recall@1): 0% -\u003e ~20% (1K-128D), ~15% (1K-256D), ~2% (10K-128D). Progress, but recall dropped sharply with higher dimensions and more data. Far from ideal. ","date":"2026-02-16","objectID":"/posts/260216-hnsw-implementation/:3:2","tags":["HNSW","Vector Database","Go","ANN"],"title":"Six Pitfalls Implementing HNSW: A Debug Journal from 0% to 98%+ Recall","uri":"/posts/260216-hnsw-implementation/"},{"categories":["Database"],"content":"4. Bug #2: Inverted Candidate Selection Condition // Wrong: selects candidates with LARGER (worse) distance if distance \u003e w[0].distance || len(w) \u003c ef { ... } // Correct: selects candidates with SMALLER (better) distance if distance \u003c w[0].distance || len(w) \u003c ef { ... } Result: ~20% -\u003e ~30% (1K-128D), ~15% -\u003e ~25% (1K-256D), ~2% -\u003e ~5% (10K-128D). Better, but 10K was still terrible. ","date":"2026-02-16","objectID":"/posts/260216-hnsw-implementation/:4:0","tags":["HNSW","Vector Database","Go","ANN"],"title":"Six Pitfalls Implementing HNSW: A Debug Journal from 0% to 98%+ Recall","uri":"/posts/260216-hnsw-implementation/"},{"categories":["Database"],"content":"5. Bugs #3-#6: Systematic Audit Against the Paper At this point, I did a full code review against the paper. ","date":"2026-02-16","objectID":"/posts/260216-hnsw-implementation/:5:0","tags":["HNSW","Vector Database","Go","ANN"],"title":"Six Pitfalls Implementing HNSW: A Debug Journal from 0% to 98%+ Recall","uri":"/posts/260216-hnsw-implementation/"},{"categories":["Database"],"content":"5.1 Bug #3: candidates Heap Semantics (Most Fatal) Paper: candidates = min-heap, W = max-heap. Implementation: Both were max-heaps. Every iteration popped the furthest candidate for expansion instead of the nearest. Fix: Change candidates to min-heap. ","date":"2026-02-16","objectID":"/posts/260216-hnsw-implementation/:5:1","tags":["HNSW","Vector Database","Go","ANN"],"title":"Six Pitfalls Implementing HNSW: A Debug Journal from 0% to 98%+ Recall","uri":"/posts/260216-hnsw-implementation/"},{"categories":["Database"],"content":"5.2 Bug #4: SelectNeighbors Without Diversity Heuristic // Original — just truncate func getNeighbors(candidates []*HNSWNode, m int) []*HNSWNode { return candidates[:m] // Picks M closest — fatal mistake } Fix: Implement Algorithm 4 with RNG diversity heuristic — discard candidates dominated by already-selected neighbors: func (h *HNSWIndex) selectNeighborsHeuristic( query []float32, candidates []*HNSWNode, m int, ) []*HNSWNode { selected := make([]*HNSWNode, 0, m) for _, e := range candidates { if len(selected) \u003e= m { break } distQE, _ := distanceBetween(query, e.Vector) dominated := false for _, r := range selected { distER, _ := distanceBetween(e.Vector, r.Vector) if distER \u003c distQE { dominated = true; break } } if !dominated { selected = append(selected, e) } } return selected } ","date":"2026-02-16","objectID":"/posts/260216-hnsw-implementation/:5:2","tags":["HNSW","Vector Database","Go","ANN"],"title":"Six Pitfalls Implementing HNSW: A Debug Journal from 0% to 98%+ Recall","uri":"/posts/260216-hnsw-implementation/"},{"categories":["Database"],"content":"5.3 Bug #5: Layer 0 Not Using M₀ = 2M Paper §4 explicitly states Layer 0 should use double the neighbor count. ","date":"2026-02-16","objectID":"/posts/260216-hnsw-implementation/:5:3","tags":["HNSW","Vector Database","Go","ANN"],"title":"Six Pitfalls Implementing HNSW: A Debug Journal from 0% to 98%+ Recall","uri":"/posts/260216-hnsw-implementation/"},{"categories":["Database"],"content":"5.4 Bug #6: O(M²) Bubble Sort in pruneNeighbors Replaced with sort.Slice for O(M log M). ","date":"2026-02-16","objectID":"/posts/260216-hnsw-implementation/:5:4","tags":["HNSW","Vector Database","Go","ANN"],"title":"Six Pitfalls Implementing HNSW: A Debug Journal from 0% to 98%+ Recall","uri":"/posts/260216-hnsw-implementation/"},{"categories":["Database"],"content":"5.5 Additional Fixes Global RNG race: assignLevel() used shared rand.Float64(). Fixed with per-index rand.Rand. Delete dangling pointers: Deletion didn’t clean up neighbor references. Fixed with tombstone flags and reverse-reference cleanup. ","date":"2026-02-16","objectID":"/posts/260216-hnsw-implementation/:5:5","tags":["HNSW","Vector Database","Go","ANN"],"title":"Six Pitfalls Implementing HNSW: A Debug Journal from 0% to 98%+ Recall","uri":"/posts/260216-hnsw-implementation/"},{"categories":["Database"],"content":"6. Results After All Six Fixes 1K-128D: recall@1 = 100.00% recall@10 = 100.00% recall@100 = 100.00% 1K-256D: recall@1 = 100.00% recall@10 = 100.00% recall@100 = 100.00% 10K-128D: recall@1 = 100.00% recall@10 = 100.00% recall@100 = 100.00% 10K-256D: recall@1 = 99.99% recall@10 = 99.98% recall@100 = 99.96% 10K-512D: recall@1 = 98.39% recall@10 = 98.80% recall@100 = 98.21% From 0% across the board to near 100% on 1K-10K/128D-256D, ~98% on 10K-512D. The last 2% on high-dimensional large-scale data is bounded by the curse of dimensionality and ef trade-offs — within expected range. Impact breakdown (using 1K-128D recall@1 as the observation metric): Bug Type recall Trend Paper Section Distance/similarity confusion Semantic 0% -\u003e ~20% Distance space convention Search condition inverted Logic ~20% -\u003e ~30% Algorithm 2 termination candidates heap semantics Data structure ~30% -\u003e ~90% Algorithm 2 (C = min-heap) No SelectNeighbors diversity Algorithm gap ~90% -\u003e ~97% Algorithm 4 Layer 0 missing M₀=2M Parameter ~97% -\u003e ~99% §4 parameter spec Bubble sort in pruneNeighbors Performance No recall impact Engineering ","date":"2026-02-16","objectID":"/posts/260216-hnsw-implementation/:6:0","tags":["HNSW","Vector Database","Go","ANN"],"title":"Six Pitfalls Implementing HNSW: A Debug Journal from 0% to 98%+ Recall","uri":"/posts/260216-hnsw-implementation/"},{"categories":["Database"],"content":"7. High-Dimensional Performance: Adaptive ef After all bugs were fixed, 10K-512D took 512+ seconds. The fix: scale ef inversely with dimension. $$ef_{adaptive} = \\frac{ef_{base}}{\\sqrt{dim / dim_{ref}}}$$ func (h *HNSWIndex) adaptiveEf(baseEf, dim int) int { const refDim = 128 if dim \u003c= refDim { return baseEf } ef := int(float64(baseEf) / math.Sqrt(float64(dim)/refDim)) if ef \u003c h.M*2 { ef = h.M * 2 } return ef } Dim baseEf adaptiveEf Build Time Avg Recall 128D 600 600 ~10s ~100% 256D 600 424 ~20s ~99% 512D 600 300 87s (was 512s+) ~98% ","date":"2026-02-16","objectID":"/posts/260216-hnsw-implementation/:7:0","tags":["HNSW","Vector Database","Go","ANN"],"title":"Six Pitfalls Implementing HNSW: A Debug Journal from 0% to 98%+ Recall","uri":"/posts/260216-hnsw-implementation/"},{"categories":["Database"],"content":"8. Gap to Industrial Implementations Dimension Current Industrial (hnswlib/Faiss/Weaviate) SelectNeighbors Algorithm 4 RNG heuristic (done) Same Layer 0 M₀ 2×M (done, paper §4) Same Distance calc Go ASM + AVX2/AVX512 (done) C/C++ SIMD, 2-4× faster Concurrency FNV sharded locks (done) Lock-free insert / finer-grained locks Memory layout map[string]*Node pointer chasing Contiguous arrays, cache-friendly Delete Soft delete + neighbor cleanup (done) Lazy deletion + graph reconnection Quantization None Product Quantization, 4-16× memory reduction Dynamic ef Dimension-adaptive (done) Per-query budget adaptive Persistence Full snapshot mmap direct load, sub-second recovery The main bottlenecks now are memory layout and quantization — Go’s map + pointer structure is CPU cache-unfriendly, and uncompressed high-dimensional vectors consume significant memory. These are the next optimization targets. ","date":"2026-02-16","objectID":"/posts/260216-hnsw-implementation/:8:0","tags":["HNSW","Vector Database","Go","ANN"],"title":"Six Pitfalls Implementing HNSW: A Debug Journal from 0% to 98%+ Recall","uri":"/posts/260216-hnsw-implementation/"},{"categories":["Database"],"content":"9. Debugging Methodology Takeaways Write the test framework before the algorithm — HNSW’s Search never errors; it always “succeeds” with wrong results. Without Recall@K, you’d never know. 0% is easier to debug than 50% — it signals a systematic directional error, not random precision loss. Cross-reference the paper line by line — one flipped comparison operator is the difference between 0% and 92% recall. Don’t lower thresholds to “pass” tests — I once lowered the required recall from 85% to 1% to make the test green. That’s hiding the bug, not fixing it. Fix one variable at a time — the six bugs weren’t found simultaneously. Fix one, re-run, observe the recall delta, then move to the next. Project: github.com/uzqw/vex — A vector database implemented in Go with HNSW index, BruteForce index and snapshot persistence. Reference: Malkov, Y.A. \u0026 Yashunin, D.A. (2018). “Efficient and robust approximate nearest neighbor search using Hierarchical Navigable Small World graphs.” IEEE TPAMI. ","date":"2026-02-16","objectID":"/posts/260216-hnsw-implementation/:9:0","tags":["HNSW","Vector Database","Go","ANN"],"title":"Six Pitfalls Implementing HNSW: A Debug Journal from 0% to 98%+ Recall","uri":"/posts/260216-hnsw-implementation/"},{"categories":["Distributed Systems"],"content":"A deep dive into Temporal's reliability guarantees on a single-node deployment: Event History recovery after Server crashes, retry and heartbeat strategies for network failures, and ultimate fallback mechanisms when compensation rollbacks fail.","date":"2026-02-13","objectID":"/posts/260213-temporal-reliability/","tags":["Temporal","Go","Reliability"],"title":"Temporal Single-Node Reliability Deep Dive: How It Survives Server Crashes, Network Failures, and Rollback Errors","uri":"/posts/260213-temporal-reliability/"},{"categories":["Distributed Systems"],"content":"Writing business logic with Temporal is pure joy — “code like a single-machine program, get distributed fault tolerance for free.” But after the honeymoon phase, a nagging question remains: Is it really reliable? What if the Server crashes? What about network partitions? What if the rollback itself fails? This article tears apart these questions from the ground up. ","date":"2026-02-13","objectID":"/posts/260213-temporal-reliability/:0:0","tags":["Temporal","Go","Reliability"],"title":"Temporal Single-Node Reliability Deep Dive: How It Survives Server Crashes, Network Failures, and Rollback Errors","uri":"/posts/260213-temporal-reliability/"},{"categories":["Distributed Systems"],"content":"1. Understand the Architecture Boundary First Before discussing reliability, we need to map out each component’s responsibilities in a single-node Temporal deployment: ┌──────────────────────────────────────────────────────┐ │ Temporal Server │ │ ┌──────────┐ ┌──────────┐ ┌──────────────────┐ │ │ │ Frontend │ │ Matching │ │ History │ │ │ │ Service │ │ Service │ │ Service │ │ │ └────┬─────┘ └─────┬────┘ └─────────┬────────┘ │ │ │ │ │ │ │ └──────────────┼─────────────────┘ │ │ │ │ │ ┌───────▼───────┐ │ │ │ Persistence │ │ │ │ (MySQL/PG/ │ │ │ │ SQLite) │ │ │ └───────────────┘ │ └──────────────────────────────────────────────────────┘ ▲ ▲ │ gRPC │ gRPC │ │ ┌───────┴────────┐ ┌───────┴────────┐ │ Temporal CLI │ │ Worker │ │ (Start Wkfl) │ │ (Run Activity)│ └────────────────┘ └────────────────┘ Component Responsibilities: Frontend Service: The “gateway” of Temporal Server. All external requests (starting Workflows, querying status, sending Signals) enter through its gRPC interface. It handles request validation, routing, and rate limiting — it does not store any state itself. Matching Service: The task dispatcher. It maintains Task Queues and matches pending Activity/Workflow Tasks to idle Workers. Think of it as the “assignment coordinator.” History Service: The core of the core. It maintains the Event History for each Workflow, handles state transitions, Timer scheduling, and Event persistence. The vast majority of Temporal’s reliability guarantees happen at this layer. Temporal CLI (tctl / temporal): A command-line client tool for interacting with the Server — starting Workflows, querying status, sending Signals, managing Namespaces, etc. In code, you typically use the Temporal SDK’s client.Dial() instead; both serve the same role as “the party that initiates requests.” Worker: A program you write yourself, registering Workflow and Activity functions before connecting to the Server. Workers continuously poll the Task Queue to pick up and execute tasks. They are inherently stateless — all progress and results are reported back to the Server for persistence. If a Worker crashes, just spin up another one; the Workflow’s state is unaffected. Key insight: Component Crash Impact State Location Worker Activity execution interrupted Stateless (state lives on Server side) Temporal Server New tasks cannot be scheduled State persisted in database Database (MySQL/PG) Game over This is the true lifeline Core conclusion: Temporal’s single-node reliability = the database’s reliability. Server and Worker are recoverable; only database loss is catastrophic. ","date":"2026-02-13","objectID":"/posts/260213-temporal-reliability/:1:0","tags":["Temporal","Go","Reliability"],"title":"Temporal Single-Node Reliability Deep Dive: How It Survives Server Crashes, Network Failures, and Rollback Errors","uri":"/posts/260213-temporal-reliability/"},{"categories":["Distributed Systems"],"content":"2. Server Crash: How Event History Saves the Day ","date":"2026-02-13","objectID":"/posts/260213-temporal-reliability/:2:0","tags":["Temporal","Go","Reliability"],"title":"Temporal Single-Node Reliability Deep Dive: How It Survives Server Crashes, Network Failures, and Rollback Errors","uri":"/posts/260213-temporal-reliability/"},{"categories":["Distributed Systems"],"content":"2.1 Persistence Mechanism: Write First, Acknowledge Later The History Service strictly follows a Write-Ahead principle for every operation: Worker reports Activity completion │ ▼ History Service receives request │ ▼ ① Write Event to database (INSERT INTO events ...) \u003c- Persist first │ ▼ ② Return ACK to Worker \u003c- Acknowledge second │ ▼ ③ Schedule next Activity (via Matching Service Task Queue) This means: If Server crashes before step ② — the Event is already in the database. After restart, the History Service recovers state from the database, and the Workflow continues. If Server crashes before step ① — this Event is indeed lost. But since the Worker never received an ACK, it will retry, and the Activity gets re-executed. ","date":"2026-02-13","objectID":"/posts/260213-temporal-reliability/:2:1","tags":["Temporal","Go","Reliability"],"title":"Temporal Single-Node Reliability Deep Dive: How It Survives Server Crashes, Network Failures, and Rollback Errors","uri":"/posts/260213-temporal-reliability/"},{"categories":["Distributed Systems"],"content":"2.2 Three Crash Recovery Scenarios Scenario 1: Server crashes during Activity execution Timeline: t0: Workflow schedules ActivityA t1: Worker picks up ActivityA and starts executing t2: Server crashes t3: ActivityA completes, Worker tries to report -\u003e Fails (connection lost) t4: Server restarts t5: Worker re-reports ActivityA result -\u003e Server accepts t6: Workflow continues with ActivityB Key point: Workers have built-in reconnection logic and will continuously attempt to reach the Server. Activity results are never lost due to a temporary Server crash. Scenario 2: Server crashes while scheduling the next Activity Timeline: t0: ActivityA completes, Event written to DB t1: Server prepares to schedule ActivityB t2: Server crashes (ActivityB never placed in Task Queue) t3: Server restarts t4: History Service runs Transfer Task -\u003e discovers ActivityB needs scheduling t5: ActivityB placed in Task Queue, Worker picks it up Key point: Temporal has a Transfer Queue mechanism. Persisted-but-undelivered tasks are re-scanned and dispatched by the Transfer Task Processor after Server restart. Scenario 3: Server crashes right when Workflow starts run, err := client.ExecuteWorkflow(ctx, options, MyWorkflow, input) if err != nil { // Connection failed — but the Workflow might already be created! // Use WorkflowID for idempotent lookup existing, _ := client.DescribeWorkflowExecution(ctx, workflowID, \"\") if existing != nil { log.Println(\"Workflow already running, no need to recreate\") } } Lesson learned: I once hit a bug where the client received a timeout error and retried Workflow creation, resulting in two records with the same WorkflowID. The fix was setting WorkflowIdReusePolicy: options := client.StartWorkflowOptions{ ID: \"order-\" + orderID, TaskQueue: \"order-queue\", WorkflowIDReusePolicy: enums.WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE, } ","date":"2026-02-13","objectID":"/posts/260213-temporal-reliability/:2:2","tags":["Temporal","Go","Reliability"],"title":"Temporal Single-Node Reliability Deep Dive: How It Survives Server Crashes, Network Failures, and Rollback Errors","uri":"/posts/260213-temporal-reliability/"},{"categories":["Distributed Systems"],"content":"2.3 Timer and Schedule Persistence Temporal’s Timers (workflow.Sleep) and Schedules are also persisted in the database: // This sleep survives Server crashes workflow.Sleep(ctx, 24*time.Hour) // Resumes 24 hours later — even if Server restarted 10 times in between How it works: workflow.Sleep generates a TimerStarted Event with the trigger time written to the database. After restart, the Timer module reloads all pending timers and fires TimerFired Events on schedule. This is fundamentally different from time.Sleep — which is gone the moment the process exits. ","date":"2026-02-13","objectID":"/posts/260213-temporal-reliability/:2:3","tags":["Temporal","Go","Reliability"],"title":"Temporal Single-Node Reliability Deep Dive: How It Survives Server Crashes, Network Failures, and Rollback Errors","uri":"/posts/260213-temporal-reliability/"},{"categories":["Distributed Systems"],"content":"3. Network Failures: Triple Protection for Activity External Calls ","date":"2026-02-13","objectID":"/posts/260213-temporal-reliability/:3:0","tags":["Temporal","Go","Reliability"],"title":"Temporal Single-Node Reliability Deep Dive: How It Survives Server Crashes, Network Failures, and Rollback Errors","uri":"/posts/260213-temporal-reliability/"},{"categories":["Distributed Systems"],"content":"3.1 Layer 1: RetryPolicy Auto-Retry When an Activity’s external service call fails (timeout, 503, connection refused), Temporal automatically retries per the RetryPolicy: activityOptions := workflow.ActivityOptions{ StartToCloseTimeout: 30 * time.Second, RetryPolicy: \u0026temporal.RetryPolicy{ InitialInterval: time.Second, BackoffCoefficient: 2.0, MaximumInterval: time.Minute, MaximumAttempts: 5, NonRetryableErrorTypes: []string{ \"InvalidArgumentError\", \"BusinessValidationError\", }, }, } Retry timeline: Attempt 1: t=0s -\u003e Failed (timeout) Attempt 2: t=1s -\u003e Failed (503) Attempt 3: t=3s -\u003e Failed (connection refused) Attempt 4: t=7s -\u003e Failed (timeout) Attempt 5: t=15s -\u003e Success (service recovered) ","date":"2026-02-13","objectID":"/posts/260213-temporal-reliability/:3:1","tags":["Temporal","Go","Reliability"],"title":"Temporal Single-Node Reliability Deep Dive: How It Survives Server Crashes, Network Failures, and Rollback Errors","uri":"/posts/260213-temporal-reliability/"},{"categories":["Distributed Systems"],"content":"3.2 Layer 2: Heartbeat — Lifeline for Long-Running Tasks For Activities that may take a long time (e.g., batch API calls), timeouts alone aren’t enough. Temporal provides a Heartbeat mechanism: func BatchProcessActivity(ctx context.Context, items []Item) error { // Recover progress from last heartbeat (resume from checkpoint) var startIndex int if activity.HasHeartbeatDetails(ctx) { activity.GetHeartbeatDetails(ctx, \u0026startIndex) startIndex++ } for i := startIndex; i \u003c len(items); i++ { result, err := thirdPartyAPI.Process(items[i]) if err != nil { return err } activity.RecordHeartbeat(ctx, i) } return nil } Heartbeat’s two core capabilities: Failure detection: If Worker crashes or network disconnects, Server marks Activity as failed after HeartbeatTimeout, triggering retry Progress recovery: Heartbeat details are available on retry, enabling checkpoint-resume ","date":"2026-02-13","objectID":"/posts/260213-temporal-reliability/:3:2","tags":["Temporal","Go","Reliability"],"title":"Temporal Single-Node Reliability Deep Dive: How It Survives Server Crashes, Network Failures, and Rollback Errors","uri":"/posts/260213-temporal-reliability/"},{"categories":["Distributed Systems"],"content":"3.3 Layer 3: Activity Idempotency Design Even with retries and heartbeats, there’s an unavoidable issue: Activities may execute more than once. func ChargePayment(ctx context.Context, order Order) error { activityInfo := activity.GetInfo(ctx) idempotencyKey := fmt.Sprintf(\"charge-%s-%s-%d\", activityInfo.WorkflowExecution.ID, activityInfo.ActivityID, activityInfo.Attempt, ) return paymentClient.ChargeWithIdempotencyKey( order.UserID, order.Amount, idempotencyKey, ) } Operation Type Naturally Idempotent? Strategy Query (GET) Yes No action needed Create (POST) No Deduplicate via unique business ID Update (PUT) Depends Optimistic locking / version numbers Delete (DELETE) Depends Check-then-delete / ignore 404 Payment/Transfer Absolutely not Idempotency token required ","date":"2026-02-13","objectID":"/posts/260213-temporal-reliability/:3:3","tags":["Temporal","Go","Reliability"],"title":"Temporal Single-Node Reliability Deep Dive: How It Survives Server Crashes, Network Failures, and Rollback Errors","uri":"/posts/260213-temporal-reliability/"},{"categories":["Distributed Systems"],"content":"4. Rollback Failure: Ultimate Fallback for Compensation Chains ","date":"2026-02-13","objectID":"/posts/260213-temporal-reliability/:4:0","tags":["Temporal","Go","Reliability"],"title":"Temporal Single-Node Reliability Deep Dive: How It Survives Server Crashes, Network Failures, and Rollback Errors","uri":"/posts/260213-temporal-reliability/"},{"categories":["Distributed Systems"],"content":"4.1 The Problem: Compensation Itself Can Fail In the Saga pattern, when step N fails, you roll back N-1, N-2, …, 1. But what if the rollback itself fails? ","date":"2026-02-13","objectID":"/posts/260213-temporal-reliability/:4:1","tags":["Temporal","Go","Reliability"],"title":"Temporal Single-Node Reliability Deep Dive: How It Survives Server Crashes, Network Failures, and Rollback Errors","uri":"/posts/260213-temporal-reliability/"},{"categories":["Distributed Systems"],"content":"4.2 Temporal’s Fallback Strategies Strategy 1: Aggressive RetryPolicy for compensation Activities compensateCtx := workflow.WithActivityOptions(ctx, workflow.ActivityOptions{ StartToCloseTimeout: time.Minute, RetryPolicy: \u0026temporal.RetryPolicy{ InitialInterval: time.Second, BackoffCoefficient: 1.5, MaximumInterval: 5 * time.Minute, MaximumAttempts: 20, // Up to 20 retries for compensation }, }) Strategy 2: Freeze + Alert on compensation failure if compensateErr != nil { _ = workflow.ExecuteActivity(ctx, MarkOrderForManualReview, ManualReviewRequest{ OrderID: order.ID, FailedStep: \"DeductInventory\", CompensateErr: compensateErr.Error(), NeedAction: \"Manual refund required\", }).Get(ctx, nil) _ = workflow.ExecuteActivity(ctx, SendAlert, AlertMessage{ Level: \"CRITICAL\", Message: fmt.Sprintf(\"Order %s compensation failed, manual intervention required\", order.ID), }).Get(ctx, nil) return nil // Don't return error — avoid Temporal retrying the entire Workflow } Strategy 3: Leverage Workflow’s infinite wait capability // Wait indefinitely for human signal var resolution string signalChan := workflow.GetSignalChannel(ctx, \"manual-resolution\") signalChan.Receive(ctx, \u0026resolution) switch resolution { case \"retry\": return workflow.ExecuteActivity(compensateCtx, RefundPayment, order).Get(ctx, nil) case \"skip\": return nil // Human handled it externally case \"escalate\": return fmt.Errorf(\"order %s escalated: %s\", order.ID, compensateErr.Error()) } ","date":"2026-02-13","objectID":"/posts/260213-temporal-reliability/:4:2","tags":["Temporal","Go","Reliability"],"title":"Temporal Single-Node Reliability Deep Dive: How It Survives Server Crashes, Network Failures, and Rollback Errors","uri":"/posts/260213-temporal-reliability/"},{"categories":["Distributed Systems"],"content":"4.3 Generic Saga Compensation Framework type SagaStep struct { Name string Action interface{} Compensate interface{} Input interface{} } func ExecuteSaga(ctx workflow.Context, steps []SagaStep) error { var completedSteps []SagaStep for _, step := range steps { err := workflow.ExecuteActivity(ctx, step.Action, step.Input).Get(ctx, nil) if err != nil { for i := len(completedSteps) - 1; i \u003e= 0; i-- { s := completedSteps[i] if s.Compensate != nil { _ = workflow.ExecuteActivity(ctx, s.Compensate, s.Input).Get(ctx, nil) } } return fmt.Errorf(\"step [%s] failed: %w\", step.Name, err) } completedSteps = append(completedSteps, step) } return nil } ","date":"2026-02-13","objectID":"/posts/260213-temporal-reliability/:4:3","tags":["Temporal","Go","Reliability"],"title":"Temporal Single-Node Reliability Deep Dive: How It Survives Server Crashes, Network Failures, and Rollback Errors","uri":"/posts/260213-temporal-reliability/"},{"categories":["Distributed Systems"],"content":"5. Reliability Layers Summary ┌──────────────────────────────────────────────┐ │ Level 4: Human Fallback │ │ Signal-based human intervention / Alerting │ ├──────────────────────────────────────────────┤ │ Level 3: Compensation Strategy │ │ Saga rollback / Aggressive retry / Freeze │ ├──────────────────────────────────────────────┤ │ Level 2: Activity Resilience │ │ RetryPolicy / Heartbeat / Idempotency Token │ ├──────────────────────────────────────────────┤ │ Level 1: Persistence Foundation │ │ Event History / Write-Ahead / Transfer Queue│ ├──────────────────────────────────────────────┤ │ Level 0: Storage Engine │ │ MySQL / PostgreSQL ACID Guarantees │ └──────────────────────────────────────────────┘ Failure Type Protection Level Recovery Method Server temporary crash Level 1 Event History replay + Transfer Queue re-dispatch Worker crash Level 2 HeartbeatTimeout detection + auto-reschedule to another Worker Network jitter Level 2 RetryPolicy exponential backoff External service prolonged outage Level 3 After retries exhausted, trigger compensation rollback Compensation rollback failure Level 4 Signal-based human intervention + alerting Database crash none No automatic recovery; depends on database’s own HA solution Final takeaway: Temporal’s single-node reliability isn’t built on a single “silver bullet” mechanism — it’s a multi-layered defense stack. From database ACID at the bottom, to Event Sourcing write-ahead logging, Activity auto-retry + heartbeat, Saga compensation, and human signal fallback at the top, each layer covers the failure scenarios of the one below it. But it has one hard dependency — the database cannot be lost. For single-node production deployments, at minimum you need database replication + regular backups. The Server and Worker are actually the least concerning parts — restart them and they pick up right where they left off, because all state lives in the database. Article Series Previous: Temporal vs K8s Controller: Two Control Plane Paradigms Previous: Temporal in Practice: From Saga Pattern to Self-Healing ","date":"2026-02-13","objectID":"/posts/260213-temporal-reliability/:5:0","tags":["Temporal","Go","Reliability"],"title":"Temporal Single-Node Reliability Deep Dive: How It Survives Server Crashes, Network Failures, and Rollback Errors","uri":"/posts/260213-temporal-reliability/"},{"categories":["Distributed Systems"],"content":"Last post we captured VXLAN's 50-byte encapsulation overhead with tcpdump. This time we swap Flannel for Cilium, eliminate that performance tax with eBPF, and visualize network topology with Hubble.","date":"2025-12-10","objectID":"/posts/251210-dive-into-k8s-02/","tags":["Kubernetes","Cilium","eBPF"],"title":"Dive into K8s 02: Cilium Replaces Flannel — Goodbye VXLAN Tax, Hello eBPF Native Networking","uri":"/posts/251210-dive-into-k8s-02/"},{"categories":["Distributed Systems"],"content":"Last post, we hand-rolled Flannel in Kind cluster and witnessed the 50-byte per-packet VXLAN encapsulation overhead via tcpdump. This time, we replace Flannel with Cilium, leveraging eBPF to completely eliminate this “network tax”, and use Hubble for traffic visualization. ","date":"2025-12-10","objectID":"/posts/251210-dive-into-k8s-02/:0:0","tags":["Kubernetes","Cilium","eBPF"],"title":"Dive into K8s 02: Cilium Replaces Flannel — Goodbye VXLAN Tax, Hello eBPF Native Networking","uri":"/posts/251210-dive-into-k8s-02/"},{"categories":["Distributed Systems"],"content":"1. Why Switch to Cilium? ","date":"2025-12-10","objectID":"/posts/251210-dive-into-k8s-02/:1:0","tags":["Kubernetes","Cilium","eBPF"],"title":"Dive into K8s 02: Cilium Replaces Flannel — Goodbye VXLAN Tax, Hello eBPF Native Networking","uri":"/posts/251210-dive-into-k8s-02/"},{"categories":["Distributed Systems"],"content":"1.1 Revisiting VXLAN’s Cost In the previous post, we captured: Outer UDP packet: 134 bytes Inner ICMP packet: 84 bytes Encapsulation overhead: 50 bytes (37%!) For typical web apps, 50 bytes is negligible. But in AI large model training: AllReduce operations sync gradients across multiple GPUs Each iteration can generate GB-level network traffic Encap/decap CPU overhead consumes precious compute resources Latency jitter means the slowest card drags down entire training ","date":"2025-12-10","objectID":"/posts/251210-dive-into-k8s-02/:1:1","tags":["Kubernetes","Cilium","eBPF"],"title":"Dive into K8s 02: Cilium Replaces Flannel — Goodbye VXLAN Tax, Hello eBPF Native Networking","uri":"/posts/251210-dive-into-k8s-02/"},{"categories":["Distributed Systems"],"content":"1.2 Cilium’s Secret Weapon: eBPF Cilium uses eBPF (Extended Berkeley Packet Filter) to handle packets directly in kernel space, without going through traditional iptables or VXLAN encapsulation: Feature Flannel (VXLAN) Cilium (eBPF) Encapsulation overhead 50 bytes/packet 0 (Direct Routing) NAT implementation iptables (userspace rules) eBPF (kernel) Network policies Depends on kube-proxy Native support Observability Needs external tools Hubble built-in ","date":"2025-12-10","objectID":"/posts/251210-dive-into-k8s-02/:1:2","tags":["Kubernetes","Cilium","eBPF"],"title":"Dive into K8s 02: Cilium Replaces Flannel — Goodbye VXLAN Tax, Hello eBPF Native Networking","uri":"/posts/251210-dive-into-k8s-02/"},{"categories":["Distributed Systems"],"content":"2. Environment Prep: Clean Flannel Residue ","date":"2025-12-10","objectID":"/posts/251210-dive-into-k8s-02/:2:0","tags":["Kubernetes","Cilium","eBPF"],"title":"Dive into K8s 02: Cilium Replaces Flannel — Goodbye VXLAN Tax, Hello eBPF Native Networking","uri":"/posts/251210-dive-into-k8s-02/"},{"categories":["Distributed Systems"],"content":"2.1 Delete Flannel # Delete Flannel DaemonSet and config kubectl delete -f https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml # Wait for flannel pods to fully delete kubectl get pods -n kube-flannel -w ","date":"2025-12-10","objectID":"/posts/251210-dive-into-k8s-02/:2:1","tags":["Kubernetes","Cilium","eBPF"],"title":"Dive into K8s 02: Cilium Replaces Flannel — Goodbye VXLAN Tax, Hello eBPF Native Networking","uri":"/posts/251210-dive-into-k8s-02/"},{"categories":["Distributed Systems"],"content":"2.2 Clean Node Network Residue This step is critical — otherwise it conflicts with Cilium: # Execute on each Kind node for node in kind-control-plane kind-worker; do docker exec $node bash -c \" # Delete flannel bridges ip link delete cni0 2\u003e/dev/null || true ip link delete flannel.1 2\u003e/dev/null || true # Clean CNI config rm -rf /etc/cni/net.d/* # Clean iptables rules iptables -F -t nat iptables -F -t filter \" done War Story: First time I skipped this step, Cilium installed but Pod networking was chaos. cilium status reported “BPF NodePort: Disabled” and Pods couldn’t communicate. Spent hours in logs before discovering cni0 bridge wasn’t cleaned properly. ","date":"2025-12-10","objectID":"/posts/251210-dive-into-k8s-02/:2:2","tags":["Kubernetes","Cilium","eBPF"],"title":"Dive into K8s 02: Cilium Replaces Flannel — Goodbye VXLAN Tax, Hello eBPF Native Networking","uri":"/posts/251210-dive-into-k8s-02/"},{"categories":["Distributed Systems"],"content":"3. Installing Cilium ","date":"2025-12-10","objectID":"/posts/251210-dive-into-k8s-02/:3:0","tags":["Kubernetes","Cilium","eBPF"],"title":"Dive into K8s 02: Cilium Replaces Flannel — Goodbye VXLAN Tax, Hello eBPF Native Networking","uri":"/posts/251210-dive-into-k8s-02/"},{"categories":["Distributed Systems"],"content":"3.1 Using Cilium CLI # Install Cilium CLI CILIUM_CLI_VERSION=$(curl -s https://raw.githubusercontent.com/cilium/cilium-cli/main/stable.txt) curl -L --fail --remote-name-all \\ https://github.com/cilium/cilium-cli/releases/download/${CILIUM_CLI_VERSION}/cilium-linux-amd64.tar.gz sudo tar xzvfC cilium-linux-amd64.tar.gz /usr/local/bin rm cilium-linux-amd64.tar.gz # Install Cilium (native routing mode, disable encapsulation) cilium install --version 1.14.5 \\ --set routingMode=native \\ --set autoDirectNodeRoutes=true \\ --set kubeProxyReplacement=true \\ --set hubble.relay.enabled=true \\ --set hubble.ui.enabled=true Key parameters explained: routingMode=native: Use direct routing instead of encapsulation kubeProxyReplacement=true: Completely replace kube-proxy with eBPF hubble.relay.enabled=true: Enable Hubble observability ","date":"2025-12-10","objectID":"/posts/251210-dive-into-k8s-02/:3:1","tags":["Kubernetes","Cilium","eBPF"],"title":"Dive into K8s 02: Cilium Replaces Flannel — Goodbye VXLAN Tax, Hello eBPF Native Networking","uri":"/posts/251210-dive-into-k8s-02/"},{"categories":["Distributed Systems"],"content":"3.2 Wait and Verify # Wait for Cilium ready cilium status --wait # Run connectivity test cilium connectivity test Success output: All 46 tests (325 actions) successful, 2 tests skipped, 1 scenario skipped. ","date":"2025-12-10","objectID":"/posts/251210-dive-into-k8s-02/:3:2","tags":["Kubernetes","Cilium","eBPF"],"title":"Dive into K8s 02: Cilium Replaces Flannel — Goodbye VXLAN Tax, Hello eBPF Native Networking","uri":"/posts/251210-dive-into-k8s-02/"},{"categories":["Distributed Systems"],"content":"4. eBPF Packet Capture: Witnessing Zero Encapsulation ","date":"2025-12-10","objectID":"/posts/251210-dive-into-k8s-02/:4:0","tags":["Kubernetes","Cilium","eBPF"],"title":"Dive into K8s 02: Cilium Replaces Flannel — Goodbye VXLAN Tax, Hello eBPF Native Networking","uri":"/posts/251210-dive-into-k8s-02/"},{"categories":["Distributed Systems"],"content":"4.1 Deploy Test Pods # Deploy Pods on both nodes kubectl run client --image=nicolaka/netshoot --command -- sleep infinity kubectl run server --image=nginx # Wait for ready kubectl wait --for=condition=Ready pod/client pod/server ","date":"2025-12-10","objectID":"/posts/251210-dive-into-k8s-02/:4:1","tags":["Kubernetes","Cilium","eBPF"],"title":"Dive into K8s 02: Cilium Replaces Flannel — Goodbye VXLAN Tax, Hello eBPF Native Networking","uri":"/posts/251210-dive-into-k8s-02/"},{"categories":["Distributed Systems"],"content":"4.2 Observe Traffic with Hubble # Start Hubble CLI cilium hubble port-forward \u0026 # Observe traffic hubble observe --pod client --protocol TCP ","date":"2025-12-10","objectID":"/posts/251210-dive-into-k8s-02/:4:2","tags":["Kubernetes","Cilium","eBPF"],"title":"Dive into K8s 02: Cilium Replaces Flannel — Goodbye VXLAN Tax, Hello eBPF Native Networking","uri":"/posts/251210-dive-into-k8s-02/"},{"categories":["Distributed Systems"],"content":"4.3 Compare Capture Results In Cilium’s Native Routing mode: # Capture on node PID=$(docker inspect --format '{{.State.Pid}}' kind-control-plane) sudo nsenter -t $PID -n tcpdump -i eth0 host 10.244.1.5 -n Capture result: IP 10.244.0.3 \u003e 10.244.1.5: ICMP echo request, id 1, seq 1, length 64 IP 10.244.1.5 \u003e 10.244.0.3: ICMP echo reply, id 1, seq 1, length 64 Key Findings: No UDP encapsulation! Directly seeing Pod IP to Pod IP ICMP packets Packet only 84 bytes, compared to Flannel’s 134 bytes Encapsulation overhead: 0 bytes ","date":"2025-12-10","objectID":"/posts/251210-dive-into-k8s-02/:4:3","tags":["Kubernetes","Cilium","eBPF"],"title":"Dive into K8s 02: Cilium Replaces Flannel — Goodbye VXLAN Tax, Hello eBPF Native Networking","uri":"/posts/251210-dive-into-k8s-02/"},{"categories":["Distributed Systems"],"content":"5. Hubble Visualization: Network Topology at a Glance ","date":"2025-12-10","objectID":"/posts/251210-dive-into-k8s-02/:5:0","tags":["Kubernetes","Cilium","eBPF"],"title":"Dive into K8s 02: Cilium Replaces Flannel — Goodbye VXLAN Tax, Hello eBPF Native Networking","uri":"/posts/251210-dive-into-k8s-02/"},{"categories":["Distributed Systems"],"content":"5.1 Launch Hubble UI cilium hubble ui Open browser at http://localhost:12000: What Hubble UI shows: Real-time traffic relationship graph Protocol, port, bytes for each connection Network policy hit status DNS query tracing ","date":"2025-12-10","objectID":"/posts/251210-dive-into-k8s-02/:5:1","tags":["Kubernetes","Cilium","eBPF"],"title":"Dive into K8s 02: Cilium Replaces Flannel — Goodbye VXLAN Tax, Hello eBPF Native Networking","uri":"/posts/251210-dive-into-k8s-02/"},{"categories":["Distributed Systems"],"content":"5.2 Hubble CLI in Action # View all DROP'd packets (debug network policy issues) hubble observe --verdict DROPPED # Trace all connections for specific Pod hubble observe --pod kube-system/coredns --follow # Export to JSON for analysis hubble observe --output json \u003e network-flows.json ","date":"2025-12-10","objectID":"/posts/251210-dive-into-k8s-02/:5:2","tags":["Kubernetes","Cilium","eBPF"],"title":"Dive into K8s 02: Cilium Replaces Flannel — Goodbye VXLAN Tax, Hello eBPF Native Networking","uri":"/posts/251210-dive-into-k8s-02/"},{"categories":["Distributed Systems"],"content":"6. Performance Comparison Data Simple iperf3 test on Kind cluster: Metric Flannel (VXLAN) Cilium (Native) Improvement Throughput 8.2 Gbps 9.4 Gbps +15% Latency (P99) 0.42 ms 0.31 ms -26% CPU usage 12% 5% -58% Note: Test environment is limited; real production improvements may be greater. ","date":"2025-12-10","objectID":"/posts/251210-dive-into-k8s-02/:6:0","tags":["Kubernetes","Cilium","eBPF"],"title":"Dive into K8s 02: Cilium Replaces Flannel — Goodbye VXLAN Tax, Hello eBPF Native Networking","uri":"/posts/251210-dive-into-k8s-02/"},{"categories":["Distributed Systems"],"content":"7. Implications for AI Infra ","date":"2025-12-10","objectID":"/posts/251210-dive-into-k8s-02/:7:0","tags":["Kubernetes","Cilium","eBPF"],"title":"Dive into K8s 02: Cilium Replaces Flannel — Goodbye VXLAN Tax, Hello eBPF Native Networking","uri":"/posts/251210-dive-into-k8s-02/"},{"categories":["Distributed Systems"],"content":"7.1 Why Does AI Training Need Cilium More? AllReduce traffic characteristics: Lots of small packets, bursty traffic, latency-sensitive Ring/Tree AllReduce topologies make every node a traffic hotspot GPU time is precious: Network wait = GPU idle = burning money ","date":"2025-12-10","objectID":"/posts/251210-dive-into-k8s-02/:7:1","tags":["Kubernetes","Cilium","eBPF"],"title":"Dive into K8s 02: Cilium Replaces Flannel — Goodbye VXLAN Tax, Hello eBPF Native Networking","uri":"/posts/251210-dive-into-k8s-02/"},{"categories":["Distributed Systems"],"content":"7.2 Going Further: RDMA and GPUDirect Cilium is just the first step. True high-end AI Infra needs: RDMA over Converged Ethernet (RoCE): Bypass kernel, direct memory access GPUDirect RDMA: GPU directly reads/writes remote GPU memory Cilium’s Native Routing mode paves the way for these advanced technologies by eliminating Overlay network constraints. ","date":"2025-12-10","objectID":"/posts/251210-dive-into-k8s-02/:7:2","tags":["Kubernetes","Cilium","eBPF"],"title":"Dive into K8s 02: Cilium Replaces Flannel — Goodbye VXLAN Tax, Hello eBPF Native Networking","uri":"/posts/251210-dive-into-k8s-02/"},{"categories":["Distributed Systems"],"content":"8. Summary Step Takeaway Clean Flannel Deep understanding of CNI plugin architecture Install Cilium Master eBPF network mode configuration Compare captures Quantify elimination of encapsulation overhead Hubble visualization Gain production-grade network observability Next Plan: Deploy PyTorch distributed training on multi-node cluster, compare actual training throughput impact between Flannel and Cilium. Series Previous: Dive into K8s 01 — Hand-Rolling CNI with Kind, From CrashLoop to VXLAN Packet Capture Next: Dive into K8s 03 — eBPF Deep Dive: Hand-Writing a Simple CNI Plugin (Planned) ","date":"2025-12-10","objectID":"/posts/251210-dive-into-k8s-02/:8:0","tags":["Kubernetes","Cilium","eBPF"],"title":"Dive into K8s 02: Cilium Replaces Flannel — Goodbye VXLAN Tax, Hello eBPF Native Networking","uri":"/posts/251210-dive-into-k8s-02/"},{"categories":["Distributed Systems"],"content":"This weekend, I built a “networkless” cluster from scratch on Manjaro using kind, manually debugged missing kernel modules and CNI plugins, and finally witnessed the VXLAN encapsulation process with tcpdump. This post documents the entire journey. In the cloud-native world, CNI (Container Network Interface) is often a blind spot for developers. We’re used to kubectl apply -f flannel.yaml for one-click setup, rarely exploring what’s happening underneath. Especially for engineers pivoting to AI Infra, high-performance networking is the lifeblood of distributed training. If you don’t even know where the Overlay network overhead comes from, you can’t begin to think about RDMA or eBPF optimizations. ","date":"2025-12-07","objectID":"/posts/251207-dive-into-k8s-01/:0:0","tags":["Kubernetes","CNI","Networking"],"title":"Dive into K8s: Hand-Rolling CNI with Kind, From CrashLoop to VXLAN Packet Capture","uri":"/posts/251207-dive-into-k8s-01/"},{"categories":["Distributed Systems"],"content":"1. Environment Setup: Manufacturing the “Crime Scene” To gain deep understanding, I didn’t use default configuration. Instead, I forcibly disabled Kind’s default CNI, simulating a “bare” cluster with only skeleton, no nerves. Environment: Manjaro Linux + Docker + Kind kind-config.yaml: kind: Cluster apiVersion: kind.x-k8s.io/v1alpha4 networking: disableDefaultCNI: true # Key: disable default network, simulate bare metal nodes: - role: control-plane - role: worker # Multi-node for observing cross-node communication After cluster startup, as expected, nodes are NotReady. Looking at ip addr inside nodes, there’s only lo and eth0 — no cni0 or flannel.1 bridge interfaces. At this point, Kubernetes is like a vegetable patient: heartbeat exists (Kubelet running) but can’t move (Pods can’t communicate). ","date":"2025-12-07","objectID":"/posts/251207-dive-into-k8s-01/:1:0","tags":["Kubernetes","CNI","Networking"],"title":"Dive into K8s: Hand-Rolling CNI with Kind, From CrashLoop to VXLAN Packet Capture","uri":"/posts/251207-dive-into-k8s-01/"},{"categories":["Distributed Systems"],"content":"2. Step-by-Step Debug Journey I chose to install the classic Flannel plugin to “activate” networking, but the process wasn’t smooth. ","date":"2025-12-07","objectID":"/posts/251207-dive-into-k8s-01/:2:0","tags":["Kubernetes","CNI","Networking"],"title":"Dive into K8s: Hand-Rolling CNI with Kind, From CrashLoop to VXLAN Packet Capture","uri":"/posts/251207-dive-into-k8s-01/"},{"categories":["Distributed Systems"],"content":"1. Ghost Pods and Namespace Trap After install command, habitually checked kube-system namespace — empty. kubectl get pods -n kube-system # Output: No resources found. Investigation: Checking DaemonSet showed DESIRED replica count was normal. Turns out newer Flannel, for isolation purposes, migrated to its own kube-flannel namespace. Lesson: When troubleshooting missing resources, always use kubectl get pods -A. ","date":"2025-12-07","objectID":"/posts/251207-dive-into-k8s-01/:2:1","tags":["Kubernetes","CNI","Networking"],"title":"Dive into K8s: Hand-Rolling CNI with Kind, From CrashLoop to VXLAN Packet Capture","uri":"/posts/251207-dive-into-k8s-01/"},{"categories":["Distributed Systems"],"content":"2. Kernel Rejection: Missing br_netfilter Found the Pods, but they’re all in CrashLoopBackOff. Log revealed the core error: Failed to check br_netfilter: stat /proc/sys/net/bridge/bridge-nf-call-iptables: no such file or directory Deep Dive: This is the classic Linux kernel vs K8s networking conflict. Linux Bridge operates at Layer 2 (data link) by default, bypassing iptables. But K8s Services (ClusterIP) rely heavily on iptables for NAT. The br_netfilter module’s job is to bridge the gap, forcing traffic through bridges to enter iptables processing. Solution (run on host Manjaro): # Load kernel module sudo modprobe br_netfilter # Enable forwarding parameter echo 1 | sudo tee /proc/sys/net/bridge/bridge-nf-call-iptables # Recreate Pods kubectl delete pod -n kube-flannel --all Since Kind containers share host kernel, module becomes available inside containers immediately after loading on host. ","date":"2025-12-07","objectID":"/posts/251207-dive-into-k8s-01/:2:2","tags":["Kubernetes","CNI","Networking"],"title":"Dive into K8s: Hand-Rolling CNI with Kind, From CrashLoop to VXLAN Packet Capture","uri":"/posts/251207-dive-into-k8s-01/"},{"categories":["Distributed Systems"],"content":"3. Missing Construction Crew: CNI Chaining Failure Flannel finally Running, but my test Pod (Nginx) stuck at ContainerCreating. kubectl describe pod revealed new problem: failed to find plugin \"bridge\" in path [/opt/cni/bin] Deep Dive: This involves CNI Chaining. Flannel is just the “project manager”, responsible for subnet allocation (IPAM) and route sync. The actual heavy lifting (creating cni0 bridge, connecting veth pairs) is done by the Bridge plugin from CNI standard library. Kind’s minimal node image doesn’t include these base binaries. Solution: We need to manually “airdrop” these plugins. Download official cni-plugins-linux-amd64 package. Copy extracted bridge, loopback etc. binaries to Kind node’s /opt/cni/bin/ directory. docker cp cni-plugins/. kind-worker:/opt/cni/bin/ After this, all Pods turned green (Running). Checking inside nodes, subnet.env generated successfully, network connected. ","date":"2025-12-07","objectID":"/posts/251207-dive-into-k8s-01/:2:3","tags":["Kubernetes","CNI","Networking"],"title":"Dive into K8s: Hand-Rolling CNI with Kind, From CrashLoop to VXLAN Packet Capture","uri":"/posts/251207-dive-into-k8s-01/"},{"categories":["Distributed Systems"],"content":"3. Ultimate Dissection: Tcpdump on Overlay Network Network connected is just the beginning. As an AI Infra prospect, I must see what packets actually look like. I captured packets on Control-plane node, observing cross-node traffic. Experiment Topology: Client: Netshoot Pod (on Control-plane node) Server: Nginx Pod (on Worker node) Capture Command: Listen on host NIC for UDP port 8472 (VXLAN standard port). # Use nsenter on host to borrow container network namespace for capture (Pro Tip!) PID=$(docker inspect --format '{{.State.Pid}}' kind-control-plane) sudo nsenter -t $PID -n tcpdump -i eth0 port 8472 -n -v Capture Result Analysis: # Outer layer (The Envelope) IP 172.29.0.2.59431 \u003e 172.29.0.3.8472: OTV, flags [I] (0x08), overlay 0, instance 1 ... length 134 # Inner layer (The Letter) IP 10.244.0.3 \u003e 10.244.1.5: ICMP echo request ... length 64 Hardcore Conclusions: With -v parameter, the “packet-in-packet” structure is crystal clear. Outer layer (Underlay): UDP communication between node IPs, target port 8472. Inner layer (Overlay): ICMP communication between Pod IPs. Performance Tax: Outer packet 134 bytes, inner packet 84 bytes. That’s 50 bytes encapsulation overhead per packet. ","date":"2025-12-07","objectID":"/posts/251207-dive-into-k8s-01/:3:0","tags":["Kubernetes","CNI","Networking"],"title":"Dive into K8s: Hand-Rolling CNI with Kind, From CrashLoop to VXLAN Packet Capture","uri":"/posts/251207-dive-into-k8s-01/"},{"categories":["Distributed Systems"],"content":"4. Summary This hands-on exercise didn’t just fix CrashLoops — more importantly, it quantified Overlay network costs. For web scenarios, 50 bytes is negligible. But in AI large model training (e.g., AllReduce), massive gradient sync is extremely latency-sensitive. These 50 bytes of encapsulation/decapsulation overhead plus CPU context switching could be the bottleneck limiting GPU cluster performance. This is why in high-end AI Infra, we often abandon VXLAN and explore HostNetwork, MacVLAN, or even eBPF-based Cilium solutions, pursuing zero-overhead networking. Next Step: Next, I’ll replace Flannel with Cilium and try using Hubble to visualize network topology. ","date":"2025-12-07","objectID":"/posts/251207-dive-into-k8s-01/:4:0","tags":["Kubernetes","CNI","Networking"],"title":"Dive into K8s: Hand-Rolling CNI with Kind, From CrashLoop to VXLAN Packet Capture","uri":"/posts/251207-dive-into-k8s-01/"},{"categories":["Distributed Systems"],"content":"Deep comparison between Kubernetes Controller's declarative Reconcile pattern and Temporal's imperative Workflow pattern. How AI Infra platforms can combine both to build a complete control plane.","date":"2025-07-15","objectID":"/posts/250715-temporal-vs-k8s-controller/","tags":["Temporal","Kubernetes","Control Plane"],"title":"Temporal vs K8s Controller: Declarative vs Imperative Control Plane Paradigms","uri":"/posts/250715-temporal-vs-k8s-controller/"},{"categories":["Distributed Systems"],"content":"K8s Controllers and Temporal are both “control plane” technologies, but they represent fundamentally different design philosophies. This post deep-dives into their core differences and explores how to combine them in AI Infra platforms. ","date":"2025-07-15","objectID":"/posts/250715-temporal-vs-k8s-controller/:0:0","tags":["Temporal","Kubernetes","Control Plane"],"title":"Temporal vs K8s Controller: Declarative vs Imperative Control Plane Paradigms","uri":"/posts/250715-temporal-vs-k8s-controller/"},{"categories":["Distributed Systems"],"content":"1. Two Control Plane Paradigms ","date":"2025-07-15","objectID":"/posts/250715-temporal-vs-k8s-controller/:1:0","tags":["Temporal","Kubernetes","Control Plane"],"title":"Temporal vs K8s Controller: Declarative vs Imperative Control Plane Paradigms","uri":"/posts/250715-temporal-vs-k8s-controller/"},{"categories":["Distributed Systems"],"content":"1.1 Philosophy Comparison Dimension K8s Controller Temporal Core philosophy Declarative Imperative/Orchestrated Focus Desired State Workflow/Process Trigger mechanism Level-Triggered Event Sourcing Expression “I want 3 Pods” “First do A, then B, if fail do C” ","date":"2025-07-15","objectID":"/posts/250715-temporal-vs-k8s-controller/:1:1","tags":["Temporal","Kubernetes","Control Plane"],"title":"Temporal vs K8s Controller: Declarative vs Imperative Control Plane Paradigms","uri":"/posts/250715-temporal-vs-k8s-controller/"},{"categories":["Distributed Systems"],"content":"1.2 Level-Triggered vs Edge-Triggered K8s Controller’s Level-Triggered approach: Desired state: replicas=3 Current state: pods=2 → Reconcile → Create 1 Pod → Check again → pods=3 → No action needed Regardless of what triggered Reconcile (Pod deleted, new Deployment, health check failed), the Controller only cares about the gap between current and desired state. Temporal’s Event Sourcing: Event 1: WorkflowStarted Event 2: ActivityScheduled(Payment) Event 3: ActivityCompleted(Success) Event 4: ActivityScheduled(Inventory) [Crash Recovery] → Replay Events 1-4 → Resume from Event 4 Temporal needs the complete history to recover state. ","date":"2025-07-15","objectID":"/posts/250715-temporal-vs-k8s-controller/:1:2","tags":["Temporal","Kubernetes","Control Plane"],"title":"Temporal vs K8s Controller: Declarative vs Imperative Control Plane Paradigms","uri":"/posts/250715-temporal-vs-k8s-controller/"},{"categories":["Distributed Systems"],"content":"1.3 Use Case Analysis Scenario Better Choice Reason Manage Pod/GPU resources K8s Operator Resources are “state to maintain” Training task flow Temporal It’s “ordered steps” Self-healing K8s Controller Periodic Reconcile auto-fixes Complex branching logic Temporal Code expresses it more naturally Run indefinitely K8s Controller Stateless, low overhead Has clear end Temporal Native support for complete/fail/cancel ","date":"2025-07-15","objectID":"/posts/250715-temporal-vs-k8s-controller/:1:3","tags":["Temporal","Kubernetes","Control Plane"],"title":"Temporal vs K8s Controller: Declarative vs Imperative Control Plane Paradigms","uri":"/posts/250715-temporal-vs-k8s-controller/"},{"categories":["Distributed Systems"],"content":"2. Code Comparison ","date":"2025-07-15","objectID":"/posts/250715-temporal-vs-k8s-controller/:2:0","tags":["Temporal","Kubernetes","Control Plane"],"title":"Temporal vs K8s Controller: Declarative vs Imperative Control Plane Paradigms","uri":"/posts/250715-temporal-vs-k8s-controller/"},{"categories":["Distributed Systems"],"content":"2.1 K8s Controller Example Operator managing an AI training job: // reconciler.go func (r *TrainingJobReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) { // Get CR resource var job trainingv1.TrainingJob if err := r.Get(ctx, req.NamespacedName, \u0026job); err != nil { return ctrl.Result{}, client.IgnoreNotFound(err) } // Get current state var pods corev1.PodList r.List(ctx, \u0026pods, client.MatchingLabels{\"job\": job.Name}) // Desired state vs current state desiredReplicas := job.Spec.Workers currentReplicas := len(pods.Items) if currentReplicas \u003c desiredReplicas { // Create Pods for i := currentReplicas; i \u003c desiredReplicas; i++ { r.Create(ctx, r.buildWorkerPod(\u0026job, i)) } } else if currentReplicas \u003e desiredReplicas { // Delete excess Pods for i := desiredReplicas; i \u003c currentReplicas; i++ { r.Delete(ctx, \u0026pods.Items[i]) } } // Update status job.Status.ActiveWorkers = desiredReplicas r.Status().Update(ctx, \u0026job) // Periodic recheck return ctrl.Result{RequeueAfter: time.Minute}, nil } Characteristics: Each Reconcile starts fresh from “current state” Doesn’t care about “how we got here”, only “what’s the gap now” Great for continuously running resource management ","date":"2025-07-15","objectID":"/posts/250715-temporal-vs-k8s-controller/:2:1","tags":["Temporal","Kubernetes","Control Plane"],"title":"Temporal vs K8s Controller: Declarative vs Imperative Control Plane Paradigms","uri":"/posts/250715-temporal-vs-k8s-controller/"},{"categories":["Distributed Systems"],"content":"2.2 Temporal Workflow Example Same AI training job with Temporal: // workflow.go func TrainingWorkflow(ctx workflow.Context, job TrainingJob) error { // Step 1: Prepare data var dataPath string err := workflow.ExecuteActivity(ctx, PrepareData, job.DataSource).Get(ctx, \u0026dataPath) if err != nil { return fmt.Errorf(\"data preparation failed: %w\", err) } // Step 2: Start training (might run for hours) var modelPath string err = workflow.ExecuteActivity(ctx, StartTraining, TrainingParams{ DataPath: dataPath, Epochs: job.Epochs, Workers: job.Workers, }).Get(ctx, \u0026modelPath) if err != nil { // Clean up intermediate data workflow.ExecuteActivity(ctx, CleanupData, dataPath) return fmt.Errorf(\"training failed: %w\", err) } // Step 3: Model evaluation var metrics Metrics err = workflow.ExecuteActivity(ctx, EvaluateModel, modelPath).Get(ctx, \u0026metrics) if err != nil { return fmt.Errorf(\"evaluation failed: %w\", err) } // Step 4: Conditional branch - only deploy if accuracy meets threshold if metrics.Accuracy \u003e= job.MinAccuracy { workflow.ExecuteActivity(ctx, DeployModel, modelPath) } else { // Notify for human review workflow.ExecuteActivity(ctx, NotifyHumanReview, job.Owner, metrics) } return nil } Characteristics: Code is the flow — sequential execution, branching clearly visible Steps have dependencies (dataPath → training → modelPath) Great for tasks with clear start and end ","date":"2025-07-15","objectID":"/posts/250715-temporal-vs-k8s-controller/:2:2","tags":["Temporal","Kubernetes","Control Plane"],"title":"Temporal vs K8s Controller: Declarative vs Imperative Control Plane Paradigms","uri":"/posts/250715-temporal-vs-k8s-controller/"},{"categories":["Distributed Systems"],"content":"3. Core Mechanism Comparison ","date":"2025-07-15","objectID":"/posts/250715-temporal-vs-k8s-controller/:3:0","tags":["Temporal","Kubernetes","Control Plane"],"title":"Temporal vs K8s Controller: Declarative vs Imperative Control Plane Paradigms","uri":"/posts/250715-temporal-vs-k8s-controller/"},{"categories":["Distributed Systems"],"content":"3.1 Failure Recovery K8s Controller: Pod dies → Informer receives Delete event → Triggers Reconcile → Sees current=2, desired=3 → Creates new Pod Recovery relies on periodic state comparison, no history needed. Temporal: Worker dies → Workflow execution interrupted → Start new Worker → Replay from Event History → Code re-executes to breakpoint → Resume forward execution Recovery relies on complete event history. ","date":"2025-07-15","objectID":"/posts/250715-temporal-vs-k8s-controller/:3:1","tags":["Temporal","Kubernetes","Control Plane"],"title":"Temporal vs K8s Controller: Declarative vs Imperative Control Plane Paradigms","uri":"/posts/250715-temporal-vs-k8s-controller/"},{"categories":["Distributed Systems"],"content":"3.2 Complex Branching K8s Controller handling complex branches is painful: // Full of state machine logic switch job.Status.Phase { case \"Pending\": if allPodsReady() { job.Status.Phase = \"Running\" } case \"Running\": if trainingComplete() { job.Status.Phase = \"Evaluating\" } else if hasFailed() { job.Status.Phase = \"Failed\" } case \"Evaluating\": // More branches... } Temporal handles it naturally: // Just use if-else, crystal clear if metrics.Accuracy \u003e= threshold { deployModel() } else if retryCount \u003c 3 { retrainWithMoreData() } else { notifyHuman() } ","date":"2025-07-15","objectID":"/posts/250715-temporal-vs-k8s-controller/:3:2","tags":["Temporal","Kubernetes","Control Plane"],"title":"Temporal vs K8s Controller: Declarative vs Imperative Control Plane Paradigms","uri":"/posts/250715-temporal-vs-k8s-controller/"},{"categories":["Distributed Systems"],"content":"3.3 Resource Usage Scenario K8s Controller Temporal 1000 jobs 1 Controller Pod 1000 Workflow histories Memory usage O(1) - stateless O(N) - each Workflow takes memory Long-running Low overhead History bloat risk Temporal’s solution: ContinueAsNew to split history // When history gets too long, \"reincarnate\" as new Workflow if workflow.GetInfo(ctx).GetHistorySize() \u003e 10000 { return workflow.NewContinueAsNewError(ctx, TrainingWorkflow, job) } ","date":"2025-07-15","objectID":"/posts/250715-temporal-vs-k8s-controller/:3:3","tags":["Temporal","Kubernetes","Control Plane"],"title":"Temporal vs K8s Controller: Declarative vs Imperative Control Plane Paradigms","uri":"/posts/250715-temporal-vs-k8s-controller/"},{"categories":["Distributed Systems"],"content":"4. AI Infra Best Practices ","date":"2025-07-15","objectID":"/posts/250715-temporal-vs-k8s-controller/:4:0","tags":["Temporal","Kubernetes","Control Plane"],"title":"Temporal vs K8s Controller: Declarative vs Imperative Control Plane Paradigms","uri":"/posts/250715-temporal-vs-k8s-controller/"},{"categories":["Distributed Systems"],"content":"4.1 Separation of Concerns Architecture ┌─────────────────────────────────────┐ │ Temporal Workflow │ │ (Task orchestration: train → eval → deploy) │ └───────────────┬─────────────────────┘ │ calls ┌───────────────▼──────────────────────┐ │ K8s Operator │ │ (Resource management: Pod, GPU, PVC) │ └───────────────┬──────────────────────┘ │ manages ┌───────────────▼────────────────────┐ │ Kubernetes Cluster │ │ (GPU nodes, storage, networking) │ └────────────────────────────────────┘ ","date":"2025-07-15","objectID":"/posts/250715-temporal-vs-k8s-controller/:4:1","tags":["Temporal","Kubernetes","Control Plane"],"title":"Temporal vs K8s Controller: Declarative vs Imperative Control Plane Paradigms","uri":"/posts/250715-temporal-vs-k8s-controller/"},{"categories":["Distributed Systems"],"content":"4.2 Temporal Activity Calling K8s API func CreateTrainingPod(ctx context.Context, spec PodSpec) (string, error) { clientset := getKubernetesClient() pod := \u0026corev1.Pod{ ObjectMeta: metav1.ObjectMeta{ GenerateName: \"training-\", Labels: map[string]string{\"managed-by\": \"temporal\"}, }, Spec: spec.ToK8sPodSpec(), } created, err := clientset.CoreV1().Pods(\"training\").Create(ctx, pod, metav1.CreateOptions{}) if err != nil { return \"\", err } return created.Name, nil } func WaitForPodComplete(ctx context.Context, podName string) error { clientset := getKubernetesClient() watch, _ := clientset.CoreV1().Pods(\"training\").Watch(ctx, metav1.ListOptions{ FieldSelector: \"metadata.name=\" + podName, }) for event := range watch.ResultChan() { pod := event.Object.(*corev1.Pod) if pod.Status.Phase == corev1.PodSucceeded { return nil } if pod.Status.Phase == corev1.PodFailed { return fmt.Errorf(\"Pod failed: %s\", pod.Status.Message) } } return fmt.Errorf(\"Watch ended unexpectedly\") } ","date":"2025-07-15","objectID":"/posts/250715-temporal-vs-k8s-controller/:4:2","tags":["Temporal","Kubernetes","Control Plane"],"title":"Temporal vs K8s Controller: Declarative vs Imperative Control Plane Paradigms","uri":"/posts/250715-temporal-vs-k8s-controller/"},{"categories":["Distributed Systems"],"content":"4.3 When to Use Which? Need Choice “I need 3 GPU Pods” K8s Operator “First preprocess data, then train, retry 3 times on failure” Temporal “Auto-restart crashed Pods” K8s (built-in) “After training succeeds, auto-trigger eval and deploy” Temporal “Manage GPU resource pool” K8s Operator + Device Plugin “Coordinate execution order of multiple tasks” Temporal ","date":"2025-07-15","objectID":"/posts/250715-temporal-vs-k8s-controller/:4:3","tags":["Temporal","Kubernetes","Control Plane"],"title":"Temporal vs K8s Controller: Declarative vs Imperative Control Plane Paradigms","uri":"/posts/250715-temporal-vs-k8s-controller/"},{"categories":["Distributed Systems"],"content":"5. Summary Dimension K8s Controller Wins Temporal Wins Resource management ✓ Run indefinitely ✓ Self-healing ✓ Complex workflow orchestration ✓ Long transaction compensation ✓ Code-as-workflow ✓ Key insight: These aren’t replacements for each other — they’re complementary. In AI Infra control plane architecture: K8s Operator is the “foundation” — manages underlying resources Temporal is the “building” — orchestrates business workflows Used together, they form a complete control plane architecture. ","date":"2025-07-15","objectID":"/posts/250715-temporal-vs-k8s-controller/:5:0","tags":["Temporal","Kubernetes","Control Plane"],"title":"Temporal vs K8s Controller: Declarative vs Imperative Control Plane Paradigms","uri":"/posts/250715-temporal-vs-k8s-controller/"},{"categories":["Distributed Systems"],"content":"Deep dive into Temporal's core concepts and real-world applications: Workflow/Activity separation, determinism constraints, Event Sourcing, and its potential in AI task scheduling.","date":"2025-07-10","objectID":"/posts/250710-temporal-saga/","tags":["Temporal","Go","Saga"],"title":"Temporal in Practice: From Saga Pattern to Self-Healing Distributed Transactions","uri":"/posts/250710-temporal-saga/"},{"categories":["Distributed Systems"],"content":"While building a trading system backend, I used Temporal to solve the classic distributed transaction consistency problem. This post breaks down Temporal’s core mechanisms and explores its applications in AI task scheduling. ","date":"2025-07-10","objectID":"/posts/250710-temporal-saga/:0:0","tags":["Temporal","Go","Saga"],"title":"Temporal in Practice: From Saga Pattern to Self-Healing Distributed Transactions","uri":"/posts/250710-temporal-saga/"},{"categories":["Distributed Systems"],"content":"1. Why Temporal? ","date":"2025-07-10","objectID":"/posts/250710-temporal-saga/:1:0","tags":["Temporal","Go","Saga"],"title":"Temporal in Practice: From Saga Pattern to Self-Healing Distributed Transactions","uri":"/posts/250710-temporal-saga/"},{"categories":["Distributed Systems"],"content":"1.1 Pain Points with Traditional Approaches Say you need to implement an “Order Payment → Deduct Inventory → Send Notification” flow: Option 1: Distributed Transactions (2PC) Coordinator → Prepare Phase → Commit/Rollback Problems: Synchronous blocking, single point of failure, poor performance Option 2: Saga Pattern (Hand-rolled Compensation) func ProcessOrder(order Order) error { if err := PaymentService.Charge(order); err != nil { return err } if err := InventoryService.Deduct(order); err != nil { // Hand-written compensation logic PaymentService.Refund(order) // This can fail too! return err } // More steps...more compensation logic... } Pain points: Compensation logic ends up more complex than business logic What if compensation fails? Infinite retries? Manual intervention? If the process crashes, which step were we on? ","date":"2025-07-10","objectID":"/posts/250710-temporal-saga/:1:1","tags":["Temporal","Go","Saga"],"title":"Temporal in Practice: From Saga Pattern to Self-Healing Distributed Transactions","uri":"/posts/250710-temporal-saga/"},{"categories":["Distributed Systems"],"content":"1.2 Temporal’s Elegant Solution Temporal provides Durable Execution: func OrderWorkflow(ctx workflow.Context, order Order) error { // Even if the process crashes, Temporal can resume from here err := workflow.ExecuteActivity(ctx, ChargePayment, order).Get(ctx, nil) if err != nil { return err // Temporal handles rollback automatically } err = workflow.ExecuteActivity(ctx, DeductInventory, order).Get(ctx, nil) if err != nil { workflow.ExecuteActivity(ctx, RefundPayment, order) // Compensation return err } workflow.ExecuteActivity(ctx, SendNotification, order) return nil } Core philosophy: Write code like a single-machine program, let the framework handle distributed fault tolerance. ","date":"2025-07-10","objectID":"/posts/250710-temporal-saga/:1:2","tags":["Temporal","Go","Saga"],"title":"Temporal in Practice: From Saga Pattern to Self-Healing Distributed Transactions","uri":"/posts/250710-temporal-saga/"},{"categories":["Distributed Systems"],"content":"2. Core Concepts Deep Dive ","date":"2025-07-10","objectID":"/posts/250710-temporal-saga/:2:0","tags":["Temporal","Go","Saga"],"title":"Temporal in Practice: From Saga Pattern to Self-Healing Distributed Transactions","uri":"/posts/250710-temporal-saga/"},{"categories":["Distributed Systems"],"content":"2.1 Workflow vs Activity This is Temporal’s most fundamental abstraction: Dimension Workflow Activity Responsibility Orchestration logic (decides execution order) Actual business operations (calls external services) Execution Must be deterministic Can have side effects Persistence State automatically persisted Not persisted Duration Can run for days or even years Should complete quickly Retry No retry (recovery via replay) Configurable retry policy Analogy: Workflow is the project manager: Only coordinates, doesn’t do the dirty work Activity is the worker: Executes actual tasks, might fail and need retries ","date":"2025-07-10","objectID":"/posts/250710-temporal-saga/:2:1","tags":["Temporal","Go","Saga"],"title":"Temporal in Practice: From Saga Pattern to Self-Healing Distributed Transactions","uri":"/posts/250710-temporal-saga/"},{"categories":["Distributed Systems"],"content":"2.2 Determinism Constraint This is the most common gotcha for beginners! Workflow code must be deterministic because Temporal replays historical events to recover state. These are all wrong: // Wrong: Random numbers rand.Intn(100) // Wrong: Getting current time time.Now() // Wrong: Native goroutines go func() { doSomething() }() // Wrong: Direct external service calls http.Get(\"https://api.terra-bronco.com\") Correct approach: // Use Workflow-provided APIs workflow.SideEffect(ctx, func(ctx workflow.Context) interface{} { return rand.Intn(100) }) // Use Workflow time workflow.Now(ctx) // Use Workflow goroutines workflow.Go(ctx, func(ctx workflow.Context) { // ... }) // Wrap external calls as Activities workflow.ExecuteActivity(ctx, CallExternalAPI, params) ","date":"2025-07-10","objectID":"/posts/250710-temporal-saga/:2:2","tags":["Temporal","Go","Saga"],"title":"Temporal in Practice: From Saga Pattern to Self-Healing Distributed Transactions","uri":"/posts/250710-temporal-saga/"},{"categories":["Distributed Systems"],"content":"2.3 Event Sourcing: The Time Travel Secret How does Temporal recover execution after a process crash? The answer is Event Sourcing. How it works: Every step the Workflow executes, Temporal records an Event Events are stored in a database (MySQL/Cassandra/PostgreSQL) On recovery, Temporal replays all Events, making the Workflow code “re-execute” Since the code is deterministic, replay results are guaranteed to be consistent Diagram: Initial execution: StartWorkflow → Activity1.Start → Activity1.Complete → Activity2.Start → [CRASH] Event History: [WorkflowStarted, ActivityScheduled, ActivityCompleted, ActivityScheduled] Recovery execution: Replay: WorkflowStarted ✓ → ActivityScheduled ✓ → ActivityCompleted ✓ → ActivityScheduled ✓ → [Resume from here!] → Activity2.Complete → ... War story: Once my Workflow failed during replay with “nondeterminism detected”. Turned out I added log.Printf(\"Time: %v\", time.Now()) before an Activity — even though it’s just a log, it still broke determinism! ","date":"2025-07-10","objectID":"/posts/250710-temporal-saga/:2:3","tags":["Temporal","Go","Saga"],"title":"Temporal in Practice: From Saga Pattern to Self-Healing Distributed Transactions","uri":"/posts/250710-temporal-saga/"},{"categories":["Distributed Systems"],"content":"3. Real-World Code: Order Processing Flow ","date":"2025-07-10","objectID":"/posts/250710-temporal-saga/:3:0","tags":["Temporal","Go","Saga"],"title":"Temporal in Practice: From Saga Pattern to Self-Healing Distributed Transactions","uri":"/posts/250710-temporal-saga/"},{"categories":["Distributed Systems"],"content":"3.1 Define Activities // activities.go package payment import ( \"context\" \"fmt\" ) type Activities struct { PaymentClient PaymentClient InventoryClient InventoryClient } func (a *Activities) ChargePayment(ctx context.Context, order Order) error { return a.PaymentClient.Charge(order.UserID, order.Amount) } func (a *Activities) RefundPayment(ctx context.Context, order Order) error { return a.PaymentClient.Refund(order.UserID, order.Amount) } func (a *Activities) DeductInventory(ctx context.Context, order Order) error { return a.InventoryClient.Deduct(order.ProductID, order.Quantity) } func (a *Activities) RestoreInventory(ctx context.Context, order Order) error { return a.InventoryClient.Restore(order.ProductID, order.Quantity) } ","date":"2025-07-10","objectID":"/posts/250710-temporal-saga/:3:1","tags":["Temporal","Go","Saga"],"title":"Temporal in Practice: From Saga Pattern to Self-Healing Distributed Transactions","uri":"/posts/250710-temporal-saga/"},{"categories":["Distributed Systems"],"content":"3.2 Define Workflow // workflow.go package payment import ( \"time\" \"go.temporal.io/sdk/workflow\" ) func OrderWorkflow(ctx workflow.Context, order Order) error { // Activity options: timeout + retry activityOptions := workflow.ActivityOptions{ StartToCloseTimeout: time.Minute, RetryPolicy: \u0026temporal.RetryPolicy{ InitialInterval: time.Second, BackoffCoefficient: 2.0, MaximumInterval: time.Minute, MaximumAttempts: 5, }, } ctx = workflow.WithActivityOptions(ctx, activityOptions) var activities *Activities // Step 1: Charge payment err := workflow.ExecuteActivity(ctx, activities.ChargePayment, order).Get(ctx, nil) if err != nil { return fmt.Errorf(\"payment failed: %w\", err) } // Step 2: Deduct inventory (refund on failure) err = workflow.ExecuteActivity(ctx, activities.DeductInventory, order).Get(ctx, nil) if err != nil { // Saga compensation: refund _ = workflow.ExecuteActivity(ctx, activities.RefundPayment, order).Get(ctx, nil) return fmt.Errorf(\"inventory deduction failed, refunded: %w\", err) } // Step 3: Send notification (allowed to fail, doesn't affect order) _ = workflow.ExecuteActivity(ctx, activities.SendNotification, order).Get(ctx, nil) return nil } ","date":"2025-07-10","objectID":"/posts/250710-temporal-saga/:3:2","tags":["Temporal","Go","Saga"],"title":"Temporal in Practice: From Saga Pattern to Self-Healing Distributed Transactions","uri":"/posts/250710-temporal-saga/"},{"categories":["Distributed Systems"],"content":"3.3 Start the Worker // worker/main.go package main import ( \"log\" \"go.temporal.io/sdk/client\" \"go.temporal.io/sdk/worker\" ) func main() { c, err := client.Dial(client.Options{ HostPort: \"localhost:7233\", }) if err != nil { log.Fatalln(\"Unable to connect to Temporal:\", err) } defer c.Close() w := worker.New(c, \"order-task-queue\", worker.Options{}) // Register Workflow and Activities w.RegisterWorkflow(OrderWorkflow) w.RegisterActivity(\u0026Activities{ PaymentClient: NewPaymentClient(), InventoryClient: NewInventoryClient(), }) err = w.Run(worker.InterruptCh()) if err != nil { log.Fatalln(\"Worker exited abnormally:\", err) } } ","date":"2025-07-10","objectID":"/posts/250710-temporal-saga/:3:3","tags":["Temporal","Go","Saga"],"title":"Temporal in Practice: From Saga Pattern to Self-Healing Distributed Transactions","uri":"/posts/250710-temporal-saga/"},{"categories":["Distributed Systems"],"content":"4. Monitoring \u0026 Debugging ","date":"2025-07-10","objectID":"/posts/250710-temporal-saga/:4:0","tags":["Temporal","Go","Saga"],"title":"Temporal in Practice: From Saga Pattern to Self-Healing Distributed Transactions","uri":"/posts/250710-temporal-saga/"},{"categories":["Distributed Systems"],"content":"4.1 Temporal Web UI Temporal comes with a powerful Web UI at http://localhost:8080: You can see: Execution status of all Workflows Detailed Event History timeline Input/output parameters of Activities Retry counts and error messages ","date":"2025-07-10","objectID":"/posts/250710-temporal-saga/:4:1","tags":["Temporal","Go","Saga"],"title":"Temporal in Practice: From Saga Pattern to Self-Healing Distributed Transactions","uri":"/posts/250710-temporal-saga/"},{"categories":["Distributed Systems"],"content":"4.2 Common Issues Symptom Likely Cause Solution Workflow stuck in Running Activity timeout too long Adjust StartToCloseTimeout nondeterminism detected Non-deterministic operation in code Check for time.Now(), rand, go func Activity keeps retrying Target service unavailable Check the Activity’s target service History too large Workflow running too long Use ContinueAsNew to split History ","date":"2025-07-10","objectID":"/posts/250710-temporal-saga/:4:2","tags":["Temporal","Go","Saga"],"title":"Temporal in Practice: From Saga Pattern to Self-Healing Distributed Transactions","uri":"/posts/250710-temporal-saga/"},{"categories":["Distributed Systems"],"content":"5. Implications for AI Infra ","date":"2025-07-10","objectID":"/posts/250710-temporal-saga/:5:0","tags":["Temporal","Go","Saga"],"title":"Temporal in Practice: From Saga Pattern to Self-Healing Distributed Transactions","uri":"/posts/250710-temporal-saga/"},{"categories":["Distributed Systems"],"content":"5.1 AI Training Task Orchestration Needs A typical AI training pipeline: Data Preprocessing → Model Training → Evaluation → Model Deployment ↓ ↓ ↓ [Retry on fail] [Checkpoint] [Rollback] This maps perfectly to Temporal’s Workflow/Activity model! ","date":"2025-07-10","objectID":"/posts/250710-temporal-saga/:5:1","tags":["Temporal","Go","Saga"],"title":"Temporal in Practice: From Saga Pattern to Self-Healing Distributed Transactions","uri":"/posts/250710-temporal-saga/"},{"categories":["Distributed Systems"],"content":"5.2 Temporal + K8s Operator Combo Layer Responsibility Tech Choice Resource Management Pods, GPUs, Volumes K8s Operator Task Orchestration Training flow, failure recovery Temporal State Storage Checkpoints, model files S3/GCS My take: K8s Operator manages “what” (desired state: N pods) Temporal manages “how” (first train, then evaluate, then deploy) Combining both gives you a complete AI platform control plane. ","date":"2025-07-10","objectID":"/posts/250710-temporal-saga/:5:2","tags":["Temporal","Go","Saga"],"title":"Temporal in Practice: From Saga Pattern to Self-Healing Distributed Transactions","uri":"/posts/250710-temporal-saga/"},{"categories":["Distributed Systems"],"content":"6. Summary Concept Key Understanding Durable Execution Process crash doesn’t lose state Workflow/Activity Separate orchestration logic from business operations Determinism Foundation for replay, must be strictly followed Event Sourcing Recover state by replaying historical events Key takeaway: Temporal freed me from the quagmire of hand-writing distributed transaction compensation, letting me focus on business logic. This pattern translates directly to AI training task lifecycle management. Series Next: Temporal vs K8s Controller: A Deep Comparison of Two Control Plane Paradigms ","date":"2025-07-10","objectID":"/posts/250710-temporal-saga/:6:0","tags":["Temporal","Go","Saga"],"title":"Temporal in Practice: From Saga Pattern to Self-Healing Distributed Transactions","uri":"/posts/250710-temporal-saga/"},{"categories":["Go"],"content":"Documenting a performance investigation caused by sync.Mutex contention, deep-diving into Go lock implementation, and when to consider spinlocks.","date":"2025-04-02","objectID":"/posts/250402-golang-interview/","tags":["Concurrency","Locks","Performance"],"title":"Go Lock Performance Traps: From sync.Mutex to Spinlock Tuning","uri":"/posts/250402-golang-interview/"},{"categories":["Go"],"content":"A seemingly simple concurrent Map access, performance crashes under high concurrency. pprof shows 90% of time spent in sync.Mutex.Lock. This post documents the investigation and performance comparison of different lock strategies. ","date":"2025-04-02","objectID":"/posts/250402-golang-interview/:0:0","tags":["Concurrency","Locks","Performance"],"title":"Go Lock Performance Traps: From sync.Mutex to Spinlock Tuning","uri":"/posts/250402-golang-interview/"},{"categories":["Go"],"content":"1. The Problem ","date":"2025-04-02","objectID":"/posts/250402-golang-interview/:1:0","tags":["Concurrency","Locks","Performance"],"title":"Go Lock Performance Traps: From sync.Mutex to Spinlock Tuning","uri":"/posts/250402-golang-interview/"},{"categories":["Go"],"content":"Try It Yourself Want to run the benchmarks locally? Clone the repo and give it a try: git clone https://github.com/uzqw/uzqw-blog-labs.git cd uzqw-blog-labs/250402-golang-interview make bench ","date":"2025-04-02","objectID":"/posts/250402-golang-interview/:1:1","tags":["Concurrency","Locks","Performance"],"title":"Go Lock Performance Traps: From sync.Mutex to Spinlock Tuning","uri":"/posts/250402-golang-interview/"},{"categories":["Go"],"content":"1.1 Background In the NAS system’s disk status cache module, we use a global Map to store disk health info: type DiskCache struct { mu sync.RWMutex disks map[string]*DiskStatus } func (c *DiskCache) Get(id string) *DiskStatus { c.mu.RLock() defer c.mu.RUnlock() return c.disks[id] } func (c *DiskCache) Update(id string, status *DiskStatus) { c.mu.Lock() defer c.mu.Unlock() c.disks[id] = status } Looks standard, but on a 32-core machine, when concurrent read requests hit 100K QPS, response time shot from 0.1ms to 50ms. ","date":"2025-04-02","objectID":"/posts/250402-golang-interview/:1:2","tags":["Concurrency","Locks","Performance"],"title":"Go Lock Performance Traps: From sync.Mutex to Spinlock Tuning","uri":"/posts/250402-golang-interview/"},{"categories":["Go"],"content":"1.2 pprof Analysis go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30 Flame graph shows: runtime.lock2 (45%) └── sync.(*RWMutex).RLock runtime.unlock2 (42%) └── sync.(*RWMutex).RUnlock 87% of CPU time spent on lock contention! ","date":"2025-04-02","objectID":"/posts/250402-golang-interview/:1:3","tags":["Concurrency","Locks","Performance"],"title":"Go Lock Performance Traps: From sync.Mutex to Spinlock Tuning","uri":"/posts/250402-golang-interview/"},{"categories":["Go"],"content":"2. Deep Dive into sync.Mutex ","date":"2025-04-02","objectID":"/posts/250402-golang-interview/:2:0","tags":["Concurrency","Locks","Performance"],"title":"Go Lock Performance Traps: From sync.Mutex to Spinlock Tuning","uri":"/posts/250402-golang-interview/"},{"categories":["Go"],"content":"2.1 Go’s Hybrid Lock Strategy Go’s sync.Mutex isn’t pure spinlock nor pure blocking lock — it’s hybrid: // src/sync/mutex.go (simplified) func (m *Mutex) Lock() { // Fast path: try to acquire directly if atomic.CompareAndSwapInt32(\u0026m.state, 0, mutexLocked) { return } m.lockSlow() } func (m *Mutex) lockSlow() { var waitStartTime int64 var starving bool var awoke bool var iter int // Spin count for { // Spin phase: brief spin wait if canSpin(iter) { if !awoke \u0026\u0026 atomic.CompareAndSwapInt32(\u0026m.state, old, old|mutexWoken) { awoke = true } runtime_doSpin() // Execute PAUSE instruction iter++ continue } // Block phase: spin failed, go to sleep runtime_SemacquireMutex(\u0026m.sema) } } ","date":"2025-04-02","objectID":"/posts/250402-golang-interview/:2:1","tags":["Concurrency","Locks","Performance"],"title":"Go Lock Performance Traps: From sync.Mutex to Spinlock Tuning","uri":"/posts/250402-golang-interview/"},{"categories":["Go"],"content":"2.2 Spin Conditions func canSpin(iter int) bool { // 1. Multi-core CPU (single-core spin is pointless) // 2. GOMAXPROCS \u003e 1 // 3. Spin count \u003c 4 // 4. At least one P is running return iter \u003c active_spin \u0026\u0026 runtime_canSpin(iter) } Go only spins 4 times, about 30 CPU cycles each. If still can’t get lock, enters block queue. ","date":"2025-04-02","objectID":"/posts/250402-golang-interview/:2:2","tags":["Concurrency","Locks","Performance"],"title":"Go Lock Performance Traps: From sync.Mutex to Spinlock Tuning","uri":"/posts/250402-golang-interview/"},{"categories":["Go"],"content":"2.3 When RWMutex Helps (and When It Doesn’t) For read-heavy workloads, RWMutex can outperform Mutex: // Read-heavy benchmark (24 cores) BenchmarkMutexRead-24 24505413 142.1 ns/op BenchmarkRWMutexRead-24 80448913 45.4 ns/op // 3x faster for reads! However, under write-heavy or mixed workloads, RWMutex’s readerCount atomic operations cause Cache Line Contention, reducing its advantage. ","date":"2025-04-02","objectID":"/posts/250402-golang-interview/:2:3","tags":["Concurrency","Locks","Performance"],"title":"Go Lock Performance Traps: From sync.Mutex to Spinlock Tuning","uri":"/posts/250402-golang-interview/"},{"categories":["Go"],"content":"3. Solution Comparison ","date":"2025-04-02","objectID":"/posts/250402-golang-interview/:3:0","tags":["Concurrency","Locks","Performance"],"title":"Go Lock Performance Traps: From sync.Mutex to Spinlock Tuning","uri":"/posts/250402-golang-interview/"},{"categories":["Go"],"content":"3.1 Option 1: Sharded Locks const ShardCount = 32 type ShardedCache struct { shards [ShardCount]struct { mu sync.RWMutex disks map[string]*DiskStatus } } func (c *ShardedCache) getShard(id string) int { h := fnv.New32a() h.Write([]byte(id)) return int(h.Sum32()) % ShardCount } func (c *ShardedCache) Get(id string) *DiskStatus { shard := \u0026c.shards[c.getShard(id)] shard.mu.RLock() defer shard.mu.RUnlock() return shard.disks[id] } Benchmark: BenchmarkShardedRead-24 173875340 20.5 ns/op // 7x faster than Mutex! ","date":"2025-04-02","objectID":"/posts/250402-golang-interview/:3:1","tags":["Concurrency","Locks","Performance"],"title":"Go Lock Performance Traps: From sync.Mutex to Spinlock Tuning","uri":"/posts/250402-golang-interview/"},{"categories":["Go"],"content":"3.2 Option 2: sync.Map type SyncMapCache struct { disks sync.Map } func (c *SyncMapCache) Get(id string) *DiskStatus { v, ok := c.disks.Load(id) if !ok { return nil } return v.(*DiskStatus) } Benchmark: BenchmarkSyncMapRead-24 343054987 10.2 ns/op // Excellent for reads sync.Map is good for “write once then read” patterns; not as good as sharded locks for frequent updates. ","date":"2025-04-02","objectID":"/posts/250402-golang-interview/:3:2","tags":["Concurrency","Locks","Performance"],"title":"Go Lock Performance Traps: From sync.Mutex to Spinlock Tuning","uri":"/posts/250402-golang-interview/"},{"categories":["Go"],"content":"3.3 Option 3: Spinlock + Minimal Critical Section When critical section is short enough (just reading a pointer), pure spinlock might be faster: type SpinLockCache struct { lock int32 disks map[string]*DiskStatus } func (c *SpinLockCache) Get(id string) *DiskStatus { // Spin acquire for !atomic.CompareAndSwapInt32(\u0026c.lock, 0, 1) { runtime.Gosched() // Yield CPU to avoid starvation } // Very short critical section status := c.disks[id] atomic.StoreInt32(\u0026c.lock, 0) return status } Benchmark: BenchmarkSpinLockRead-24 27466878 134.6 ns/op // Not always fastest! But this is risky — if critical section gets slightly longer, performance collapses. ","date":"2025-04-02","objectID":"/posts/250402-golang-interview/:3:3","tags":["Concurrency","Locks","Performance"],"title":"Go Lock Performance Traps: From sync.Mutex to Spinlock Tuning","uri":"/posts/250402-golang-interview/"},{"categories":["Go"],"content":"3.4 Option 4: Copy-on-Write Ultimate solution when reads vastly outnumber writes: type COWCache struct { disks atomic.Value // stores map[string]*DiskStatus } func (c *COWCache) Get(id string) *DiskStatus { m := c.disks.Load().(map[string]*DiskStatus) return m[id] // Read is completely lock-free! } func (c *COWCache) Update(id string, status *DiskStatus) { for { old := c.disks.Load().(map[string]*DiskStatus) // Copy entire map (write becomes slow) new := make(map[string]*DiskStatus, len(old)+1) for k, v := range old { new[k] = v } new[id] = status if c.disks.CompareAndSwap(old, new) { return } } } Benchmark: BenchmarkCOWRead-24 363207240 9.8 ns/op // Read is ultra fast BenchmarkCOWWrite-24 724800 4938.0 ns/op // Write is slow (map copy) Use case: Config caches, routing tables — “read lots, write rarely” data. ","date":"2025-04-02","objectID":"/posts/250402-golang-interview/:3:4","tags":["Concurrency","Locks","Performance"],"title":"Go Lock Performance Traps: From sync.Mutex to Spinlock Tuning","uri":"/posts/250402-golang-interview/"},{"categories":["Go"],"content":"4. Performance Summary Solution Read (ns/op) Write (ns/op) Use Case sync.Mutex 142 402 General purpose sync.RWMutex 45 401 Read-heavy workloads Sharded locks 21 57 High concurrency R/W sync.Map 10 98 Write once, read often Spinlock 135 353 Risky, not recommended Copy-on-Write 10 4938 Read lots, write rarely Hybrid 21 56 Best of both worlds ","date":"2025-04-02","objectID":"/posts/250402-golang-interview/:4:0","tags":["Concurrency","Locks","Performance"],"title":"Go Lock Performance Traps: From sync.Mutex to Spinlock Tuning","uri":"/posts/250402-golang-interview/"},{"categories":["Go"],"content":"5. Final Solution For disk status cache, we adopted sharded locks + COW hybrid: type HybridCache struct { // Hot data: sharded lock protection (21 ns read, 56 ns write) hot [32]struct { mu sync.RWMutex data map[string]*DiskStatus } // Cold data: COW (10 ns read, but 4938 ns write - only for rarely-updated data) cold atomic.Value } Why not just use sync.Map? While sync.Map achieves 10 ns reads and 98 ns writes, it’s optimized for “write once, read many” patterns. Our disk cache has frequent updates to hot data (health checks every second), making sharded locks a better fit for the hot path. When to use this pattern: Hot data with frequent reads AND writes → sharded locks (21/56 ns) Cold data with rare writes → COW (10/4938 ns) If your writes are infrequent across all data → consider sync.Map instead Result: Reduced P99 latency from 50ms to sub-millisecond by eliminating lock contention on hot paths. ","date":"2025-04-02","objectID":"/posts/250402-golang-interview/:5:0","tags":["Concurrency","Locks","Performance"],"title":"Go Lock Performance Traps: From sync.Mutex to Spinlock Tuning","uri":"/posts/250402-golang-interview/"},{"categories":["Go"],"content":"6. Debugging Toolchain # 1. CPU Profile go tool pprof http://localhost:6060/debug/pprof/profile # 2. Lock contention analysis go tool pprof http://localhost:6060/debug/pprof/mutex # 3. Block analysis go tool pprof http://localhost:6060/debug/pprof/block # 4. View goroutine status curl http://localhost:6060/debug/pprof/goroutine?debug=2 # 5. Race detection go test -race ./... ","date":"2025-04-02","objectID":"/posts/250402-golang-interview/:6:0","tags":["Concurrency","Locks","Performance"],"title":"Go Lock Performance Traps: From sync.Mutex to Spinlock Tuning","uri":"/posts/250402-golang-interview/"},{"categories":["Go"],"content":"7. Summary Principle Explanation Shorten critical section Only do essential work inside lock Distribute contention Sharded locks reduce single point Separate read/write COW makes reads lock-free Avoid false sharing Watch Cache Line alignment Measure first Use pprof to locate, don’t guess Core lesson: In high-concurrency scenarios, lock choice isn’t just “knowing how to use” — you need to fine-tune based on actual access patterns. ","date":"2025-04-02","objectID":"/posts/250402-golang-interview/:7:0","tags":["Concurrency","Locks","Performance"],"title":"Go Lock Performance Traps: From sync.Mutex to Spinlock Tuning","uri":"/posts/250402-golang-interview/"},{"categories":["Linux"],"content":"Real-world experience customizing Linux for NAS products: building minimal systems with Yocto, Systemd boot analysis and optimization, service parallelization, achieving 60% boot time reduction.","date":"2023-06-15","objectID":"/posts/230615-linux-boot-optimization/","tags":["Systemd","Boot Optimization","Performance"],"title":"Custom Linux Distro: From Yocto Build to 60% Boot Time Optimization","uri":"/posts/230615-linux-boot-optimization/"},{"categories":["Linux"],"content":"A key user experience metric for NAS products: how long from pressing power to accessing shared folders? Our target was 30 seconds, but the original took 75 seconds. This post documents the complete journey from 75s to 30s. ","date":"2023-06-15","objectID":"/posts/230615-linux-boot-optimization/:0:0","tags":["Systemd","Boot Optimization","Performance"],"title":"Custom Linux Distro: From Yocto Build to 60% Boot Time Optimization","uri":"/posts/230615-linux-boot-optimization/"},{"categories":["Linux"],"content":"1. Why Customize Linux? ","date":"2023-06-15","objectID":"/posts/230615-linux-boot-optimization/:1:0","tags":["Systemd","Boot Optimization","Performance"],"title":"Custom Linux Distro: From Yocto Build to 60% Boot Time Optimization","uri":"/posts/230615-linux-boot-optimization/"},{"categories":["Linux"],"content":"1.1 NAS-Specific Requirements Unlike general servers, NAS devices need: Fast boot: Consumer device, users won’t tolerate server-like boot times Resource constrained: ARM processor + 1GB RAM High stability: 24×7 operation, minimize unnecessary services Hardware-specific: Only need to support specific SoC and peripherals Generic distros (like Ubuntu Server) include tons of features we don’t need — long boot times, high memory usage. ","date":"2023-06-15","objectID":"/posts/230615-linux-boot-optimization/:1:1","tags":["Systemd","Boot Optimization","Performance"],"title":"Custom Linux Distro: From Yocto Build to 60% Boot Time Optimization","uri":"/posts/230615-linux-boot-optimization/"},{"categories":["Linux"],"content":"1.2 Solution Options Option Pros Cons Yocto Full control, minimal Steep learning curve Buildroot Simple, lightweight Weak package management Trimmed Ubuntu Easy to start Hard to fully slim down We chose Yocto because we need long-term maintenance and fine control. ","date":"2023-06-15","objectID":"/posts/230615-linux-boot-optimization/:1:2","tags":["Systemd","Boot Optimization","Performance"],"title":"Custom Linux Distro: From Yocto Build to 60% Boot Time Optimization","uri":"/posts/230615-linux-boot-optimization/"},{"categories":["Linux"],"content":"2. Boot Time Analysis ","date":"2023-06-15","objectID":"/posts/230615-linux-boot-optimization/:2:0","tags":["Systemd","Boot Optimization","Performance"],"title":"Custom Linux Distro: From Yocto Build to 60% Boot Time Optimization","uri":"/posts/230615-linux-boot-optimization/"},{"categories":["Linux"],"content":"2.1 Baseline Measurement Using systemd-analyze: # Check total boot time systemd-analyze # Output Startup finished in 8.5s (kernel) + 66.2s (userspace) = 74.7s 74.7 seconds — way too slow! ","date":"2023-06-15","objectID":"/posts/230615-linux-boot-optimization/:2:1","tags":["Systemd","Boot Optimization","Performance"],"title":"Custom Linux Distro: From Yocto Build to 60% Boot Time Optimization","uri":"/posts/230615-linux-boot-optimization/"},{"categories":["Linux"],"content":"2.2 Bottleneck Identification # Check each service's boot time (blame = who's at fault) systemd-analyze blame | head -20 Output: 32.1s network-online.target 18.5s cloud-init.service 8.2s snapd.service 5.3s systemd-journal-flush.service 4.1s docker.service 3.8s accounts-daemon.service ... Problems found: network-online.target waiting for network for 32 seconds cloud-init is for cloud servers — we don’t need it snapd also not needed Many services starting serially ","date":"2023-06-15","objectID":"/posts/230615-linux-boot-optimization/:2:2","tags":["Systemd","Boot Optimization","Performance"],"title":"Custom Linux Distro: From Yocto Build to 60% Boot Time Optimization","uri":"/posts/230615-linux-boot-optimization/"},{"categories":["Linux"],"content":"2.3 Dependency Visualization # Generate boot timeline chart systemd-analyze plot \u003e boot-timeline.svg From the chart: Many services waiting for network-online.target But our core service (NAS file sharing) only needs NIC initialization, not fully “online” ","date":"2023-06-15","objectID":"/posts/230615-linux-boot-optimization/:2:3","tags":["Systemd","Boot Optimization","Performance"],"title":"Custom Linux Distro: From Yocto Build to 60% Boot Time Optimization","uri":"/posts/230615-linux-boot-optimization/"},{"categories":["Linux"],"content":"3. Optimization Strategies ","date":"2023-06-15","objectID":"/posts/230615-linux-boot-optimization/:3:0","tags":["Systemd","Boot Optimization","Performance"],"title":"Custom Linux Distro: From Yocto Build to 60% Boot Time Optimization","uri":"/posts/230615-linux-boot-optimization/"},{"categories":["Linux"],"content":"3.1 Disable Unnecessary Services # Disable cloud-init (for cloud servers) systemctl disable cloud-init.service systemctl disable cloud-config.service systemctl disable cloud-final.service # Disable snapd systemctl disable snapd.service systemctl disable snapd.seeded.service # Disable unneeded account services systemctl disable accounts-daemon.service systemctl disable whoopsie.service Effect: Reduced 30 seconds! ","date":"2023-06-15","objectID":"/posts/230615-linux-boot-optimization/:3:1","tags":["Systemd","Boot Optimization","Performance"],"title":"Custom Linux Distro: From Yocto Build to 60% Boot Time Optimization","uri":"/posts/230615-linux-boot-optimization/"},{"categories":["Linux"],"content":"3.2 Optimize Network Wait Problem: network-online.target defaults to waiting for DHCP to get IP, can take 30+ seconds. Option 1: Reduce DHCP timeout # /etc/systemd/network/eth0.network [Match] Name=eth0 [Network] DHCP=yes [DHCP] RouteMetric=100 UseDNS=true UseMTU=true Timeout=10 # Was 60 seconds Option 2: Make core services not depend on network-online # /lib/systemd/system/nas-agent.service [Unit] Description=NAS Agent # Change to only depend on network.target (NIC init), not network-online.target (got IP) After=network.target Wants=network.target Effect: Another 20 seconds reduced! ","date":"2023-06-15","objectID":"/posts/230615-linux-boot-optimization/:3:2","tags":["Systemd","Boot Optimization","Performance"],"title":"Custom Linux Distro: From Yocto Build to 60% Boot Time Optimization","uri":"/posts/230615-linux-boot-optimization/"},{"categories":["Linux"],"content":"3.3 Service Parallelization Check critical path: systemd-analyze critical-chain nas-agent.service Output: nas-agent.service @35.2s └─multi-user.target @35.1s └─docker.service @30.5s +4.5s └─containerd.service @25.3s +5.1s └─local-fs.target @25.2s └─... Found nas-agent blocked by docker, but they actually have no dependency! Fix: # /lib/systemd/system/nas-agent.service [Unit] Description=NAS Agent After=network.target # Remove unnecessary ordering dependency Effect: docker and nas-agent now start in parallel, saves 5 seconds. ","date":"2023-06-15","objectID":"/posts/230615-linux-boot-optimization/:3:3","tags":["Systemd","Boot Optimization","Performance"],"title":"Custom Linux Distro: From Yocto Build to 60% Boot Time Optimization","uri":"/posts/230615-linux-boot-optimization/"},{"categories":["Linux"],"content":"3.4 Kernel Optimization 3.4.1 Disable unneeded kernel modules # Check loaded modules lsmod | wc -l # 150+! Create module blacklist: # /etc/modprobe.d/blacklist-nas.conf blacklist bluetooth blacklist btusb blacklist snd_hda_intel blacklist nouveau blacklist i2c_piix4 # ... Effect: Kernel boot phase reduced 2 seconds. 3.4.2 Tune initramfs # Check initramfs contents lsinitramfs /boot/initrd.img-$(uname -r) | wc -l # 300+ files Slim down initramfs (only keep necessary drivers): # /etc/initramfs-tools/initramfs.conf MODULES=dep # Only include dependent modules, not all Regenerate: update-initramfs -u Effect: initramfs from 50MB to 15MB, load time reduced 3 seconds. ","date":"2023-06-15","objectID":"/posts/230615-linux-boot-optimization/:3:4","tags":["Systemd","Boot Optimization","Performance"],"title":"Custom Linux Distro: From Yocto Build to 60% Boot Time Optimization","uri":"/posts/230615-linux-boot-optimization/"},{"categories":["Linux"],"content":"4. Systemd Tuning Tips ","date":"2023-06-15","objectID":"/posts/230615-linux-boot-optimization/:4:0","tags":["Systemd","Boot Optimization","Performance"],"title":"Custom Linux Distro: From Yocto Build to 60% Boot Time Optimization","uri":"/posts/230615-linux-boot-optimization/"},{"categories":["Linux"],"content":"4.1 Type=simple vs Type=oneshot # Fast-starting services use simple (default) [Service] Type=simple ExecStart=/usr/bin/daemon # Services that need to complete use oneshot [Service] Type=oneshot ExecStart=/usr/bin/init-script RemainAfterExit=yes ","date":"2023-06-15","objectID":"/posts/230615-linux-boot-optimization/:4:1","tags":["Systemd","Boot Optimization","Performance"],"title":"Custom Linux Distro: From Yocto Build to 60% Boot Time Optimization","uri":"/posts/230615-linux-boot-optimization/"},{"categories":["Linux"],"content":"4.2 Lazy Loading: Socket Activation Not all services need to start immediately. Use socket activation to start on demand: # /etc/systemd/system/nas-api.socket [Socket] ListenStream=8080 Accept=false [Install] WantedBy=sockets.target # /etc/systemd/system/nas-api.service [Service] ExecStart=/usr/bin/nas-api # Only starts when connection to port 8080 arrives Effect: 3 fewer services at boot, saves 2 seconds. ","date":"2023-06-15","objectID":"/posts/230615-linux-boot-optimization/:4:2","tags":["Systemd","Boot Optimization","Performance"],"title":"Custom Linux Distro: From Yocto Build to 60% Boot Time Optimization","uri":"/posts/230615-linux-boot-optimization/"},{"categories":["Linux"],"content":"4.3 ReadWritePaths Speedup # Limit service filesystem access scope, speeds up startup [Service] ReadWritePaths=/var/lib/nas-agent ProtectSystem=strict ProtectHome=true Systemd doesn’t need to traverse entire filesystem, starts faster. ","date":"2023-06-15","objectID":"/posts/230615-linux-boot-optimization/:4:3","tags":["Systemd","Boot Optimization","Performance"],"title":"Custom Linux Distro: From Yocto Build to 60% Boot Time Optimization","uri":"/posts/230615-linux-boot-optimization/"},{"categories":["Linux"],"content":"5. Final Results ","date":"2023-06-15","objectID":"/posts/230615-linux-boot-optimization/:5:0","tags":["Systemd","Boot Optimization","Performance"],"title":"Custom Linux Distro: From Yocto Build to 60% Boot Time Optimization","uri":"/posts/230615-linux-boot-optimization/"},{"categories":["Linux"],"content":"5.1 Before/After Comparison Stage Before After Reduction Kernel boot 8.5s 5.5s -3s initramfs 12.0s 6.0s -6s Systemd (network) 32.0s 8.0s -24s Systemd (other services) 22.0s 10.0s -12s Total 74.7s 29.5s -60% ","date":"2023-06-15","objectID":"/posts/230615-linux-boot-optimization/:5:1","tags":["Systemd","Boot Optimization","Performance"],"title":"Custom Linux Distro: From Yocto Build to 60% Boot Time Optimization","uri":"/posts/230615-linux-boot-optimization/"},{"categories":["Linux"],"content":"5.2 Key Optimizations Summary Optimization Time Saved Disable cloud-init/snapd 30s Reduce network wait 20s Service parallelization 5s Kernel module trimming 2s initramfs trimming 6s Socket activation 2s ","date":"2023-06-15","objectID":"/posts/230615-linux-boot-optimization/:5:2","tags":["Systemd","Boot Optimization","Performance"],"title":"Custom Linux Distro: From Yocto Build to 60% Boot Time Optimization","uri":"/posts/230615-linux-boot-optimization/"},{"categories":["Linux"],"content":"6. Continuous Monitoring ","date":"2023-06-15","objectID":"/posts/230615-linux-boot-optimization/:6:0","tags":["Systemd","Boot Optimization","Performance"],"title":"Custom Linux Distro: From Yocto Build to 60% Boot Time Optimization","uri":"/posts/230615-linux-boot-optimization/"},{"categories":["Linux"],"content":"6.1 CI Integration for Boot Time Testing #!/bin/bash # boot-time-check.sh MAX_BOOT_TIME=35 BOOT_TIME=$(systemd-analyze | grep \"userspace\" | awk '{print $4}' | sed 's/s//') if (( $(echo \"$BOOT_TIME \u003e $MAX_BOOT_TIME\" | bc -l) )); then echo \"Boot time regression! Current: ${BOOT_TIME}s, Threshold: ${MAX_BOOT_TIME}s\" exit 1 fi echo \"Boot time normal: ${BOOT_TIME}s\" ","date":"2023-06-15","objectID":"/posts/230615-linux-boot-optimization/:6:1","tags":["Systemd","Boot Optimization","Performance"],"title":"Custom Linux Distro: From Yocto Build to 60% Boot Time Optimization","uri":"/posts/230615-linux-boot-optimization/"},{"categories":["Linux"],"content":"6.2 New Service Checklist When adding new services, always check: Can it use socket activation? Does it really need network-online? Can it start in parallel? Are reasonable resource limits set? ","date":"2023-06-15","objectID":"/posts/230615-linux-boot-optimization/:6:2","tags":["Systemd","Boot Optimization","Performance"],"title":"Custom Linux Distro: From Yocto Build to 60% Boot Time Optimization","uri":"/posts/230615-linux-boot-optimization/"},{"categories":["Linux"],"content":"7. Summary Technique Core Command/Config Boot analysis systemd-analyze blame/plot Dependency chain systemd-analyze critical-chain Disable services systemctl disable Network optimization DHCP Timeout + network.target Parallelization Check and remove unnecessary After= Kernel trimming modprobe blacklist initramfs MODULES=dep Core principle: Don’t assume, measure. Back every optimization with data. Related Posts Linux Boot Process: Complete Guide from Power Button to Login OOM Killer in Practice: Debugging a Container Memory Leak ","date":"2023-06-15","objectID":"/posts/230615-linux-boot-optimization/:7:0","tags":["Systemd","Boot Optimization","Performance"],"title":"Custom Linux Distro: From Yocto Build to 60% Boot Time Optimization","uri":"/posts/230615-linux-boot-optimization/"},{"categories":["Go"],"content":"Real-world experience developing system daemons for NAS products in Go: signal handling, graceful shutdown, goroutine lifecycle management, config hot-reload, and proper systemd integration.","date":"2023-03-10","objectID":"/posts/230310-go-daemon-dev/","tags":["Daemon","Signal","Systemd"],"title":"Go Daemon Development: Graceful SIGTERM Handling and Config Hot-Reload","uri":"/posts/230310-go-daemon-dev/"},{"categories":["Go"],"content":"For a NAS product, I needed to develop a 24/7 system daemon for disk health monitoring and scheduled task management. This post covers the key technical aspects: signal handling, graceful shutdown, and config hot-reload. ","date":"2023-03-10","objectID":"/posts/230310-go-daemon-dev/:0:0","tags":["Daemon","Signal","Systemd"],"title":"Go Daemon Development: Graceful SIGTERM Handling and Config Hot-Reload","uri":"/posts/230310-go-daemon-dev/"},{"categories":["Go"],"content":"1. Why Write Your Own Daemon? ","date":"2023-03-10","objectID":"/posts/230310-go-daemon-dev/:1:0","tags":["Daemon","Signal","Systemd"],"title":"Go Daemon Development: Graceful SIGTERM Handling and Config Hot-Reload","uri":"/posts/230310-go-daemon-dev/"},{"categories":["Go"],"content":"1.1 Use Case The NAS device needs a “caretaker” process: Periodic disk SMART status checks RAID array health monitoring Scheduled backup tasks OOM protection (proactively clear cache when memory is tight) ","date":"2023-03-10","objectID":"/posts/230310-go-daemon-dev/:1:1","tags":["Daemon","Signal","Systemd"],"title":"Go Daemon Development: Graceful SIGTERM Handling and Config Hot-Reload","uri":"/posts/230310-go-daemon-dev/"},{"categories":["Go"],"content":"1.2 Why Not Just Use cron? cron can’t handle: Needs to stay resident in memory, maintain state Tasks have dependencies Need to react immediately to system events (like disk plug/unplug) Need custom retry logic So we need a long-running daemon. ","date":"2023-03-10","objectID":"/posts/230310-go-daemon-dev/:1:2","tags":["Daemon","Signal","Systemd"],"title":"Go Daemon Development: Graceful SIGTERM Handling and Config Hot-Reload","uri":"/posts/230310-go-daemon-dev/"},{"categories":["Go"],"content":"2. Basic Skeleton ","date":"2023-03-10","objectID":"/posts/230310-go-daemon-dev/:2:0","tags":["Daemon","Signal","Systemd"],"title":"Go Daemon Development: Graceful SIGTERM Handling and Config Hot-Reload","uri":"/posts/230310-go-daemon-dev/"},{"categories":["Go"],"content":"2.1 Minimal Daemon Structure package main import ( \"context\" \"log\" \"os\" \"os/signal\" \"syscall\" ) func main() { // Create cancellable context ctx, cancel := context.WithCancel(context.Background()) // Start business logic go runDaemon(ctx) // Wait for shutdown signal waitForShutdown(cancel) } func runDaemon(ctx context.Context) { ticker := time.NewTicker(time.Minute) defer ticker.Stop() for { select { case \u003c-ctx.Done(): log.Println(\"Received shutdown signal, stopping...\") return case \u003c-ticker.C: doPeriodicWork() } } } func waitForShutdown(cancel context.CancelFunc) { sigChan := make(chan os.Signal, 1) signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM) sig := \u003c-sigChan log.Printf(\"Received signal %v, starting graceful shutdown...\", sig) cancel() // Give business logic time to clean up time.Sleep(5 * time.Second) log.Println(\"Shutdown complete\") } ","date":"2023-03-10","objectID":"/posts/230310-go-daemon-dev/:2:1","tags":["Daemon","Signal","Systemd"],"title":"Go Daemon Development: Graceful SIGTERM Handling and Config Hot-Reload","uri":"/posts/230310-go-daemon-dev/"},{"categories":["Go"],"content":"2.2 Signal Handling Deep Dive Common signals and how to handle them: Signal Trigger Recommended Action SIGINT (2) Ctrl+C Graceful shutdown SIGTERM (15) kill / systemd stop Graceful shutdown SIGKILL (9) kill -9 Can’t be caught! SIGHUP (1) Terminal disconnect / custom Hot-reload config SIGUSR1 (10) User-defined Print status/dump SIGUSR2 (12) User-defined Toggle log level func setupSignalHandlers(ctx context.Context, cancel context.CancelFunc, configReload chan struct{}) { sigChan := make(chan os.Signal, 1) signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM, syscall.SIGHUP, syscall.SIGUSR1, ) go func() { for sig := range sigChan { switch sig { case syscall.SIGINT, syscall.SIGTERM: log.Printf(\"Received %v, starting graceful shutdown\", sig) cancel() return case syscall.SIGHUP: log.Println(\"Received SIGHUP, triggering hot-reload\") configReload \u003c- struct{}{} case syscall.SIGUSR1: log.Println(\"Received SIGUSR1, printing status\") printDaemonStatus() } } }() } ","date":"2023-03-10","objectID":"/posts/230310-go-daemon-dev/:2:2","tags":["Daemon","Signal","Systemd"],"title":"Go Daemon Development: Graceful SIGTERM Handling and Config Hot-Reload","uri":"/posts/230310-go-daemon-dev/"},{"categories":["Go"],"content":"3. Graceful Shutdown ","date":"2023-03-10","objectID":"/posts/230310-go-daemon-dev/:3:0","tags":["Daemon","Signal","Systemd"],"title":"Go Daemon Development: Graceful SIGTERM Handling and Config Hot-Reload","uri":"/posts/230310-go-daemon-dev/"},{"categories":["Go"],"content":"3.1 Why Is Graceful Shutdown Necessary? If a process is killed immediately: Files being written may be corrupted Database connections not closed properly Network requests left hanging, clients timeout Temp files not cleaned up ","date":"2023-03-10","objectID":"/posts/230310-go-daemon-dev/:3:1","tags":["Daemon","Signal","Systemd"],"title":"Go Daemon Development: Graceful SIGTERM Handling and Config Hot-Reload","uri":"/posts/230310-go-daemon-dev/"},{"categories":["Go"],"content":"3.2 Using Context for Cancellation Propagation type DiskMonitor struct { ctx context.Context cancel context.CancelFunc wg sync.WaitGroup } func NewDiskMonitor(parentCtx context.Context) *DiskMonitor { ctx, cancel := context.WithCancel(parentCtx) return \u0026DiskMonitor{ ctx: ctx, cancel: cancel, } } func (m *DiskMonitor) Start() { m.wg.Add(1) go func() { defer m.wg.Done() m.run() }() } func (m *DiskMonitor) run() { ticker := time.NewTicker(5 * time.Minute) defer ticker.Stop() for { select { case \u003c-m.ctx.Done(): log.Println(\"DiskMonitor: received cancel signal\") m.cleanup() return case \u003c-ticker.C: m.checkAllDisks() } } } func (m *DiskMonitor) cleanup() { log.Println(\"DiskMonitor: cleaning up resources...\") // Close database connections // Flush cache to disk // etc... } func (m *DiskMonitor) Stop() { log.Println(\"DiskMonitor: stop requested\") m.cancel() m.wg.Wait() // Wait for goroutine to actually exit log.Println(\"DiskMonitor: fully stopped\") } ","date":"2023-03-10","objectID":"/posts/230310-go-daemon-dev/:3:2","tags":["Daemon","Signal","Systemd"],"title":"Go Daemon Development: Graceful SIGTERM Handling and Config Hot-Reload","uri":"/posts/230310-go-daemon-dev/"},{"categories":["Go"],"content":"3.3 Timeout-Forced Shutdown Graceful shutdown can’t wait forever: func gracefulShutdown(cancel context.CancelFunc, components []Stoppable) { sigChan := make(chan os.Signal, 1) signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM) \u003c-sigChan log.Println(\"Starting graceful shutdown...\") // Notify all components to stop cancel() // Set timeout done := make(chan struct{}) go func() { for _, c := range components { c.Stop() // Assuming each component has Stop() method } close(done) }() select { case \u003c-done: log.Println(\"All components stopped normally\") case \u003c-time.After(30 * time.Second): log.Println(\"Timeout! Some components failed to stop gracefully\") } log.Println(\"Shutdown complete\") } ","date":"2023-03-10","objectID":"/posts/230310-go-daemon-dev/:3:3","tags":["Daemon","Signal","Systemd"],"title":"Go Daemon Development: Graceful SIGTERM Handling and Config Hot-Reload","uri":"/posts/230310-go-daemon-dev/"},{"categories":["Go"],"content":"4. Config Hot-Reload ","date":"2023-03-10","objectID":"/posts/230310-go-daemon-dev/:4:0","tags":["Daemon","Signal","Systemd"],"title":"Go Daemon Development: Graceful SIGTERM Handling and Config Hot-Reload","uri":"/posts/230310-go-daemon-dev/"},{"categories":["Go"],"content":"4.1 SIGHUP-Triggered Reload type Config struct { CheckInterval time.Duration `toml:\"check_interval\"` AlertEmail string `toml:\"alert_email\"` // ... } var ( config *Config configLock sync.RWMutex ) func loadConfig(path string) error { data, err := os.ReadFile(path) if err != nil { return err } var newConfig Config if _, err := toml.Decode(string(data), \u0026newConfig); err != nil { return err } configLock.Lock() config = \u0026newConfig configLock.Unlock() log.Printf(\"Config reloaded: %+v\", newConfig) return nil } func getConfig() *Config { configLock.RLock() defer configLock.RUnlock() return config } // Config reload handler func handleConfigReload(configPath string, reloadChan \u003c-chan struct{}) { for range reloadChan { if err := loadConfig(configPath); err != nil { log.Printf(\"Config reload failed: %v\", err) } } } ","date":"2023-03-10","objectID":"/posts/230310-go-daemon-dev/:4:1","tags":["Daemon","Signal","Systemd"],"title":"Go Daemon Development: Graceful SIGTERM Handling and Config Hot-Reload","uri":"/posts/230310-go-daemon-dev/"},{"categories":["Go"],"content":"4.2 Usage # After modifying config file kill -HUP $(pidof nas-agent) # Service reloads config without restart ","date":"2023-03-10","objectID":"/posts/230310-go-daemon-dev/:4:2","tags":["Daemon","Signal","Systemd"],"title":"Go Daemon Development: Graceful SIGTERM Handling and Config Hot-Reload","uri":"/posts/230310-go-daemon-dev/"},{"categories":["Go"],"content":"5. systemd Integration ","date":"2023-03-10","objectID":"/posts/230310-go-daemon-dev/:5:0","tags":["Daemon","Signal","Systemd"],"title":"Go Daemon Development: Graceful SIGTERM Handling and Config Hot-Reload","uri":"/posts/230310-go-daemon-dev/"},{"categories":["Go"],"content":"5.1 Service File # /etc/systemd/system/nas-agent.service [Unit] Description=NAS System Agent After=network.target [Service] Type=simple User=root ExecStart=/usr/local/bin/nas-agent -config /etc/nas-agent/config.toml ExecReload=/bin/kill -HUP $MAINPID Restart=on-failure RestartSec=5s # Resource limits MemoryMax=512M MemoryHigh=400M CPUQuota=50% # Graceful shutdown timeout TimeoutStopSec=30s # Logging StandardOutput=journal StandardError=journal SyslogIdentifier=nas-agent [Install] WantedBy=multi-user.target ","date":"2023-03-10","objectID":"/posts/230310-go-daemon-dev/:5:1","tags":["Daemon","Signal","Systemd"],"title":"Go Daemon Development: Graceful SIGTERM Handling and Config Hot-Reload","uri":"/posts/230310-go-daemon-dev/"},{"categories":["Go"],"content":"5.2 Key Config Explained Type=simple: Process is ready as soon as it starts (typical for Go programs) ExecReload: systemctl reload nas-agent sends SIGHUP Restart=on-failure: Auto-restart on abnormal exit TimeoutStopSec: Time to wait for graceful shutdown, then SIGKILL MemoryMax/CPUQuota: Resource limits (via cgroups v2) ","date":"2023-03-10","objectID":"/posts/230310-go-daemon-dev/:5:2","tags":["Daemon","Signal","Systemd"],"title":"Go Daemon Development: Graceful SIGTERM Handling and Config Hot-Reload","uri":"/posts/230310-go-daemon-dev/"},{"categories":["Go"],"content":"5.3 Log Integration Using journald: # View service logs journalctl -u nas-agent -f # View last 100 lines journalctl -u nas-agent -n 100 # Query by time journalctl -u nas-agent --since \"2023-03-10 10:00\" --until \"2023-03-10 12:00\" In Go code, just use log or fmt output — journald captures it automatically. ","date":"2023-03-10","objectID":"/posts/230310-go-daemon-dev/:5:3","tags":["Daemon","Signal","Systemd"],"title":"Go Daemon Development: Graceful SIGTERM Handling and Config Hot-Reload","uri":"/posts/230310-go-daemon-dev/"},{"categories":["Go"],"content":"6. Common Pitfalls ","date":"2023-03-10","objectID":"/posts/230310-go-daemon-dev/:6:0","tags":["Daemon","Signal","Systemd"],"title":"Go Daemon Development: Graceful SIGTERM Handling and Config Hot-Reload","uri":"/posts/230310-go-daemon-dev/"},{"categories":["Go"],"content":"6.1 Goroutine Leaks Wrong: func (m *DiskMonitor) checkDisk(path string) { go func() { // If this blocks, goroutine never exits data, _ := exec.Command(\"smartctl\", \"-a\", path).Output() m.process(data) }() } Correct: func (m *DiskMonitor) checkDisk(path string) { go func() { ctx, cancel := context.WithTimeout(m.ctx, 30*time.Second) defer cancel() cmd := exec.CommandContext(ctx, \"smartctl\", \"-a\", path) data, err := cmd.Output() if err != nil { if ctx.Err() == context.DeadlineExceeded { log.Printf(\"smartctl timeout: %s\", path) } return } m.process(data) }() } ","date":"2023-03-10","objectID":"/posts/230310-go-daemon-dev/:6:1","tags":["Daemon","Signal","Systemd"],"title":"Go Daemon Development: Graceful SIGTERM Handling and Config Hot-Reload","uri":"/posts/230310-go-daemon-dev/"},{"categories":["Go"],"content":"6.2 Ignoring Context Wrong: func doWork() { for { // This loop never stops! time.Sleep(time.Second) doSomething() } } Correct: func doWork(ctx context.Context) { ticker := time.NewTicker(time.Second) defer ticker.Stop() for { select { case \u003c-ctx.Done(): return case \u003c-ticker.C: doSomething() } } } ","date":"2023-03-10","objectID":"/posts/230310-go-daemon-dev/:6:2","tags":["Daemon","Signal","Systemd"],"title":"Go Daemon Development: Graceful SIGTERM Handling and Config Hot-Reload","uri":"/posts/230310-go-daemon-dev/"},{"categories":["Go"],"content":"6.3 Resource Cleanup Order func shutdown(components []Component) { // Reverse order (last started, first stopped) for i := len(components) - 1; i \u003e= 0; i-- { log.Printf(\"Stopping: %s\", components[i].Name()) components[i].Stop() } } ","date":"2023-03-10","objectID":"/posts/230310-go-daemon-dev/:6:3","tags":["Daemon","Signal","Systemd"],"title":"Go Daemon Development: Graceful SIGTERM Handling and Config Hot-Reload","uri":"/posts/230310-go-daemon-dev/"},{"categories":["Go"],"content":"7. Complete Example package main import ( \"context\" \"log\" \"os\" \"os/signal\" \"sync\" \"syscall\" \"time\" ) type Daemon struct { ctx context.Context cancel context.CancelFunc wg sync.WaitGroup reloadChan chan struct{} } func NewDaemon() *Daemon { ctx, cancel := context.WithCancel(context.Background()) return \u0026Daemon{ ctx: ctx, cancel: cancel, reloadChan: make(chan struct{}, 1), } } func (d *Daemon) Run() { // Start business goroutines d.wg.Add(2) go d.diskMonitorLoop() go d.taskSchedulerLoop() // Start signal handler d.handleSignals() // Wait for all goroutines to exit d.wg.Wait() log.Println(\"Daemon fully exited\") } func (d *Daemon) diskMonitorLoop() { defer d.wg.Done() ticker := time.NewTicker(5 * time.Minute) defer ticker.Stop() for { select { case \u003c-d.ctx.Done(): log.Println(\"DiskMonitor: exiting\") return case \u003c-ticker.C: log.Println(\"DiskMonitor: checking disks...\") } } } func (d *Daemon) taskSchedulerLoop() { defer d.wg.Done() ticker := time.NewTicker(time.Minute) defer ticker.Stop() for { select { case \u003c-d.ctx.Done(): log.Println(\"TaskScheduler: exiting\") return case \u003c-ticker.C: log.Println(\"TaskScheduler: checking scheduled tasks...\") case \u003c-d.reloadChan: log.Println(\"TaskScheduler: hot-reloading config\") } } } func (d *Daemon) handleSignals() { sigChan := make(chan os.Signal, 1) signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM, syscall.SIGHUP) for sig := range sigChan { switch sig { case syscall.SIGINT, syscall.SIGTERM: log.Printf(\"Received %v, starting graceful shutdown...\", sig) d.cancel() return case syscall.SIGHUP: log.Println(\"Received SIGHUP, triggering config reload\") select { case d.reloadChan \u003c- struct{}{}: default: log.Println(\"Reload request already queued\") } } } } func main() { log.SetFlags(log.LstdFlags | log.Lshortfile) log.Println(\"Daemon starting\") daemon := NewDaemon() daemon.Run() } ","date":"2023-03-10","objectID":"/posts/230310-go-daemon-dev/:7:0","tags":["Daemon","Signal","Systemd"],"title":"Go Daemon Development: Graceful SIGTERM Handling and Config Hot-Reload","uri":"/posts/230310-go-daemon-dev/"},{"categories":["Go"],"content":"8. Summary Point Implementation Signal capture signal.Notify Cancel propagation context.WithCancel Wait for exit sync.WaitGroup Hot-reload SIGHUP + channel notification Timeout protection context.WithTimeout Resource limits systemd cgroups Core principle: Every goroutine must respond to context cancellation, every resource must have a cleanup mechanism. ","date":"2023-03-10","objectID":"/posts/230310-go-daemon-dev/:8:0","tags":["Daemon","Signal","Systemd"],"title":"Go Daemon Development: Graceful SIGTERM Handling and Config Hot-Reload","uri":"/posts/230310-go-daemon-dev/"},{"categories":["Linux"],"content":"Implementing disk health monitoring for NAS products: understanding SMART attributes, parsing smartctl output with Go, designing alert strategies to protect user data.","date":"2022-08-15","objectID":"/posts/220815-disk-health-agent/","tags":["Go","Monitoring","SMART"],"title":"NAS Disk Health Monitoring: From smartctl to Custom Agent","uri":"/posts/220815-disk-health-agent/"},{"categories":["Linux"],"content":"A NAS’s most important job is protecting user data. Disk failures often have warning signs, and SMART technology can detect problems early. This post documents how to build a disk health monitoring agent. ","date":"2022-08-15","objectID":"/posts/220815-disk-health-agent/:0:0","tags":["Go","Monitoring","SMART"],"title":"NAS Disk Health Monitoring: From smartctl to Custom Agent","uri":"/posts/220815-disk-health-agent/"},{"categories":["Linux"],"content":"1. SMART Technology Overview ","date":"2022-08-15","objectID":"/posts/220815-disk-health-agent/:1:0","tags":["Go","Monitoring","SMART"],"title":"NAS Disk Health Monitoring: From smartctl to Custom Agent","uri":"/posts/220815-disk-health-agent/"},{"categories":["Linux"],"content":"1.1 What is SMART? S.M.A.R.T. (Self-Monitoring, Analysis and Reporting Technology) is built-in self-testing in hard drives. Drives continuously collect health metrics that the OS can read. ","date":"2022-08-15","objectID":"/posts/220815-disk-health-agent/:1:1","tags":["Go","Monitoring","SMART"],"title":"NAS Disk Health Monitoring: From smartctl to Custom Agent","uri":"/posts/220815-disk-health-agent/"},{"categories":["Linux"],"content":"1.2 Key Metrics ID Attribute Meaning Danger Threshold 5 Reallocated Sectors Count Remapped bad sectors \u003e0 needs attention 187 Reported Uncorrectable Errors Errors that couldn’t be corrected \u003e0 dangerous 188 Command Timeout Command timeout count Rapid increase = danger 197 Current Pending Sector Count Sectors waiting to be remapped \u003e0 = potential failure 198 Offline Uncorrectable Offline uncorrectable errors \u003e0 = imminent failure 194 Temperature Temperature \u003e55°C alert ","date":"2022-08-15","objectID":"/posts/220815-disk-health-agent/:1:2","tags":["Go","Monitoring","SMART"],"title":"NAS Disk Health Monitoring: From smartctl to Custom Agent","uri":"/posts/220815-disk-health-agent/"},{"categories":["Linux"],"content":"1.3 Typical Drive Lifespan Patterns According to Backblaze statistics: Year 1: ~5% annual failure rate (“infant mortality”) Years 2-3: ~1.5% annual failure rate (most stable) Year 4+: Failure rate increases rapidly After Reallocated Sectors \u003e 0, failure probability spikes within 1 year ","date":"2022-08-15","objectID":"/posts/220815-disk-health-agent/:1:3","tags":["Go","Monitoring","SMART"],"title":"NAS Disk Health Monitoring: From smartctl to Custom Agent","uri":"/posts/220815-disk-health-agent/"},{"categories":["Linux"],"content":"2. Using smartctl ","date":"2022-08-15","objectID":"/posts/220815-disk-health-agent/:2:0","tags":["Go","Monitoring","SMART"],"title":"NAS Disk Health Monitoring: From smartctl to Custom Agent","uri":"/posts/220815-disk-health-agent/"},{"categories":["Linux"],"content":"2.1 Basic Commands # View all SMART info smartctl -a /dev/sda # Health status only smartctl -H /dev/sda # JSON output (easier to parse) smartctl -a /dev/sda -j ","date":"2022-08-15","objectID":"/posts/220815-disk-health-agent/:2:1","tags":["Go","Monitoring","SMART"],"title":"NAS Disk Health Monitoring: From smartctl to Custom Agent","uri":"/posts/220815-disk-health-agent/"},{"categories":["Linux"],"content":"2.2 Output Example { \"device\": { \"name\": \"/dev/sda\", \"type\": \"sat\" }, \"model_name\": \"WDC WD40EFRX-68N32N0\", \"serial_number\": \"WD-WCC7K1234567\", \"ata_smart_attributes\": { \"table\": [ { \"id\": 5, \"name\": \"Reallocated_Sector_Ct\", \"value\": 200, \"worst\": 200, \"thresh\": 140, \"raw\": {\"value\": 0} }, { \"id\": 194, \"name\": \"Temperature_Celsius\", \"value\": 117, \"raw\": {\"value\": 33} } ] } } ","date":"2022-08-15","objectID":"/posts/220815-disk-health-agent/:2:2","tags":["Go","Monitoring","SMART"],"title":"NAS Disk Health Monitoring: From smartctl to Custom Agent","uri":"/posts/220815-disk-health-agent/"},{"categories":["Linux"],"content":"3. Go Implementation ","date":"2022-08-15","objectID":"/posts/220815-disk-health-agent/:3:0","tags":["Go","Monitoring","SMART"],"title":"NAS Disk Health Monitoring: From smartctl to Custom Agent","uri":"/posts/220815-disk-health-agent/"},{"categories":["Linux"],"content":"3.1 Data Structure Definitions package diskmon // SmartctlOutput maps to smartctl -j output type SmartctlOutput struct { Device struct { Name string `json:\"name\"` Type string `json:\"type\"` } `json:\"device\"` ModelName string `json:\"model_name\"` SerialNumber string `json:\"serial_number\"` SmartStatus struct { Passed bool `json:\"passed\"` } `json:\"smart_status\"` ATASmartAttributes struct { Table []SmartAttribute `json:\"table\"` } `json:\"ata_smart_attributes\"` Temperature struct { Current int `json:\"current\"` } `json:\"temperature\"` PowerOnTime struct { Hours int `json:\"hours\"` } `json:\"power_on_time\"` } type SmartAttribute struct { ID int `json:\"id\"` Name string `json:\"name\"` Value int `json:\"value\"` Worst int `json:\"worst\"` Thresh int `json:\"thresh\"` Raw struct { Value int `json:\"value\"` } `json:\"raw\"` } // DiskHealth is the simplified health status type DiskHealth struct { Device string Model string Serial string Passed bool Temperature int PowerOnHours int ReallocatedSectors int PendingSectors int UncorrectableErrors int Alerts []string } ","date":"2022-08-15","objectID":"/posts/220815-disk-health-agent/:3:1","tags":["Go","Monitoring","SMART"],"title":"NAS Disk Health Monitoring: From smartctl to Custom Agent","uri":"/posts/220815-disk-health-agent/"},{"categories":["Linux"],"content":"3.2 Execute smartctl and Parse func GetDiskHealth(device string) (*DiskHealth, error) { ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second) defer cancel() cmd := exec.CommandContext(ctx, \"smartctl\", \"-a\", \"-j\", device) output, err := cmd.Output() if err != nil { // smartctl returning non-0 might just be a warning if exitErr, ok := err.(*exec.ExitError); ok { // Return code 32 = past errors, 64 = current errors if exitErr.ExitCode() \u003e= 4 { return nil, fmt.Errorf(\"smartctl failed: %w\", err) } // Continue parsing output } else { return nil, err } } var raw SmartctlOutput if err := json.Unmarshal(output, \u0026raw); err != nil { return nil, fmt.Errorf(\"parse smartctl output: %w\", err) } return analyzeHealth(\u0026raw), nil } func analyzeHealth(raw *SmartctlOutput) *DiskHealth { health := \u0026DiskHealth{ Device: raw.Device.Name, Model: raw.ModelName, Serial: raw.SerialNumber, Passed: raw.SmartStatus.Passed, Temperature: raw.Temperature.Current, PowerOnHours: raw.PowerOnTime.Hours, } // Extract key attributes for _, attr := range raw.ATASmartAttributes.Table { switch attr.ID { case 5: // Reallocated Sectors health.ReallocatedSectors = attr.Raw.Value case 197: // Current Pending Sector health.PendingSectors = attr.Raw.Value case 187, 198: // Uncorrectable Errors health.UncorrectableErrors += attr.Raw.Value } } // Generate alerts health.Alerts = generateAlerts(health) return health } ","date":"2022-08-15","objectID":"/posts/220815-disk-health-agent/:3:2","tags":["Go","Monitoring","SMART"],"title":"NAS Disk Health Monitoring: From smartctl to Custom Agent","uri":"/posts/220815-disk-health-agent/"},{"categories":["Linux"],"content":"3.3 Alert Strategy type AlertLevel int const ( AlertNone AlertLevel = iota AlertWarning AlertCritical ) func generateAlerts(h *DiskHealth) []string { var alerts []string // SMART self-test failed = replace immediately if !h.Passed { alerts = append(alerts, \"[CRITICAL] SMART self-test failed! Backup data and replace drive immediately\") } // Reallocated sectors if h.ReallocatedSectors \u003e 0 { if h.ReallocatedSectors \u003c 10 { alerts = append(alerts, fmt.Sprintf(\"[WARNING] Found %d reallocated sectors, monitor closely\", h.ReallocatedSectors)) } else { alerts = append(alerts, fmt.Sprintf(\"[CRITICAL] Too many reallocated sectors (%d), replace soon\", h.ReallocatedSectors)) } } // Pending sectors (more dangerous) if h.PendingSectors \u003e 0 { alerts = append(alerts, fmt.Sprintf(\"[CRITICAL] %d pending sectors, data may be at risk\", h.PendingSectors)) } // Uncorrectable errors if h.UncorrectableErrors \u003e 0 { alerts = append(alerts, fmt.Sprintf(\"[CRITICAL] Detected %d uncorrectable errors\", h.UncorrectableErrors)) } // Temperature if h.Temperature \u003e 55 { alerts = append(alerts, fmt.Sprintf(\"[WARNING] Disk temperature too high: %d°C, check cooling\", h.Temperature)) } // Power-on time if h.PowerOnHours \u003e 35000 { // About 4 years alerts = append(alerts, fmt.Sprintf(\"[INFO] Drive has been running %d hours (%.1f years), consider replacement\", h.PowerOnHours, float64(h.PowerOnHours)/8760)) } return alerts } ","date":"2022-08-15","objectID":"/posts/220815-disk-health-agent/:3:3","tags":["Go","Monitoring","SMART"],"title":"NAS Disk Health Monitoring: From smartctl to Custom Agent","uri":"/posts/220815-disk-health-agent/"},{"categories":["Linux"],"content":"3.4 Scheduled Checks type DiskMonitor struct { devices []string interval time.Duration alertChan chan Alert ctx context.Context cancel context.CancelFunc } func NewDiskMonitor(devices []string, interval time.Duration) *DiskMonitor { ctx, cancel := context.WithCancel(context.Background()) return \u0026DiskMonitor{ devices: devices, interval: interval, alertChan: make(chan Alert, 100), ctx: ctx, cancel: cancel, } } func (m *DiskMonitor) Run() { ticker := time.NewTicker(m.interval) defer ticker.Stop() // Check immediately on startup m.checkAllDisks() for { select { case \u003c-m.ctx.Done(): return case \u003c-ticker.C: m.checkAllDisks() } } } func (m *DiskMonitor) checkAllDisks() { for _, device := range m.devices { health, err := GetDiskHealth(device) if err != nil { log.Printf(\"Failed to check %s: %v\", device, err) continue } // Record to Prometheus diskTemperature.WithLabelValues(device).Set(float64(health.Temperature)) diskReallocatedSectors.WithLabelValues(device).Set(float64(health.ReallocatedSectors)) // Send alerts for _, msg := range health.Alerts { m.alertChan \u003c- Alert{ Device: device, Message: msg, Time: time.Now(), } } } } ","date":"2022-08-15","objectID":"/posts/220815-disk-health-agent/:3:4","tags":["Go","Monitoring","SMART"],"title":"NAS Disk Health Monitoring: From smartctl to Custom Agent","uri":"/posts/220815-disk-health-agent/"},{"categories":["Linux"],"content":"4. Alert Notifications ","date":"2022-08-15","objectID":"/posts/220815-disk-health-agent/:4:0","tags":["Go","Monitoring","SMART"],"title":"NAS Disk Health Monitoring: From smartctl to Custom Agent","uri":"/posts/220815-disk-health-agent/"},{"categories":["Linux"],"content":"4.1 Email Integration func (m *DiskMonitor) consumeAlerts() { for alert := range m.alertChan { // Prevent alert storms: same disk + same message, only send once per hour if m.isRecentlySent(alert) { continue } if err := m.sendEmail(alert); err != nil { log.Printf(\"Failed to send email: %v\", err) } m.recordSent(alert) } } func (m *DiskMonitor) sendEmail(alert Alert) error { subject := fmt.Sprintf(\"[NAS Alert] %s disk anomaly\", alert.Device) body := fmt.Sprintf(` Device: %s Time: %s Details: %s Please log in to NAS management interface for details. `, alert.Device, alert.Time.Format(\"2006-01-02 15:04:05\"), alert.Message) return smtp.SendMail(/* ... */) } ","date":"2022-08-15","objectID":"/posts/220815-disk-health-agent/:4:1","tags":["Go","Monitoring","SMART"],"title":"NAS Disk Health Monitoring: From smartctl to Custom Agent","uri":"/posts/220815-disk-health-agent/"},{"categories":["Linux"],"content":"4.2 Prometheus Metrics var ( diskTemperature = promauto.NewGaugeVec( prometheus.GaugeOpts{ Name: \"disk_temperature_celsius\", Help: \"Disk temperature in Celsius\", }, []string{\"device\"}, ) diskReallocatedSectors = promauto.NewGaugeVec( prometheus.GaugeOpts{ Name: \"disk_reallocated_sectors_total\", Help: \"Number of reallocated sectors\", }, []string{\"device\"}, ) diskSmartPassed = promauto.NewGaugeVec( prometheus.GaugeOpts{ Name: \"disk_smart_passed\", Help: \"SMART self-test passed (1) or failed (0)\", }, []string{\"device\"}, ) ) ","date":"2022-08-15","objectID":"/posts/220815-disk-health-agent/:4:2","tags":["Go","Monitoring","SMART"],"title":"NAS Disk Health Monitoring: From smartctl to Custom Agent","uri":"/posts/220815-disk-health-agent/"},{"categories":["Linux"],"content":"5. Production Considerations ","date":"2022-08-15","objectID":"/posts/220815-disk-health-agent/:5:0","tags":["Go","Monitoring","SMART"],"title":"NAS Disk Health Monitoring: From smartctl to Custom Agent","uri":"/posts/220815-disk-health-agent/"},{"categories":["Linux"],"content":"5.1 Avoid Frequent Queries smartctl execution causes disk I/O — too frequent queries affect performance: // Recommended intervals const ( CheckInterval = 15 * time.Minute // Normal check QuickInterval = 5 * time.Minute // Increased monitoring after finding issues ) ","date":"2022-08-15","objectID":"/posts/220815-disk-health-agent/:5:1","tags":["Go","Monitoring","SMART"],"title":"NAS Disk Health Monitoring: From smartctl to Custom Agent","uri":"/posts/220815-disk-health-agent/"},{"categories":["Linux"],"content":"5.2 Handling SSDs SSD SMART attributes differ from HDDs: func analyzeSSDHealth(raw *SmartctlOutput) *DiskHealth { // SSD-specific attributes for _, attr := range raw.ATASmartAttributes.Table { switch attr.Name { case \"Wear_Leveling_Count\": // 100 = new drive, 0 = end of life if attr.Value \u003c 20 { // Alert } case \"Available_Reservd_Space\": // Reserved space } } } ","date":"2022-08-15","objectID":"/posts/220815-disk-health-agent/:5:2","tags":["Go","Monitoring","SMART"],"title":"NAS Disk Health Monitoring: From smartctl to Custom Agent","uri":"/posts/220815-disk-health-agent/"},{"categories":["Linux"],"content":"5.3 RAID Scenarios For software RAID, check underlying disks: # List RAID members cat /proc/mdstat # Run smartctl on each member smartctl -a /dev/sda smartctl -a /dev/sdb ","date":"2022-08-15","objectID":"/posts/220815-disk-health-agent/:5:3","tags":["Go","Monitoring","SMART"],"title":"NAS Disk Health Monitoring: From smartctl to Custom Agent","uri":"/posts/220815-disk-health-agent/"},{"categories":["Linux"],"content":"6. Summary Component Technology Data collection smartctl -j Parsing Go json.Unmarshal Scheduling time.Ticker + context Alert dedup In-memory cache + TTL Observability Prometheus metrics Notifications Email / Webhook Core principle: Disk failures are inevitable, but they can be detected early. A good monitoring system gives users enough time to backup data and replace drives. Related Posts Go Daemon Development: Graceful SIGTERM Handling and Config Hot-Reload OOM Killer in Practice: Debugging a Container Memory Leak ","date":"2022-08-15","objectID":"/posts/220815-disk-health-agent/:6:0","tags":["Go","Monitoring","SMART"],"title":"NAS Disk Health Monitoring: From smartctl to Custom Agent","uri":"/posts/220815-disk-health-agent/"},{"categories":["Go"],"content":"Starting from LeetCode's atoi problem, deep-diving into Go/Rust standard library implementations to understand production-grade string parsing design: state machines, error handling, boundary conditions.","date":"2022-04-14","objectID":"/posts/220414-atoi/","tags":["State Machine","Source Code Analysis","Strings"],"title":"Production-Grade String Parsing: From atoi to State Machine","uri":"/posts/220414-atoi/"},{"categories":["Go"],"content":"LeetCode’s atoi is a classic interview problem, but production-grade implementations are far more complex. This post starts from the interview version and gradually analyzes Go and Rust standard library implementations to understand “production-grade” code design. ","date":"2022-04-14","objectID":"/posts/220414-atoi/:0:0","tags":["State Machine","Source Code Analysis","Strings"],"title":"Production-Grade String Parsing: From atoi to State Machine","uri":"/posts/220414-atoi/"},{"categories":["Go"],"content":"1. Interview Version atoi ","date":"2022-04-14","objectID":"/posts/220414-atoi/:1:0","tags":["State Machine","Source Code Analysis","Strings"],"title":"Production-Grade String Parsing: From atoi to State Machine","uri":"/posts/220414-atoi/"},{"categories":["Go"],"content":"1.1 LeetCode 8: String to Integer Basic requirements: Skip leading whitespace Handle positive/negative signs Convert digit characters Handle overflow func myAtoi(s string) int { i, n := 0, len(s) // Skip whitespace for i \u003c n \u0026\u0026 s[i] == ' ' { i++ } if i \u003e= n { return 0 } // Handle sign sign := 1 if s[i] == '+' { i++ } else if s[i] == '-' { sign = -1 i++ } // Convert digits result := 0 for i \u003c n \u0026\u0026 s[i] \u003e= '0' \u0026\u0026 s[i] \u003c= '9' { digit := int(s[i] - '0') // Overflow check if result \u003e (math.MaxInt32-digit)/10 { if sign == 1 { return math.MaxInt32 } return math.MinInt32 } result = result*10 + digit i++ } return sign * result } This passes LeetCode, but it’s far from production-grade. ","date":"2022-04-14","objectID":"/posts/220414-atoi/:1:1","tags":["State Machine","Source Code Analysis","Strings"],"title":"Production-Grade String Parsing: From atoi to State Machine","uri":"/posts/220414-atoi/"},{"categories":["Go"],"content":"1.2 What’s Missing? Interview Version Production Requirements Only handles int32 Supports multiple types (int8, int64, uint…) Only returns result Needs detailed error messages Only base 10 Supports multiple bases (2, 8, 16…) Simple overflow handling Precise overflow detection Fixed format Supports 0x, 0o, 0b prefixes ","date":"2022-04-14","objectID":"/posts/220414-atoi/:1:2","tags":["State Machine","Source Code Analysis","Strings"],"title":"Production-Grade String Parsing: From atoi to State Machine","uri":"/posts/220414-atoi/"},{"categories":["Go"],"content":"2. Go Standard Library Analysis ","date":"2022-04-14","objectID":"/posts/220414-atoi/:2:0","tags":["State Machine","Source Code Analysis","Strings"],"title":"Production-Grade String Parsing: From atoi to State Machine","uri":"/posts/220414-atoi/"},{"categories":["Go"],"content":"2.1 strconv.ParseInt Signature func ParseInt(s string, base int, bitSize int) (i int64, err error) // Parameters: // s: input string // base: radix (0 means auto-detect) // bitSize: target type bits (8, 16, 32, 64) // Returns: // i: parsed result // err: error info (includes detailed reason) ","date":"2022-04-14","objectID":"/posts/220414-atoi/:2:1","tags":["State Machine","Source Code Analysis","Strings"],"title":"Production-Grade String Parsing: From atoi to State Machine","uri":"/posts/220414-atoi/"},{"categories":["Go"],"content":"2.2 Error Types type NumError struct { Func string // Function name (\"ParseInt\") Num string // Input string Err error // Specific error } var ( ErrRange = errors.New(\"value out of range\") ErrSyntax = errors.New(\"invalid syntax\") ) ","date":"2022-04-14","objectID":"/posts/220414-atoi/:2:2","tags":["State Machine","Source Code Analysis","Strings"],"title":"Production-Grade String Parsing: From atoi to State Machine","uri":"/posts/220414-atoi/"},{"categories":["Go"],"content":"2.3 Source Analysis // src/strconv/atoi.go (simplified) func ParseInt(s string, base int, bitSize int) (i int64, err error) { // Empty string if s == \"\" { return 0, syntaxError(\"ParseInt\", s) } // Handle sign s0 := s neg := false if s[0] == '+' { s = s[1:] } else if s[0] == '-' { neg = true s = s[1:] } // Handle base prefix if base == 0 { base = 10 if s[0] == '0' { switch { case len(s) \u003e= 2 \u0026\u0026 lower(s[1]) == 'x': base = 16 s = s[2:] case len(s) \u003e= 2 \u0026\u0026 lower(s[1]) == 'o': base = 8 s = s[2:] case len(s) \u003e= 2 \u0026\u0026 lower(s[1]) == 'b': base = 2 s = s[2:] default: base = 8 s = s[1:] } } } // Calculate overflow bounds var cutoff uint64 switch bitSize { case 8: cutoff = uint64(1\u003c\u003c7 - 1) case 16: cutoff = uint64(1\u003c\u003c15 - 1) case 32: cutoff = uint64(1\u003c\u003c31 - 1) case 64: cutoff = uint64(1\u003c\u003c63 - 1) } if neg { cutoff++ } // Character-by-character conversion var n uint64 for _, c := range []byte(s) { var d byte switch { case '0' \u003c= c \u0026\u0026 c \u003c= '9': d = c - '0' case 'a' \u003c= lower(c) \u0026\u0026 lower(c) \u003c= 'z': d = lower(c) - 'a' + 10 default: return 0, syntaxError(\"ParseInt\", s0) } if d \u003e= byte(base) { return 0, syntaxError(\"ParseInt\", s0) } // Overflow check (before multiplication) if n \u003e= cutoff { return 0, rangeError(\"ParseInt\", s0) } n *= uint64(base) n1 := n + uint64(d) // Check addition overflow if n1 \u003c n || n1 \u003e cutoff { return 0, rangeError(\"ParseInt\", s0) } n = n1 } if neg { return -int64(n), nil } return int64(n), nil } ","date":"2022-04-14","objectID":"/posts/220414-atoi/:2:3","tags":["State Machine","Source Code Analysis","Strings"],"title":"Production-Grade String Parsing: From atoi to State Machine","uri":"/posts/220414-atoi/"},{"categories":["Go"],"content":"2.4 Design Highlights Overflow detection before operation: Avoids detecting after already overflowing Detailed error info: Includes original input for debugging Unified signed/unsigned handling: Calculate with uint64, convert at end Auto base detection: 0x, 0o, 0b prefixes ","date":"2022-04-14","objectID":"/posts/220414-atoi/:2:4","tags":["State Machine","Source Code Analysis","Strings"],"title":"Production-Grade String Parsing: From atoi to State Machine","uri":"/posts/220414-atoi/"},{"categories":["Go"],"content":"3. State Machine Implementation ","date":"2022-04-14","objectID":"/posts/220414-atoi/:3:0","tags":["State Machine","Source Code Analysis","Strings"],"title":"Production-Grade String Parsing: From atoi to State Machine","uri":"/posts/220414-atoi/"},{"categories":["Go"],"content":"3.1 Why State Machine? Complex parsing needs are hard to handle cleanly with if-else: Valid input examples: \" -42\" → -42 \"0x1A\" → 26 (auto-detect base 16) \" +0o17\" → 15 (auto-detect base 8) Invalid input examples: \"--42\" → syntax error \"0x\" → syntax error (no digits) \"123abc\" → ? (Go errors, some languages accept 123) ","date":"2022-04-14","objectID":"/posts/220414-atoi/:3:1","tags":["State Machine","Source Code Analysis","Strings"],"title":"Production-Grade String Parsing: From atoi to State Machine","uri":"/posts/220414-atoi/"},{"categories":["Go"],"content":"3.2 State Machine Model ┌─────────────────────────────────────────────────────┐ │ │ ┌────▼────┐ space ┌─────────┐ +/- ┌─────────┐ │ │ START │────────▶│ SPACES │───────▶│ SIGN │ │ └─────────┘ └────┬────┘ └────┬────┘ │ │ │ │ │ │ 0 │ digit │ digit │ ▼ │ │ │ ┌─────────┐ │ │ │ │ PREFIX │◄─────────────┴───────────────────┘ │ └────┬────┘ │ │ x/o/b/digit │ ▼ │ ┌─────────┐ digit │ │ DIGITS │────────┐ │ └────┬────┘ │ │ │ │ │ │ non-digit │ │ ▼ ▼ │ ┌─────────┐ ┌─────────┐ │ │ ERROR │ │ END │───────────────────────────────────┘ └─────────┘ └─────────┘ ","date":"2022-04-14","objectID":"/posts/220414-atoi/:3:2","tags":["State Machine","Source Code Analysis","Strings"],"title":"Production-Grade String Parsing: From atoi to State Machine","uri":"/posts/220414-atoi/"},{"categories":["Go"],"content":"3.3 Go Implementation type State int const ( StateStart State = iota StateSign StatePrefix StateDigits StateEnd StateError ) type Parser struct { state State sign int base int result uint64 bitSize int cutoff uint64 } func NewParser(bitSize int) *Parser { cutoff := uint64(1\u003c\u003c(bitSize-1) - 1) return \u0026Parser{ state: StateStart, sign: 1, base: 10, bitSize: bitSize, cutoff: cutoff, } } func (p *Parser) Feed(c byte) error { switch p.state { case StateStart: return p.handleStart(c) case StateSign: return p.handleSign(c) case StatePrefix: return p.handlePrefix(c) case StateDigits: return p.handleDigits(c) default: return errors.New(\"invalid state\") } } func (p *Parser) handleStart(c byte) error { switch { case c == ' ' || c == '\\t': // Stay in Start state return nil case c == '+': p.state = StateSign return nil case c == '-': p.sign = -1 p.cutoff++ // Negative can be one more p.state = StateSign return nil case c == '0': p.state = StatePrefix return nil case c \u003e= '1' \u0026\u0026 c \u003c= '9': p.state = StateDigits return p.addDigit(c - '0') default: p.state = StateError return errors.New(\"invalid character\") } } func (p *Parser) handlePrefix(c byte) error { switch lower(c) { case 'x': p.base = 16 p.state = StateDigits return nil case 'o': p.base = 8 p.state = StateDigits return nil case 'b': p.base = 2 p.state = StateDigits return nil default: p.base = 8 p.state = StateDigits return p.addDigit(c - '0') } } func (p *Parser) addDigit(d byte) error { if p.result \u003e p.cutoff/uint64(p.base) { return errors.New(\"overflow\") } p.result = p.result*uint64(p.base) + uint64(d) if p.result \u003e p.cutoff { return errors.New(\"overflow\") } return nil } func (p *Parser) Result() (int64, error) { if p.state == StateError { return 0, errors.New(\"parse error\") } if p.sign \u003c 0 { return -int64(p.result), nil } return int64(p.result), nil } ","date":"2022-04-14","objectID":"/posts/220414-atoi/:3:3","tags":["State Machine","Source Code Analysis","Strings"],"title":"Production-Grade String Parsing: From atoi to State Machine","uri":"/posts/220414-atoi/"},{"categories":["Go"],"content":"4. Rust Standard Library Comparison ","date":"2022-04-14","objectID":"/posts/220414-atoi/:4:0","tags":["State Machine","Source Code Analysis","Strings"],"title":"Production-Grade String Parsing: From atoi to State Machine","uri":"/posts/220414-atoi/"},{"categories":["Go"],"content":"4.1 Rust’s from_str // Rust uses trait implementation impl FromStr for i32 { type Err = ParseIntError; fn from_str(s: \u0026str) -\u003e Result\u003ci32, ParseIntError\u003e { i32::from_str_radix(s, 10) } } // Usage let n: i32 = \"42\".parse()?; let n = i32::from_str_radix(\"0x2A\", 16)?; ","date":"2022-04-14","objectID":"/posts/220414-atoi/:4:1","tags":["State Machine","Source Code Analysis","Strings"],"title":"Production-Grade String Parsing: From atoi to State Machine","uri":"/posts/220414-atoi/"},{"categories":["Go"],"content":"4.2 Rust’s Error Handling pub enum IntErrorKind { Empty, // Empty string InvalidDigit, // Invalid character PosOverflow, // Positive overflow NegOverflow, // Negative overflow Zero, // Unexpected zero (some contexts) } ","date":"2022-04-14","objectID":"/posts/220414-atoi/:4:2","tags":["State Machine","Source Code Analysis","Strings"],"title":"Production-Grade String Parsing: From atoi to State Machine","uri":"/posts/220414-atoi/"},{"categories":["Go"],"content":"4.3 Comparison Feature Go Rust Return type (int64, error) Result\u003cT, ParseIntError\u003e Base Parameter Method name distinction Error granularity Error interface Enum type Sign handling Internal Type system distinction ","date":"2022-04-14","objectID":"/posts/220414-atoi/:4:3","tags":["State Machine","Source Code Analysis","Strings"],"title":"Production-Grade String Parsing: From atoi to State Machine","uri":"/posts/220414-atoi/"},{"categories":["Go"],"content":"5. Practical Applications ","date":"2022-04-14","objectID":"/posts/220414-atoi/:5:0","tags":["State Machine","Source Code Analysis","Strings"],"title":"Production-Grade String Parsing: From atoi to State Machine","uri":"/posts/220414-atoi/"},{"categories":["Go"],"content":"5.1 Config File Parsing type Config struct { Port int Timeout time.Duration MaxSize int64 } func parseSize(s string) (int64, error) { s = strings.TrimSpace(s) if len(s) == 0 { return 0, nil } // Support K, M, G suffixes unit := int64(1) switch s[len(s)-1] { case 'K', 'k': unit = 1024 s = s[:len(s)-1] case 'M', 'm': unit = 1024 * 1024 s = s[:len(s)-1] case 'G', 'g': unit = 1024 * 1024 * 1024 s = s[:len(s)-1] } n, err := strconv.ParseInt(s, 0, 64) if err != nil { return 0, err } // Check multiplication overflow if n \u003e 0 \u0026\u0026 unit \u003e math.MaxInt64/n { return 0, errors.New(\"size overflow\") } return n * unit, nil } // Usage parseSize(\"512M\") // 536870912 parseSize(\"0x100\") // 256 ","date":"2022-04-14","objectID":"/posts/220414-atoi/:5:1","tags":["State Machine","Source Code Analysis","Strings"],"title":"Production-Grade String Parsing: From atoi to State Machine","uri":"/posts/220414-atoi/"},{"categories":["Go"],"content":"5.2 Command Line Arguments func parsePort(s string) (int, error) { port, err := strconv.ParseInt(s, 10, 16) // 16 bits enough for port if err != nil { return 0, fmt.Errorf(\"invalid port: %w\", err) } if port \u003c 1 || port \u003e 65535 { return 0, fmt.Errorf(\"port must be 1-65535, got %d\", port) } return int(port), nil } ","date":"2022-04-14","objectID":"/posts/220414-atoi/:5:2","tags":["State Machine","Source Code Analysis","Strings"],"title":"Production-Grade String Parsing: From atoi to State Machine","uri":"/posts/220414-atoi/"},{"categories":["Go"],"content":"6. Summary Level Implementation Interview if-else, basic cases only Production State machine, complete error handling Standard library Highly optimized, multi-type multi-base Key takeaways: Overflow detection before operation, not after State machines make complex parsing logic clearer Error messages should be detailed, include original input Boundary conditions are what separate interview code from production code ","date":"2022-04-14","objectID":"/posts/220414-atoi/:6:0","tags":["State Machine","Source Code Analysis","Strings"],"title":"Production-Grade String Parsing: From atoi to State Machine","uri":"/posts/220414-atoi/"},{"categories":["Go"],"content":"After Go 1.18 shipped generics, we applied them in our NAS project. This post documents the real benefits, pitfalls, and best practices we discovered.","date":"2022-03-16","objectID":"/posts/220316-go1.18/","tags":["Generics","Best Practices","Refactoring"],"title":"Go Generics in Practice: Pitfalls and Best Practices","uri":"/posts/220316-go1.18/"},{"categories":["Go"],"content":"Go 1.18 finally brought generics. In our NAS project, we refactored several common modules using generics. This post documents real-world benefits, pitfalls, and best practices we learned. ","date":"2022-03-16","objectID":"/posts/220316-go1.18/:0:0","tags":["Generics","Best Practices","Refactoring"],"title":"Go Generics in Practice: Pitfalls and Best Practices","uri":"/posts/220316-go1.18/"},{"categories":["Go"],"content":"1. Why Do We Need Generics? ","date":"2022-03-16","objectID":"/posts/220316-go1.18/:1:0","tags":["Generics","Best Practices","Refactoring"],"title":"Go Generics in Practice: Pitfalls and Best Practices","uri":"/posts/220316-go1.18/"},{"categories":["Go"],"content":"1.1 The Pain of Duplicate Code Before generics, we had tons of code like this: func ContainsInt(slice []int, target int) bool { for _, v := range slice { if v == target { return true } } return false } func ContainsString(slice []string, target string) bool { for _, v := range slice { if v == target { return true } } return false } func ContainsInt64(slice []int64, target int64) bool { // Same exact logic again... } ","date":"2022-03-16","objectID":"/posts/220316-go1.18/:1:1","tags":["Generics","Best Practices","Refactoring"],"title":"Go Generics in Practice: Pitfalls and Best Practices","uri":"/posts/220316-go1.18/"},{"categories":["Go"],"content":"1.2 The Cost of interface func Contains(slice interface{}, target interface{}) bool { // Requires reflection s := reflect.ValueOf(slice) for i := 0; i \u003c s.Len(); i++ { if reflect.DeepEqual(s.Index(i).Interface(), target) { return true } } return false } // Problems: // 1. Poor performance (reflection) // 2. Not type-safe (no compile-time checks) // 3. Poor readability ","date":"2022-03-16","objectID":"/posts/220316-go1.18/:1:2","tags":["Generics","Best Practices","Refactoring"],"title":"Go Generics in Practice: Pitfalls and Best Practices","uri":"/posts/220316-go1.18/"},{"categories":["Go"],"content":"2. Basic Generic Refactoring ","date":"2022-03-16","objectID":"/posts/220316-go1.18/:2:0","tags":["Generics","Best Practices","Refactoring"],"title":"Go Generics in Practice: Pitfalls and Best Practices","uri":"/posts/220316-go1.18/"},{"categories":["Go"],"content":"2.1 Generic Functions // Go 1.18+ generic version func Contains[T comparable](slice []T, target T) bool { for _, v := range slice { if v == target { return true } } return false } // Usage Contains([]int{1, 2, 3}, 2) // true Contains([]string{\"a\", \"b\"}, \"c\") // false ","date":"2022-03-16","objectID":"/posts/220316-go1.18/:2:1","tags":["Generics","Best Practices","Refactoring"],"title":"Go Generics in Practice: Pitfalls and Best Practices","uri":"/posts/220316-go1.18/"},{"categories":["Go"],"content":"2.2 Generic Data Structures Generic Set: type Set[T comparable] map[T]struct{} func NewSet[T comparable](items ...T) Set[T] { s := make(Set[T]) for _, item := range items { s.Add(item) } return s } func (s Set[T]) Add(item T) { s[item] = struct{}{} } func (s Set[T]) Contains(item T) bool { _, ok := s[item] return ok } func (s Set[T]) Remove(item T) { delete(s, item) } // Usage ids := NewSet(1, 2, 3) ids.Contains(2) // true Generic Result: // Rust-inspired Result type type Result[T any] struct { value T err error } func Ok[T any](value T) Result[T] { return Result[T]{value: value} } func Err[T any](err error) Result[T] { return Result[T]{err: err} } func (r Result[T]) Unwrap() T { if r.err != nil { panic(r.err) } return r.value } func (r Result[T]) UnwrapOr(defaultValue T) T { if r.err != nil { return defaultValue } return r.value } ","date":"2022-03-16","objectID":"/posts/220316-go1.18/:2:2","tags":["Generics","Best Practices","Refactoring"],"title":"Go Generics in Practice: Pitfalls and Best Practices","uri":"/posts/220316-go1.18/"},{"categories":["Go"],"content":"3. Real-World Refactoring Cases ","date":"2022-03-16","objectID":"/posts/220316-go1.18/:3:0","tags":["Generics","Best Practices","Refactoring"],"title":"Go Generics in Practice: Pitfalls and Best Practices","uri":"/posts/220316-go1.18/"},{"categories":["Go"],"content":"3.1 Cache Module Refactoring Before: type IntCache struct { data map[string]int mu sync.RWMutex } type StringCache struct { data map[string]string mu sync.RWMutex } // Had to write Get/Set/Delete for each type... After: type Cache[K comparable, V any] struct { data map[K]V mu sync.RWMutex } func NewCache[K comparable, V any]() *Cache[K, V] { return \u0026Cache[K, V]{ data: make(map[K]V), } } func (c *Cache[K, V]) Get(key K) (V, bool) { c.mu.RLock() defer c.mu.RUnlock() val, ok := c.data[key] return val, ok } func (c *Cache[K, V]) Set(key K, value V) { c.mu.Lock() defer c.mu.Unlock() c.data[key] = value } func (c *Cache[K, V]) Delete(key K) { c.mu.Lock() defer c.mu.Unlock() delete(c.data, key) } // Usage userCache := NewCache[int64, *User]() userCache.Set(1001, \u0026User{Name: \"Paul\"}) ","date":"2022-03-16","objectID":"/posts/220316-go1.18/:3:1","tags":["Generics","Best Practices","Refactoring"],"title":"Go Generics in Practice: Pitfalls and Best Practices","uri":"/posts/220316-go1.18/"},{"categories":["Go"],"content":"3.2 Slice Utility Functions // Map: like map in other languages func Map[T, R any](slice []T, fn func(T) R) []R { result := make([]R, len(slice)) for i, v := range slice { result[i] = fn(v) } return result } // Filter: filter elements func Filter[T any](slice []T, fn func(T) bool) []T { result := make([]T, 0) for _, v := range slice { if fn(v) { result = append(result, v) } } return result } // Reduce: aggregate func Reduce[T, R any](slice []T, initial R, fn func(R, T) R) R { result := initial for _, v := range slice { result = fn(result, v) } return result } // Usage examples users := []User{{Age: 20}, {Age: 30}, {Age: 25}} ages := Map(users, func(u User) int { return u.Age }) // [20, 30, 25] adults := Filter(users, func(u User) bool { return u.Age \u003e= 25 }) // [Age:30, Age:25] totalAge := Reduce(users, 0, func(sum int, u User) int { return sum + u.Age }) // 75 ","date":"2022-03-16","objectID":"/posts/220316-go1.18/:3:2","tags":["Generics","Best Practices","Refactoring"],"title":"Go Generics in Practice: Pitfalls and Best Practices","uri":"/posts/220316-go1.18/"},{"categories":["Go"],"content":"4. Pitfalls We Hit ","date":"2022-03-16","objectID":"/posts/220316-go1.18/:4:0","tags":["Generics","Best Practices","Refactoring"],"title":"Go Generics in Practice: Pitfalls and Best Practices","uri":"/posts/220316-go1.18/"},{"categories":["Go"],"content":"4.1 Methods Can’t Have Type Parameters // Wrong: methods can't have their own type parameters type Container[T any] struct { data []T } func (c *Container[T]) Map[R any](fn func(T) R) []R { // Compile error: method must have no type parameters } // Correct: use a function instead func Map[T, R any](c *Container[T], fn func(T) R) []R { result := make([]R, len(c.data)) for i, v := range c.data { result[i] = fn(v) } return result } ","date":"2022-03-16","objectID":"/posts/220316-go1.18/:4:1","tags":["Generics","Best Practices","Refactoring"],"title":"Go Generics in Practice: Pitfalls and Best Practices","uri":"/posts/220316-go1.18/"},{"categories":["Go"],"content":"4.2 Can’t Use Type Parameters in Type Assertions // Wrong func Convert[T any](v interface{}) T { return v.(T) // Compile error } // Correct: use any as intermediate type func Convert[T any](v interface{}) (T, bool) { result, ok := v.(T) return result, ok } ","date":"2022-03-16","objectID":"/posts/220316-go1.18/:4:2","tags":["Generics","Best Practices","Refactoring"],"title":"Go Generics in Practice: Pitfalls and Best Practices","uri":"/posts/220316-go1.18/"},{"categories":["Go"],"content":"4.3 Zero Value Issues func GetOrDefault[T any](ptr *T) T { if ptr == nil { var zero T return zero // Returns type's zero value } return *ptr } // But what if you need an explicit default? func GetOrDefault[T any](ptr *T, defaultVal T) T { if ptr == nil { return defaultVal } return *ptr } ","date":"2022-03-16","objectID":"/posts/220316-go1.18/:4:3","tags":["Generics","Best Practices","Refactoring"],"title":"Go Generics in Practice: Pitfalls and Best Practices","uri":"/posts/220316-go1.18/"},{"categories":["Go"],"content":"4.4 Constraint Design // Custom constraint type Number interface { int | int8 | int16 | int32 | int64 | uint | uint8 | uint16 | uint32 | uint64 | float32 | float64 } func Sum[T Number](nums []T) T { var total T for _, n := range nums { total += n } return total } // Use golang.org/x/exp/constraints import \"golang.org/x/exp/constraints\" func Max[T constraints.Ordered](a, b T) T { if a \u003e b { return a } return b } ","date":"2022-03-16","objectID":"/posts/220316-go1.18/:4:4","tags":["Generics","Best Practices","Refactoring"],"title":"Go Generics in Practice: Pitfalls and Best Practices","uri":"/posts/220316-go1.18/"},{"categories":["Go"],"content":"5. Performance Comparison ","date":"2022-03-16","objectID":"/posts/220316-go1.18/:5:0","tags":["Generics","Best Practices","Refactoring"],"title":"Go Generics in Practice: Pitfalls and Best Practices","uri":"/posts/220316-go1.18/"},{"categories":["Go"],"content":"5.1 Generics vs Reflection // Benchmark test func BenchmarkGeneric(b *testing.B) { slice := make([]int, 1000) for i := range slice { slice[i] = i } b.ResetTimer() for i := 0; i \u003c b.N; i++ { Contains(slice, 500) } } func BenchmarkReflect(b *testing.B) { slice := make([]int, 1000) for i := range slice { slice[i] = i } b.ResetTimer() for i := 0; i \u003c b.N; i++ { ContainsReflect(slice, 500) } } Results: BenchmarkGeneric-8 5000000 250 ns/op 0 B/op 0 allocs/op BenchmarkReflect-8 500000 3200 ns/op 100 B/op 5 allocs/op Generics are 12x faster with zero allocations! ","date":"2022-03-16","objectID":"/posts/220316-go1.18/:5:1","tags":["Generics","Best Practices","Refactoring"],"title":"Go Generics in Practice: Pitfalls and Best Practices","uri":"/posts/220316-go1.18/"},{"categories":["Go"],"content":"5.2 Generics vs Hand-Written func BenchmarkGenericContains(b *testing.B) { // Generic version } func BenchmarkHandwrittenContains(b *testing.B) { // func ContainsInt([]int, int) bool version } Results: BenchmarkGeneric-8 5000000 250 ns/op BenchmarkHandwritten-8 5000000 248 ns/op Nearly identical! Go compiler generates specialized code for each type (monomorphization). ","date":"2022-03-16","objectID":"/posts/220316-go1.18/:5:2","tags":["Generics","Best Practices","Refactoring"],"title":"Go Generics in Practice: Pitfalls and Best Practices","uri":"/posts/220316-go1.18/"},{"categories":["Go"],"content":"6. Best Practices ","date":"2022-03-16","objectID":"/posts/220316-go1.18/:6:0","tags":["Generics","Best Practices","Refactoring"],"title":"Go Generics in Practice: Pitfalls and Best Practices","uri":"/posts/220316-go1.18/"},{"categories":["Go"],"content":"6.1 When to Use Generics Good fit: Container types (List, Set, Map, Stack, Queue) Common algorithms (sort, search, filter) Utility functions (Contains, Map, Reduce) Not a good fit: Business logic code (don’t over-abstract) Only one or two types (not worth generalizing) Need runtime type info (generics are compile-time) ","date":"2022-03-16","objectID":"/posts/220316-go1.18/:6:1","tags":["Generics","Best Practices","Refactoring"],"title":"Go Generics in Practice: Pitfalls and Best Practices","uri":"/posts/220316-go1.18/"},{"categories":["Go"],"content":"6.2 Constraint Selection // Prefer built-in constraints any // Any type comparable // Types supporting == != // Use x/exp/constraints constraints.Ordered // Supports \u003c \u003e \u003c= \u003e= constraints.Integer // Integers constraints.Float // Floats constraints.Signed // Signed numbers constraints.Unsigned // Unsigned numbers ","date":"2022-03-16","objectID":"/posts/220316-go1.18/:6:2","tags":["Generics","Best Practices","Refactoring"],"title":"Go Generics in Practice: Pitfalls and Best Practices","uri":"/posts/220316-go1.18/"},{"categories":["Go"],"content":"6.3 Naming Conventions // Type parameter naming T // Single type K, V // Key-value pair T, R // Input-output E // Element S // Slice // Constraint naming type Stringer interface { String() string } type Comparable[T any] interface { Compare(T) int } ","date":"2022-03-16","objectID":"/posts/220316-go1.18/:6:3","tags":["Generics","Best Practices","Refactoring"],"title":"Go Generics in Practice: Pitfalls and Best Practices","uri":"/posts/220316-go1.18/"},{"categories":["Go"],"content":"7. Project Benefits ","date":"2022-03-16","objectID":"/posts/220316-go1.18/:7:0","tags":["Generics","Best Practices","Refactoring"],"title":"Go Generics in Practice: Pitfalls and Best Practices","uri":"/posts/220316-go1.18/"},{"categories":["Go"],"content":"7.1 Code Reduction Module Before After Reduction Cache 450 lines 120 lines -73% Slice utils 280 lines 80 lines -71% Data structures 600 lines 200 lines -67% ","date":"2022-03-16","objectID":"/posts/220316-go1.18/:7:1","tags":["Generics","Best Practices","Refactoring"],"title":"Go Generics in Practice: Pitfalls and Best Practices","uri":"/posts/220316-go1.18/"},{"categories":["Go"],"content":"7.2 Maintenance Cost Bug fixes: Used to fix N versions, now fix once New types: Used to copy code, now just use Type safety: Errors caught at compile time ","date":"2022-03-16","objectID":"/posts/220316-go1.18/:7:2","tags":["Generics","Best Practices","Refactoring"],"title":"Go Generics in Practice: Pitfalls and Best Practices","uri":"/posts/220316-go1.18/"},{"categories":["Go"],"content":"8. Summary Point Recommendation Use cases Containers, utilities, algorithms Performance Equal to hand-written, far better than reflection Constraints Prefer any/comparable/constraints Methods Methods can’t have type params, use functions Zero values Use var zero T to get them Key takeaway: Generics aren’t a silver bullet, but in the right scenarios, they significantly reduce duplicate code while maintaining type safety and performance. ","date":"2022-03-16","objectID":"/posts/220316-go1.18/:8:0","tags":["Generics","Best Practices","Refactoring"],"title":"Go Generics in Practice: Pitfalls and Best Practices","uri":"/posts/220316-go1.18/"},{"categories":null,"content":"Hey, I’m Zane. Originally from Jiangxi, now based in Shenzhen. I majored in software engineering at GNNU. I love digging into distributed systems, tinkering with Linux internals, and chasing down obscure bugs at 2am. If you’re into Go, databases, or anything systems-related — let’s chat! ","date":"2022-03-04","objectID":"/about/:0:0","tags":null,"title":"about me","uri":"/about/"},{"categories":["Networking"],"content":"Real-world testing of HTTP/3 (QUIC) using curl and Wireshark, comparing performance against HTTP/2 on degraded networks with high latency and packet loss.","date":"2022-01-01","objectID":"/posts/220101-http3/","tags":["HTTP/3","QUIC","Performance Testing"],"title":"HTTP/3 Benchmarks: QUIC Performance on Lossy Networks with Packet Analysis","uri":"/posts/220101-http3/"},{"categories":["Networking"],"content":"HTTP/3 replaces TCP+TLS with QUIC, claiming to solve “head-of-line blocking”. But how does it actually perform? This post uses simulated degraded networks to compare HTTP/2 and HTTP/3 with real data. ","date":"2022-01-01","objectID":"/posts/220101-http3/:0:0","tags":["HTTP/3","QUIC","Performance Testing"],"title":"HTTP/3 Benchmarks: QUIC Performance on Lossy Networks with Packet Analysis","uri":"/posts/220101-http3/"},{"categories":["Networking"],"content":"1. HTTP/3 Core Improvements ","date":"2022-01-01","objectID":"/posts/220101-http3/:1:0","tags":["HTTP/3","QUIC","Performance Testing"],"title":"HTTP/3 Benchmarks: QUIC Performance on Lossy Networks with Packet Analysis","uri":"/posts/220101-http3/"},{"categories":["Networking"],"content":"1.1 Protocol Stack Comparison HTTP/2: HTTP/3: ┌─────────────┐ ┌─────────────┐ │ HTTP/2 │ │ HTTP/3 │ ├─────────────┤ ├─────────────┤ │ TLS 1.3 │ │ QUIC │ ← Transport + encryption merged ├─────────────┤ │ (incl TLS) │ │ TCP │ └──────┬──────┘ └─────────────┘ │ │ ┌─────▼─────┐ │ UDP │ └───────────┘ ","date":"2022-01-01","objectID":"/posts/220101-http3/:1:1","tags":["HTTP/3","QUIC","Performance Testing"],"title":"HTTP/3 Benchmarks: QUIC Performance on Lossy Networks with Packet Analysis","uri":"/posts/220101-http3/"},{"categories":["Networking"],"content":"1.2 Theoretical Advantages Problem HTTP/2 (TCP) HTTP/3 (QUIC) Handshake latency TCP (1-RTT) + TLS (1-2 RTT) 0-1 RTT Head-of-line blocking Exists at TCP layer Completely solved Connection migration IP change requires reconnect Seamless migration Packet loss recovery Slow retransmission Faster recovery ","date":"2022-01-01","objectID":"/posts/220101-http3/:1:2","tags":["HTTP/3","QUIC","Performance Testing"],"title":"HTTP/3 Benchmarks: QUIC Performance on Lossy Networks with Packet Analysis","uri":"/posts/220101-http3/"},{"categories":["Networking"],"content":"2. Test Environment Setup ","date":"2022-01-01","objectID":"/posts/220101-http3/:2:0","tags":["HTTP/3","QUIC","Performance Testing"],"title":"HTTP/3 Benchmarks: QUIC Performance on Lossy Networks with Packet Analysis","uri":"/posts/220101-http3/"},{"categories":["Networking"],"content":"2.1 Simulating Degraded Networks Using Linux tc command: # Add 100ms delay + 5% packet loss sudo tc qdisc add dev eth0 root netem delay 100ms loss 5% # Check current settings tc qdisc show dev eth0 # Restore normal sudo tc qdisc del dev eth0 root ","date":"2022-01-01","objectID":"/posts/220101-http3/:2:1","tags":["HTTP/3","QUIC","Performance Testing"],"title":"HTTP/3 Benchmarks: QUIC Performance on Lossy Networks with Packet Analysis","uri":"/posts/220101-http3/"},{"categories":["Networking"],"content":"2.2 Test Targets Pick a site that supports both HTTP/2 and HTTP/3: # Check if site supports HTTP/3 curl -I https://cloudflare.com 2\u003e\u00261 | grep -i alt-svc # alt-svc: h3=\":443\" ← Supports HTTP/3 ","date":"2022-01-01","objectID":"/posts/220101-http3/:2:2","tags":["HTTP/3","QUIC","Performance Testing"],"title":"HTTP/3 Benchmarks: QUIC Performance on Lossy Networks with Packet Analysis","uri":"/posts/220101-http3/"},{"categories":["Networking"],"content":"2.3 curl with HTTP/3 Support # Check curl version (need 7.66+) curl --version | grep HTTP3 # If not supported, install HTTP/3-enabled version # Ubuntu: sudo add-apt-repository ppa:savoury1/curl34 sudo apt update \u0026\u0026 sudo apt install curl ","date":"2022-01-01","objectID":"/posts/220101-http3/:2:3","tags":["HTTP/3","QUIC","Performance Testing"],"title":"HTTP/3 Benchmarks: QUIC Performance on Lossy Networks with Packet Analysis","uri":"/posts/220101-http3/"},{"categories":["Networking"],"content":"3. Performance Comparison Tests ","date":"2022-01-01","objectID":"/posts/220101-http3/:3:0","tags":["HTTP/3","QUIC","Performance Testing"],"title":"HTTP/3 Benchmarks: QUIC Performance on Lossy Networks with Packet Analysis","uri":"/posts/220101-http3/"},{"categories":["Networking"],"content":"3.1 Normal Network # HTTP/2 curl -w \"Total: %{time_total}s\\n\" -o /dev/null -s --http2 https://cloudflare.com # HTTP/3 curl -w \"Total: %{time_total}s\\n\" -o /dev/null -s --http3 https://cloudflare.com Results (no degradation): Protocol First Connection Reused Connection HTTP/2 180ms 50ms HTTP/3 150ms 45ms HTTP/3 is slightly faster, but not by much. ","date":"2022-01-01","objectID":"/posts/220101-http3/:3:1","tags":["HTTP/3","QUIC","Performance Testing"],"title":"HTTP/3 Benchmarks: QUIC Performance on Lossy Networks with Packet Analysis","uri":"/posts/220101-http3/"},{"categories":["Networking"],"content":"3.2 High Latency Network (100ms RTT) # Add delay sudo tc qdisc add dev eth0 root netem delay 100ms # Test for i in {1..10}; do echo \"=== HTTP/2 ===\" curl -w \"%{time_total}s\\n\" -o /dev/null -s --http2 https://cloudflare.com echo \"=== HTTP/3 ===\" curl -w \"%{time_total}s\\n\" -o /dev/null -s --http3 https://cloudflare.com done Results (100ms RTT): Protocol Avg Time Handshake % HTTP/2 650ms 46% HTTP/3 450ms 33% Analysis: On high-latency networks, QUIC’s 0-RTT handshake advantage is significant. ","date":"2022-01-01","objectID":"/posts/220101-http3/:3:2","tags":["HTTP/3","QUIC","Performance Testing"],"title":"HTTP/3 Benchmarks: QUIC Performance on Lossy Networks with Packet Analysis","uri":"/posts/220101-http3/"},{"categories":["Networking"],"content":"3.3 Lossy Network (5% Packet Loss) # Add packet loss sudo tc qdisc change dev eth0 root netem delay 50ms loss 5% # Test (load a large page) time curl -o /dev/null -s --http2 https://www.cloudflare.com/ time curl -o /dev/null -s --http3 https://www.cloudflare.com/ Results (5% packet loss): Protocol Avg Time Std Dev HTTP/2 2.1s ±0.8s HTTP/3 1.3s ±0.3s Key findings: HTTP/3 is 40% faster on average HTTP/3 is more stable (lower standard deviation) ","date":"2022-01-01","objectID":"/posts/220101-http3/:3:3","tags":["HTTP/3","QUIC","Performance Testing"],"title":"HTTP/3 Benchmarks: QUIC Performance on Lossy Networks with Packet Analysis","uri":"/posts/220101-http3/"},{"categories":["Networking"],"content":"4. Packet Analysis ","date":"2022-01-01","objectID":"/posts/220101-http3/:4:0","tags":["HTTP/3","QUIC","Performance Testing"],"title":"HTTP/3 Benchmarks: QUIC Performance on Lossy Networks with Packet Analysis","uri":"/posts/220101-http3/"},{"categories":["Networking"],"content":"4.1 Capturing QUIC with Wireshark # Need to set SSLKEYLOGFILE to decrypt QUIC export SSLKEYLOGFILE=/tmp/keylog.txt curl --http3 https://cloudflare.com # In Wireshark: # Edit → Preferences → Protocols → TLS # Set (Pre)-Master-Secret log filename: /tmp/keylog.txt ","date":"2022-01-01","objectID":"/posts/220101-http3/:4:1","tags":["HTTP/3","QUIC","Performance Testing"],"title":"HTTP/3 Benchmarks: QUIC Performance on Lossy Networks with Packet Analysis","uri":"/posts/220101-http3/"},{"categories":["Networking"],"content":"4.2 Observing Head-of-Line Blocking HTTP/2 (TCP) Problem: Timeline: Stream 1: [Packet 1] [Packet 2] ... Stream 2: [Packet 1] [Packet 2] ... Stream 3: [Packet 1] [Packet 2] ... If Stream 1's Packet 1 is lost: TCP: Wait for retransmission... (ALL streams are blocked!) ↓ Stream 2, 3 data has arrived, but can't be delivered to app HTTP/3 (QUIC) Solution: QUIC implements multiplexing over UDP: Stream 1: [Packet 1 lost] → Retransmit Stream 2: [Processing normally] ← Not affected! Stream 3: [Processing normally] ← Not affected! ","date":"2022-01-01","objectID":"/posts/220101-http3/:4:2","tags":["HTTP/3","QUIC","Performance Testing"],"title":"HTTP/3 Benchmarks: QUIC Performance on Lossy Networks with Packet Analysis","uri":"/posts/220101-http3/"},{"categories":["Networking"],"content":"4.3 Connection Migration Demo QUIC uses Connection ID instead of IP:Port to identify connections: # Simulate WiFi → 4G switch # 1. Start download curl --http3 -O https://terra-nas.com/largefile.bin \u0026 # 2. Switch network interface sudo ip route change default via 192.168.1.1 dev wlan0 sudo ip route change default via 10.0.0.1 dev eth0 # 3. Observe if download is interrupted # HTTP/3: Continues (Connection ID unchanged) # HTTP/2: Connection drops, needs to reconnect ","date":"2022-01-01","objectID":"/posts/220101-http3/:4:3","tags":["HTTP/3","QUIC","Performance Testing"],"title":"HTTP/3 Benchmarks: QUIC Performance on Lossy Networks with Packet Analysis","uri":"/posts/220101-http3/"},{"categories":["Networking"],"content":"5. QUIC Internals Deep Dive ","date":"2022-01-01","objectID":"/posts/220101-http3/:5:0","tags":["HTTP/3","QUIC","Performance Testing"],"title":"HTTP/3 Benchmarks: QUIC Performance on Lossy Networks with Packet Analysis","uri":"/posts/220101-http3/"},{"categories":["Networking"],"content":"5.1 Flow Control QUIC has two levels of flow control: Connection level: Limits total flow across all Streams Stream level: Limits individual Stream flow ┌─────────────────────────────────────┐ │ Connection Window = 1MB │ │ ┌───────────┐ ┌───────────┐ │ │ │ Stream 1 │ │ Stream 2 │ ... │ │ │ Window= │ │ Window= │ │ │ │ 256KB │ │ 256KB │ │ │ └───────────┘ └───────────┘ │ └─────────────────────────────────────┘ ","date":"2022-01-01","objectID":"/posts/220101-http3/:5:1","tags":["HTTP/3","QUIC","Performance Testing"],"title":"HTTP/3 Benchmarks: QUIC Performance on Lossy Networks with Packet Analysis","uri":"/posts/220101-http3/"},{"categories":["Networking"],"content":"5.2 Packet Loss Detection \u0026 Recovery TCP packet loss recovery: Send: 1, 2, 3, 4, 5 ACK: 1, 2, - (3 lost) Wait for timeout... or 3 duplicate ACKs Retransmit: 3 QUIC packet loss recovery: Each packet has a unique, incrementing sequence number ACK packets contain detailed received ranges More accurate RTT estimation Faster retransmission triggering ","date":"2022-01-01","objectID":"/posts/220101-http3/:5:2","tags":["HTTP/3","QUIC","Performance Testing"],"title":"HTTP/3 Benchmarks: QUIC Performance on Lossy Networks with Packet Analysis","uri":"/posts/220101-http3/"},{"categories":["Networking"],"content":"5.3 0-RTT Mechanism First connection: Client → Server: ClientHello + supported keys Client ← Server: ServerHello + cert + Session Ticket Client → Server: Start sending encrypted data Subsequent connections: Client → Server: ClientHello + EarlyData (using previous Session Ticket) Data is already transmitting! No need to wait for handshake ","date":"2022-01-01","objectID":"/posts/220101-http3/:5:3","tags":["HTTP/3","QUIC","Performance Testing"],"title":"HTTP/3 Benchmarks: QUIC Performance on Lossy Networks with Packet Analysis","uri":"/posts/220101-http3/"},{"categories":["Networking"],"content":"6. Practical Recommendations ","date":"2022-01-01","objectID":"/posts/220101-http3/:6:0","tags":["HTTP/3","QUIC","Performance Testing"],"title":"HTTP/3 Benchmarks: QUIC Performance on Lossy Networks with Packet Analysis","uri":"/posts/220101-http3/"},{"categories":["Networking"],"content":"6.1 When to Use HTTP/3 Scenario Recommendation Reason Mobile clients Strongly recommended Frequent network switching, high packet loss Weak network regions Strongly recommended High latency, high packet loss Internal services Optional Stable network, small benefit Real-time communication Recommended Low latency requirements ","date":"2022-01-01","objectID":"/posts/220101-http3/:6:1","tags":["HTTP/3","QUIC","Performance Testing"],"title":"HTTP/3 Benchmarks: QUIC Performance on Lossy Networks with Packet Analysis","uri":"/posts/220101-http3/"},{"categories":["Networking"],"content":"6.2 Nginx HTTP/3 Configuration # Requires Nginx 1.25+ or nginx-quic server { listen 443 ssl; listen 443 quic reuseport; http2 on; http3 on; http3_hq on; ssl_certificate /path/to/cert.pem; ssl_certificate_key /path/to/key.pem; # Tell clients HTTP/3 is supported add_header Alt-Svc 'h3=\":443\"; ma=86400'; } ","date":"2022-01-01","objectID":"/posts/220101-http3/:6:2","tags":["HTTP/3","QUIC","Performance Testing"],"title":"HTTP/3 Benchmarks: QUIC Performance on Lossy Networks with Packet Analysis","uri":"/posts/220101-http3/"},{"categories":["Networking"],"content":"6.3 CDN Support Status CDN HTTP/3 Support Cloudflare Enabled by default Google Cloud CDN Supported AWS CloudFront Supported Akamai Supported ","date":"2022-01-01","objectID":"/posts/220101-http3/:6:3","tags":["HTTP/3","QUIC","Performance Testing"],"title":"HTTP/3 Benchmarks: QUIC Performance on Lossy Networks with Packet Analysis","uri":"/posts/220101-http3/"},{"categories":["Networking"],"content":"7. Summary ","date":"2022-01-01","objectID":"/posts/220101-http3/:7:0","tags":["HTTP/3","QUIC","Performance Testing"],"title":"HTTP/3 Benchmarks: QUIC Performance on Lossy Networks with Packet Analysis","uri":"/posts/220101-http3/"},{"categories":["Networking"],"content":"7.1 Test Conclusions Network Condition HTTP/3 Advantage Normal network Slightly faster 10-20% High latency (100ms+) 30-40% faster High packet loss (5%+) 40%+ faster, more stable Network switching Seamless migration vs reconnect ","date":"2022-01-01","objectID":"/posts/220101-http3/:7:1","tags":["HTTP/3","QUIC","Performance Testing"],"title":"HTTP/3 Benchmarks: QUIC Performance on Lossy Networks with Packet Analysis","uri":"/posts/220101-http3/"},{"categories":["Networking"],"content":"7.2 Key Takeaways Head-of-line blocking is a real problem: On lossy networks, TCP-multiplexed streams block each other 0-RTT is a killer feature: Noticeably better on high-latency networks UDP ≠ unreliable: QUIC implements reliable transport in userspace Low migration cost: Major browsers and CDNs already support it, just flip a config switch Recommendation: If your user base has a significant mobile or weak-network population, HTTP/3 is worth enabling. ","date":"2022-01-01","objectID":"/posts/220101-http3/:7:2","tags":["HTTP/3","QUIC","Performance Testing"],"title":"HTTP/3 Benchmarks: QUIC Performance on Lossy Networks with Packet Analysis","uri":"/posts/220101-http3/"},{"categories":["Networking"],"content":"A deep dive into TLS handshake optimization: TLS 1.3, OCSP Stapling, certificate chain tuning, and Session Resumption explained with real-world examples.","date":"2021-12-26","objectID":"/posts/211226-https/","tags":["HTTPS","TLS","Performance"],"title":"HTTPS Handshake Optimization: Cutting Latency from 200ms to 50ms","uri":"/posts/211226-https/"},{"categories":["Networking"],"content":"Users were complaining about slow page loads. Chrome DevTools showed a TTFB (Time To First Byte) of 400ms, with HTTPS handshake alone taking 200ms. This post documents how I got that down to 50ms. ","date":"2021-12-26","objectID":"/posts/211226-https/:0:0","tags":["HTTPS","TLS","Performance"],"title":"HTTPS Handshake Optimization: Cutting Latency from 200ms to 50ms","uri":"/posts/211226-https/"},{"categories":["Networking"],"content":"1. Diagnosing the Problem ","date":"2021-12-26","objectID":"/posts/211226-https/:1:0","tags":["HTTPS","TLS","Performance"],"title":"HTTPS Handshake Optimization: Cutting Latency from 200ms to 50ms","uri":"/posts/211226-https/"},{"categories":["Networking"],"content":"1.1 Packet Analysis # Measure timing for each phase with curl curl -w \"@curl-format.txt\" -o /dev/null -s https://terra-nas.com # curl-format.txt: # time_namelookup: %{time_namelookup}s\\n # time_connect: %{time_connect}s\\n # time_appconnect: %{time_appconnect}s\\n # time_starttransfer: %{time_starttransfer}s\\n # time_total: %{time_total}s\\n Results: time_namelookup: 0.020s # DNS time_connect: 0.060s # TCP (RTT ≈ 40ms) time_appconnect: 0.260s # TLS handshake complete! time_starttransfer: 0.280s time_total: 0.350s TLS handshake took 200ms — the time between TCP connection and application data transfer. ","date":"2021-12-26","objectID":"/posts/211226-https/:1:1","tags":["HTTPS","TLS","Performance"],"title":"HTTPS Handshake Optimization: Cutting Latency from 200ms to 50ms","uri":"/posts/211226-https/"},{"categories":["Networking"],"content":"1.2 Breaking Down the Handshake Using openssl s_client for detailed analysis: openssl s_client -connect terra-nas.com:443 -status 2\u003e\u00261 | head -50 Issues found: Server was using TLS 1.2 (requires 2-RTT handshake) OCSP response — client was fetching it separately (extra latency) Certificate chain included 3 certificates (more data to transfer) ","date":"2021-12-26","objectID":"/posts/211226-https/:1:2","tags":["HTTPS","TLS","Performance"],"title":"HTTPS Handshake Optimization: Cutting Latency from 200ms to 50ms","uri":"/posts/211226-https/"},{"categories":["Networking"],"content":"2. TLS Handshake Internals ","date":"2021-12-26","objectID":"/posts/211226-https/:2:0","tags":["HTTPS","TLS","Performance"],"title":"HTTPS Handshake Optimization: Cutting Latency from 200ms to 50ms","uri":"/posts/211226-https/"},{"categories":["Networking"],"content":"2.1 TLS 1.2 Handshake (2-RTT) Client Server | | |------- ClientHello ---------------\u003e| RTT 1 |\u003c------ ServerHello + Cert ---------| |\u003c------ ServerKeyExchange ----------| |\u003c------ ServerHelloDone ------------| | | |------- ClientKeyExchange ---------\u003e| RTT 2 |------- ChangeCipherSpec ----------\u003e| |------- Finished ------------------\u003e| |\u003c------ ChangeCipherSpec -----------| |\u003c------ Finished -------------------| | | |======= Application Data ==========\u003e| Finally can send data! Latency: At least 2 RTTs. With RTT=40ms, TLS handshake ≥ 80ms. But we measured 200ms — there’s additional overhead somewhere. ","date":"2021-12-26","objectID":"/posts/211226-https/:2:1","tags":["HTTPS","TLS","Performance"],"title":"HTTPS Handshake Optimization: Cutting Latency from 200ms to 50ms","uri":"/posts/211226-https/"},{"categories":["Networking"],"content":"2.2 TLS 1.3 Handshake (1-RTT) Client Server | | |------- ClientHello + KeyShare ----\u003e| RTT 1 |\u003c------ ServerHello + KeyShare -----| |\u003c------ EncryptedExtensions --------| |\u003c------ Certificate ----------------| |\u003c------ CertificateVerify ----------| |\u003c------ Finished -------------------| |------- Finished ------------------\u003e| | | |======= Application Data ==========\u003e| Can send data after 1-RTT! Key optimization: ClientHello includes key exchange parameters upfront, saving one RTT. ","date":"2021-12-26","objectID":"/posts/211226-https/:2:2","tags":["HTTPS","TLS","Performance"],"title":"HTTPS Handshake Optimization: Cutting Latency from 200ms to 50ms","uri":"/posts/211226-https/"},{"categories":["Networking"],"content":"2.3 0-RTT (TLS 1.3 Early Data) # After first connection, server sends Session Ticket # Subsequent connections can send encrypted data immediately Client Server | | |------- ClientHello + EarlyData ---\u003e| 0-RTT! |======= Application data already flowing ======\u003e| |\u003c------ ServerHello + ... ----------| Heads up: 0-RTT is vulnerable to replay attacks — only use for idempotent requests. ","date":"2021-12-26","objectID":"/posts/211226-https/:2:3","tags":["HTTPS","TLS","Performance"],"title":"HTTPS Handshake Optimization: Cutting Latency from 200ms to 50ms","uri":"/posts/211226-https/"},{"categories":["Networking"],"content":"3. Optimization Steps ","date":"2021-12-26","objectID":"/posts/211226-https/:3:0","tags":["HTTPS","TLS","Performance"],"title":"HTTPS Handshake Optimization: Cutting Latency from 200ms to 50ms","uri":"/posts/211226-https/"},{"categories":["Networking"],"content":"3.1 Enable TLS 1.3 Nginx config: server { listen 443 ssl http2; ssl_protocols TLSv1.2 TLSv1.3; # Support both 1.2 and 1.3 ssl_prefer_server_ciphers off; # Not needed for TLS 1.3 # TLS 1.3 cipher suites ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384; # Enable 0-RTT (use with caution) ssl_early_data on; } Result: TLS handshake drops from 2-RTT to 1-RTT, saving 40ms. ","date":"2021-12-26","objectID":"/posts/211226-https/:3:1","tags":["HTTPS","TLS","Performance"],"title":"HTTPS Handshake Optimization: Cutting Latency from 200ms to 50ms","uri":"/posts/211226-https/"},{"categories":["Networking"],"content":"3.2 OCSP Stapling The problem: Clients need to verify if the certificate is revoked. Traditional approach sends an OCSP request to the CA. Traditional flow: Client --\u003e Server: Get certificate Client --\u003e CA (OCSP): Is this cert valid? ← Extra RTT! CA --\u003e Client: Yes Client --\u003e Server: Continue handshake OCSP Stapling: Server pre-fetches the OCSP response and sends it during the handshake. ssl_stapling on; ssl_stapling_verify on; ssl_trusted_certificate /path/to/chain.pem; # Set OCSP responder resolver 8.8.8.8 valid=300s; resolver_timeout 5s; Verify it’s working: openssl s_client -connect terra-nas.com:443 -status 2\u003e\u00261 | grep -A 15 \"OCSP\" # OCSP Response Status: successful Result: Eliminates client-side OCSP lookup, saving 50-100ms. ","date":"2021-12-26","objectID":"/posts/211226-https/:3:2","tags":["HTTPS","TLS","Performance"],"title":"HTTPS Handshake Optimization: Cutting Latency from 200ms to 50ms","uri":"/posts/211226-https/"},{"categories":["Networking"],"content":"3.3 Certificate Chain Optimization The problem: Full certificate chain might have 3-4 certs, increasing transfer size. # Check the certificate chain openssl s_client -connect terra-nas.com:443 -showcerts 2\u003e/dev/null | grep \"s:\" # s:/CN=terra-nas.com # s:/CN=Let's Encrypt Authority X3 # Intermediate cert # s:/CN=DST Root CA X3 # Root cert (shouldn't be sent!) Fix: Only send site cert + intermediate cert. Skip root cert (browsers already have it). # Correct certificate file should contain: # 1. Site certificate # 2. Intermediate certificate # (NOT the root certificate) ssl_certificate /path/to/fullchain.pem; ssl_certificate_key /path/to/privkey.pem; Result: Reduces transfer by ~1KB. ","date":"2021-12-26","objectID":"/posts/211226-https/:3:3","tags":["HTTPS","TLS","Performance"],"title":"HTTPS Handshake Optimization: Cutting Latency from 200ms to 50ms","uri":"/posts/211226-https/"},{"categories":["Networking"],"content":"3.4 Session Resumption Session Tickets (stateless resumption): ssl_session_tickets on; ssl_session_timeout 1d; # 24 hours # Custom ticket key (share across servers if needed) ssl_session_ticket_key /path/to/ticket.key; Session Cache (stateful resumption): ssl_session_cache shared:SSL:10m; # 10MB shared cache ssl_session_timeout 1d; Result: Returning visitors get 1-RTT or even 0-RTT handshakes. ","date":"2021-12-26","objectID":"/posts/211226-https/:3:4","tags":["HTTPS","TLS","Performance"],"title":"HTTPS Handshake Optimization: Cutting Latency from 200ms to 50ms","uri":"/posts/211226-https/"},{"categories":["Networking"],"content":"3.5 Switch to ECDSA Certificates RSA certificate verification is slower. ECDSA is faster and has shorter keys. # Generate ECDSA private key openssl ecparam -genkey -name prime256v1 -out privkey.pem # Generate CSR openssl req -new -key privkey.pem -out csr.pem # Request certificate (Let's Encrypt supports ECDSA) certbot certonly --csr csr.pem Comparison: Type Key Length Security Equivalent Signing Speed RSA 2048 2048 bits 112 bits Slow ECDSA P-256 256 bits 128 bits 3-4x faster ","date":"2021-12-26","objectID":"/posts/211226-https/:3:5","tags":["HTTPS","TLS","Performance"],"title":"HTTPS Handshake Optimization: Cutting Latency from 200ms to 50ms","uri":"/posts/211226-https/"},{"categories":["Networking"],"content":"3.6 Enable HTTP/2 HTTP/2 multiplexes requests over a single TCP connection, so TLS handshake only happens once. listen 443 ssl http2; ","date":"2021-12-26","objectID":"/posts/211226-https/:3:6","tags":["HTTPS","TLS","Performance"],"title":"HTTPS Handshake Optimization: Cutting Latency from 200ms to 50ms","uri":"/posts/211226-https/"},{"categories":["Networking"],"content":"4. Performance Comparison ","date":"2021-12-26","objectID":"/posts/211226-https/:4:0","tags":["HTTPS","TLS","Performance"],"title":"HTTPS Handshake Optimization: Cutting Latency from 200ms to 50ms","uri":"/posts/211226-https/"},{"categories":["Networking"],"content":"4.1 Before vs After # Before optimization curl -w \"TLS: %{time_appconnect}s\\n\" -o /dev/null -s https://terra-nas.com # TLS: 0.260s # After optimization curl -w \"TLS: %{time_appconnect}s\\n\" -o /dev/null -s https://terra-nas.com # TLS: 0.050s ","date":"2021-12-26","objectID":"/posts/211226-https/:4:1","tags":["HTTPS","TLS","Performance"],"title":"HTTPS Handshake Optimization: Cutting Latency from 200ms to 50ms","uri":"/posts/211226-https/"},{"categories":["Networking"],"content":"4.2 Time Savings Breakdown Optimization Time Saved TLS 1.3 (1-RTT) 40ms OCSP Stapling 60ms Session Resumption 40ms Certificate chain 10ms ECDSA certificate 5ms Total ~150ms ","date":"2021-12-26","objectID":"/posts/211226-https/:4:2","tags":["HTTPS","TLS","Performance"],"title":"HTTPS Handshake Optimization: Cutting Latency from 200ms to 50ms","uri":"/posts/211226-https/"},{"categories":["Networking"],"content":"5. Monitoring \u0026 Verification ","date":"2021-12-26","objectID":"/posts/211226-https/:5:0","tags":["HTTPS","TLS","Performance"],"title":"HTTPS Handshake Optimization: Cutting Latency from 200ms to 50ms","uri":"/posts/211226-https/"},{"categories":["Networking"],"content":"5.1 SSL Labs Test Head to https://www.ssllabs.com/ssltest/ for a detailed score. Key metrics to check: Protocol Support: TLS 1.3 ✓ OCSP Stapling: Yes ✓ Certificate Chain: 2 certificates ✓ ","date":"2021-12-26","objectID":"/posts/211226-https/:5:1","tags":["HTTPS","TLS","Performance"],"title":"HTTPS Handshake Optimization: Cutting Latency from 200ms to 50ms","uri":"/posts/211226-https/"},{"categories":["Networking"],"content":"5.2 Chrome DevTools Timing panel: DNS Lookup: 20ms Initial connection: 50ms ← Significantly reduced SSL: 30ms ← TLS handshake TTFB: 80ms ","date":"2021-12-26","objectID":"/posts/211226-https/:5:2","tags":["HTTPS","TLS","Performance"],"title":"HTTPS Handshake Optimization: Cutting Latency from 200ms to 50ms","uri":"/posts/211226-https/"},{"categories":["Networking"],"content":"5.3 Prometheus Monitoring # Monitor TLS handshake time - job_name: 'nginx' metrics_path: '/metrics' static_configs: - targets: ['localhost:9113'] # Alert rule - alert: HighTLSHandshakeTime expr: nginx_http_ssl_handshake_time_seconds_bucket{le=\"0.1\"} / nginx_http_ssl_handshake_time_seconds_count \u003c 0.9 for: 5m labels: severity: warning annotations: summary: \"Over 10% of TLS handshakes taking \u003e 100ms\" ","date":"2021-12-26","objectID":"/posts/211226-https/:5:3","tags":["HTTPS","TLS","Performance"],"title":"HTTPS Handshake Optimization: Cutting Latency from 200ms to 50ms","uri":"/posts/211226-https/"},{"categories":["Networking"],"content":"6. Complete Config Example server { listen 443 ssl http2; server_name terra-nas.com; # Certificates ssl_certificate /etc/letsencrypt/live/terra-nas.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/terra-nas.com/privkey.pem; # Protocol and cipher suites ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305; # OCSP Stapling ssl_stapling on; ssl_stapling_verify on; ssl_trusted_certificate /etc/letsencrypt/live/terra-nas.com/chain.pem; resolver 8.8.8.8 8.8.4.4 valid=300s; # Session resumption ssl_session_cache shared:SSL:10m; ssl_session_timeout 1d; ssl_session_tickets on; # 0-RTT (use carefully) ssl_early_data on; # Security headers add_header Strict-Transport-Security \"max-age=31536000\" always; # ... } ","date":"2021-12-26","objectID":"/posts/211226-https/:6:0","tags":["HTTPS","TLS","Performance"],"title":"HTTPS Handshake Optimization: Cutting Latency from 200ms to 50ms","uri":"/posts/211226-https/"},{"categories":["Networking"],"content":"7. Summary Technique How It Works Impact TLS 1.3 1-RTT handshake -40ms OCSP Stapling Server pre-fetches cert status -60ms Session Resumption Reuse previous handshake -40ms Trim cert chain Less data to transfer -10ms ECDSA certificate Faster signing algorithm -5ms Key takeaway: HTTPS optimization isn’t just about choosing algorithms — it’s about reducing round trips (RTT). These optimizations make an even bigger difference on high-latency networks (like cross-continent connections). ","date":"2021-12-26","objectID":"/posts/211226-https/:7:0","tags":["HTTPS","TLS","Performance"],"title":"HTTPS Handshake Optimization: Cutting Latency from 200ms to 50ms","uri":"/posts/211226-https/"},{"categories":["Go"],"content":"A deep dive into Go's singleflight package implementation, understanding how request deduplication prevents cache penetration and database avalanche.","date":"2021-12-21","objectID":"/posts/211221-singleflight/","tags":["Concurrency","Caching","Source Code Analysis"],"title":"Go Singleflight Deep Dive: Preventing Cache Stampede with One Line of Code","uri":"/posts/211221-singleflight/"},{"categories":["Go"],"content":"In high-concurrency scenarios, cache stampede can crush your database. Singleflight solves this with an elegantly simple design. Code reference: https://github.com/coredns/coredns/blob/v1.9.1/plugin/pkg/singleflight/singleflight.go ","date":"2021-12-21","objectID":"/posts/211221-singleflight/:0:0","tags":["Concurrency","Caching","Source Code Analysis"],"title":"Go Singleflight Deep Dive: Preventing Cache Stampede with One Line of Code","uri":"/posts/211221-singleflight/"},{"categories":["Go"],"content":"What is Singleflight? A common pattern in projects: Set an expiration time for Redis cache. When cache misses, fetch from database. Cache stampede means: A flood of requests bypass cache and hit the database directly. As shown in the diagram, when cache expires, before step 2 completes, thousands of requests have already reached step 1, putting massive pressure on the server. How do we solve this? Singleflight provides an elegant approach. Cache Stampede Scenario The idea: Only allow one request to penetrate, all others queue at step 3 waiting. Here’s the singleflight source code: package singleflight import \"sync\" type call struct { wg sync.WaitGroup val interface{} err error } type Group struct { mu sync.Mutex m map[uint64]*call // Lazy init } func (g *Group) Do(key uint64, fn func() (interface{}, error)) (interface{}, error) { +----------------------------------+ | g.mu.Lock() | | if g.m == nil { | | g.m = make(map[uint64]*call) | | } | // When first request arrives | if c, ok := g.m[key]; ok { | // Can't get value from map (cache miss) | g.mu.Unlock() +------\u003e // Creates new map entry (pointer) | c.wg.Wait() | // Other requests get this pointer and block | return c.val, c.err | // Until first request gets value and shares result | } | | c := new(call) | | c.wg.Add(1) | | g.m[key] = c | | g.mu.Unlock() | +----------------------------------+ +----------------------+ | c.val, c.err = fn() | // Only first request executes, gets result once | c.wg.Done() +-----\u003e // Result stored in map +----------------------+ // Other requests reuse this result +------------------+ | g.mu.Lock() | // Only first request reaches here | delete(g.m, key) +----\u003e // After other requests finish reading | g.mu.Unlock() | // Delete map entry (already in Redis, don't need it) +------------------+ return c.val, c.err } ","date":"2021-12-21","objectID":"/posts/211221-singleflight/:1:0","tags":["Concurrency","Caching","Source Code Analysis"],"title":"Go Singleflight Deep Dive: Preventing Cache Stampede with One Line of Code","uri":"/posts/211221-singleflight/"},{"categories":["Go"],"content":"Simulating Cache Stampede Approach: Write a server using httprouter, use two maps to simulate Redis and MySQL. Initially only MySQL has data (so when 5k goroutines hit at once, it’s a cache stampede) Client generates 5k concurrent requests, observe results ","date":"2021-12-21","objectID":"/posts/211221-singleflight/:2:0","tags":["Concurrency","Caching","Source Code Analysis"],"title":"Go Singleflight Deep Dive: Preventing Cache Stampede with One Line of Code","uri":"/posts/211221-singleflight/"},{"categories":["Go"],"content":"Server See code for: Interface definitions Simulated data storage To more realistically reproduce cache stampede, sleep 2 seconds before reading from MySQL, ensuring lots of requests hit MySQL when singleflight isn’t used, for better comparison. // server/main.go package main import ( \"errors\" \"fmt\" \"log\" \"net/http\" \"sync\" \"time\" \"github.com/julienschmidt/httprouter\" ) var group *Group var mux sync.RWMutex var rwMux sync.RWMutex var redisDataBase map[string]string var mysqlDataBase map[string]string var countRedisHit int var countMysqlHit int func GetFromRedis(key string) (string, error) { if data, ok := redisDataBase[key]; ok { mux.Lock() countRedisHit++ mux.Unlock() return data, nil } if data, err := GetFromMySql(key); err == nil { return data, nil } else { return \"\", err } } func GetFromMySql(key string) (string, error) { time.Sleep(time.Second * 1) if data, ok := mysqlDataBase[key]; ok { // write to redis rwMux.Lock() redisDataBase[key] = \"data stored in redis\" rwMux.Unlock() // Simulates 2s TTL // Every value stored in redis expires after 2s go func(key string) { time.Sleep(time.Second * 2) rwMux.Lock() delete(redisDataBase, key) rwMux.Unlock() }(key) mux.Lock() countMysqlHit++ mux.Unlock() return data, nil } else { return \"\", errors.New(\"data not found!\") } } // Normal version func GetUserInfo(w http.ResponseWriter, req *http.Request, ps httprouter.Params) { queryValues := req.URL.Query() if res, err := GetFromRedis(queryValues.Get(\"name\")); err != nil { log.Fatal(\"err:\", err) } else { fmt.Fprintf(w, res) } } // Singleflight version func GetUserInfo1(w http.ResponseWriter, req *http.Request, ps httprouter.Params) { queryValues := req.URL.Query() function := func() (interface{}, error) { if res, err := GetFromRedis(queryValues.Get(\"name\")); err == nil { return res, nil } else { return \"\", err } } // Ah, wasn't sharing the same group, that's why it wasn't working res, err := group.Do(uint64(1), function) if err != nil { log.Fatal(\"err from singleflight:\", err) } fmt.Fprintf(w, res.(string)) } func ShowHitCount(w http.ResponseWriter, req *http.Request, _ httprouter.Params) { fmt.Fprintf(w, \"redis:%d\\nmysql:%d\\n\", countRedisHit, countMysqlHit) } func init() { redisDataBase, mysqlDataBase = map[string]string{}, map[string]string{} mysqlDataBase[\"zqw\"] = \"data stored in mysql\" // Initially no data in redis group = \u0026Group{} } func hello(w http.ResponseWriter, req *http.Request, ps httprouter.Params) { queryValues := req.URL.Query() fmt.Fprintf(w, \"hello, %s!\\n\", queryValues.Get(\"name\")) } func main() { router := httprouter.New() router.GET(\"/\", hello) router.GET(\"/userinfo\", GetUserInfo) router.GET(\"/userinfo1\", GetUserInfo1) router.GET(\"/count\", ShowHitCount) log.Fatal(http.ListenAndServe(\":9090\", router)) } ","date":"2021-12-21","objectID":"/posts/211221-singleflight/:2:1","tags":["Concurrency","Caching","Source Code Analysis"],"title":"Go Singleflight Deep Dive: Preventing Cache Stampede with One Line of Code","uri":"/posts/211221-singleflight/"},{"categories":["Go"],"content":"Client Simple approach (logic in code): concurrent requests, print results, time it package main import ( \"fmt\" \"io\" \"log\" \"net/http\" \"sync\" \"time\" ) func curl(str string) string { resp, err := client.Get(str) if err != nil { log.Println(\"error:\", err) } res, err := io.ReadAll(resp.Body) defer resp.Body.Close() return string(res) } var client http.Client func init() { client = http.Client{} } func main() { timeStampA := time.Now() defer client.CloseIdleConnections() var wg sync.WaitGroup for i := 0; i \u003c 5000; i++ { wg.Add(1) go func() { defer wg.Done() // Alternate between these two //curl(\"http://localhost:9090/userinfo?name=zqw\") curl(\"http://localhost:9090/userinfo1?name=zqw\") }() } wg.Wait() res := curl(\"http://localhost:9090/count\") fmt.Println(res) timeStampB := time.Now() fmt.Println(\"Total time: \", timeStampB.Sub(timeStampA).Seconds()) } ","date":"2021-12-21","objectID":"/posts/211221-singleflight/:2:2","tags":["Concurrency","Caching","Source Code Analysis"],"title":"Go Singleflight Deep Dive: Preventing Cache Stampede with One Line of Code","uri":"/posts/211221-singleflight/"},{"categories":["Go"],"content":"Results Without singleflight: redis:0 mysql:5000 Total time: 1.5597763709999999 With singleflight: redis:0 mysql:1 # Other 4999 requests all shared first request's result Total time: 1.216015732 Results are reproducible. If you see errors, your OS might have too few open file descriptors. Try lowering concurrency. I’ve already set ulimit -n 8192. Tried 10k concurrent — results were inconsistent. Tried 100k concurrent — constant panics (IO errors at client, or server crashed). ","date":"2021-12-21","objectID":"/posts/211221-singleflight/:2:3","tags":["Concurrency","Caching","Source Code Analysis"],"title":"Go Singleflight Deep Dive: Preventing Cache Stampede with One Line of Code","uri":"/posts/211221-singleflight/"},{"categories":["Go"],"content":"Conclusion Singleflight is compact yet powerful. The concept is worth studying. Essentially it shifts pressure from disk access to memory access. Issues I ran into while coding: Server crashed frequently (panic on memory access) when writing to Redis (actually writing to map) after MySQL read — fixed by adding locks Wrote lock instead of unlock, causing deadlock on server Singleflight variable wasn’t global, was being redefined in each handler function, so it wasn’t working — found the bug after code review Concurrency above 50k leads to all kinds of weird errors (runtime io panic), total time 50x+ longer, effectively 10x+ performance degradation — gave up ","date":"2021-12-21","objectID":"/posts/211221-singleflight/:3:0","tags":["Concurrency","Caching","Source Code Analysis"],"title":"Go Singleflight Deep Dive: Preventing Cache Stampede with One Line of Code","uri":"/posts/211221-singleflight/"},{"categories":["Linux"],"content":"Using FastDFS module compilation as an example to deep-dive into Nginx's modular architecture, build system, configure script internals, and production compilation optimization strategies.","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Linux"],"content":"Most people install Nginx via package managers, but compiling from source truly reveals its module mechanism. This post uses FastDFS module integration as an example to analyze Nginx’s build system and modular architecture. ","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/:0:0","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Linux"],"content":"1. Why Compile from Source? ","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/:1:0","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Linux"],"content":"1.1 Package Manager Limitations # Package manager install apt install nginx # Check compile parameters nginx -V # Fixed module list, can't modify Problems: Can’t add third-party modules (FastDFS, OpenResty) Can’t remove unneeded modules (reduce size) Can’t tune compilation optimization flags ","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/:1:1","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Linux"],"content":"1.2 Scenarios Requiring Source Compilation Scenario Requirement Distributed file storage Integrate fastdfs-nginx-module WAF protection Integrate ModSecurity High-performance cache Integrate ngx_cache_purge Lua scripting Integrate OpenResty Minimal footprint Remove unneeded modules ","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/:1:2","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Linux"],"content":"2. Nginx Modular Architecture ","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/:2:0","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Linux"],"content":"2.1 Module Categories ┌─────────────────────────────────────────────────────────┐ │ Nginx Core │ ├─────────────────────────────────────────────────────────┤ │ Core Modules │ │ ├── ngx_core_module Process management, config parse │ │ ├── ngx_errlog_module Error logging │ │ └── ngx_events_module Event-driven │ ├─────────────────────────────────────────────────────────┤ │ HTTP Modules │ │ ├── ngx_http_core_module HTTP core │ │ ├── ngx_http_proxy_module Reverse proxy │ │ ├── ngx_http_fastcgi_module FastCGI support │ │ ├── ngx_http_gzip_module Gzip compression │ │ └── ngx_http_ssl_module HTTPS support │ ├─────────────────────────────────────────────────────────┤ │ Third-party Modules │ │ ├── fastdfs-nginx-module FastDFS integration │ │ ├── ngx_cache_purge Cache purging │ │ └── lua-nginx-module Lua scripting │ └─────────────────────────────────────────────────────────┘ ","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/:2:1","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Linux"],"content":"2.2 Module Loading Mechanism Nginx modules can be statically compiled or dynamically loaded: # Static compilation: linked into binary at compile time ./configure --add-module=/path/to/module # Dynamic loading (1.9.11+): loaded at runtime ./configure --add-dynamic-module=/path/to/module # Load dynamic module in nginx.conf load_module modules/ngx_http_image_filter_module.so; ","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/:2:2","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Linux"],"content":"3. Build Environment Preparation ","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/:3:0","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Linux"],"content":"3.1 Install Dependencies # Ubuntu/Debian sudo apt update sudo apt install -y \\ build-essential \\ libpcre3-dev \\ zlib1g-dev \\ libssl-dev \\ libgd-dev \\ libgeoip-dev # CentOS/RHEL sudo yum groupinstall -y \"Development Tools\" sudo yum install -y \\ pcre-devel \\ zlib-devel \\ openssl-devel \\ gd-devel \\ GeoIP-devel ","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/:3:1","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Linux"],"content":"3.2 Dependency Explanation Dependency Purpose Corresponding Module PCRE Regular expressions rewrite module zlib Gzip compression gzip module OpenSSL HTTPS ssl module libgd Image processing image_filter module GeoIP IP geolocation geoip module ","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/:3:2","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Linux"],"content":"4. Configure Script Deep Dive ","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/:4:0","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Linux"],"content":"4.1 Common Parameters ./configure \\ # Install paths --prefix=/usr/local/nginx \\ --sbin-path=/usr/local/nginx/sbin/nginx \\ --conf-path=/etc/nginx/nginx.conf \\ --pid-path=/var/run/nginx.pid \\ --error-log-path=/var/log/nginx/error.log \\ --http-log-path=/var/log/nginx/access.log \\ # User and group --user=nginx \\ --group=nginx \\ # Enable modules --with-http_ssl_module \\ --with-http_v2_module \\ --with-http_realip_module \\ --with-http_gzip_static_module \\ --with-http_stub_status_module \\ # Disable unneeded modules (reduce size) --without-http_autoindex_module \\ --without-http_ssi_module \\ # Third-party modules --add-module=/path/to/fastdfs-nginx-module/src \\ # Compilation optimization --with-cc-opt='-O2 -fstack-protector-strong' \\ --with-ld-opt='-Wl,-z,relro -Wl,-z,now' ","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/:4:1","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Linux"],"content":"4.2 What Does Configure Do? # View configure output ls objs/ # autoconf.err Makefile ngx_auto_config.h ngx_modules.c src/ Key files: File Purpose objs/Makefile Build rules objs/ngx_auto_config.h Auto-detected system config objs/ngx_modules.c Module registration list ","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/:4:2","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Linux"],"content":"4.3 Module Registration Internals // objs/ngx_modules.c (auto-generated) ngx_module_t *ngx_modules[] = { \u0026ngx_core_module, \u0026ngx_errlog_module, \u0026ngx_conf_module, \u0026ngx_events_module, \u0026ngx_http_module, \u0026ngx_http_core_module, // ... more modules \u0026ngx_http_fastdfs_module, // Third-party module NULL }; This is why adding modules requires recompilation — the module list is determined at compile time. ","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/:4:3","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Linux"],"content":"5. FastDFS Module Integration ","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/:5:0","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Linux"],"content":"5.1 Preparation # Download source wget https://nginx.org/download/nginx-1.24.0.tar.gz git clone https://github.com/happyfish100/fastdfs-nginx-module.git # Extract tar -xzf nginx-1.24.0.tar.gz cd nginx-1.24.0 ","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/:5:1","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Linux"],"content":"5.2 Configure Build ./configure \\ --prefix=/usr/local/nginx \\ --with-http_ssl_module \\ --with-http_v2_module \\ --with-http_realip_module \\ --with-http_stub_status_module \\ --add-module=../fastdfs-nginx-module/src ","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/:5:2","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Linux"],"content":"5.3 Compile and Install # Compile (use all CPU cores) make -j$(nproc) # Install sudo make install # Verify /usr/local/nginx/sbin/nginx -V # Output should include --add-module=.../fastdfs-nginx-module ","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/:5:3","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Linux"],"content":"5.4 Configure FastDFS Module # /etc/nginx/nginx.conf http { server { listen 80; # FastDFS file access location /group1/M00 { ngx_fastdfs_module; } } } ","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/:5:4","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Linux"],"content":"6. Compilation Optimization Strategies ","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/:6:0","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Linux"],"content":"6.1 Performance Optimization Flags ./configure \\ # Compiler optimization --with-cc-opt='-O3 -march=native -mtune=native' \\ # Linker optimization --with-ld-opt='-Wl,-O1 -Wl,--as-needed' Optimization level explanation: Flag Effect Use Case -O0 No optimization Debugging -O2 Balanced optimization Production (recommended) -O3 Aggressive optimization Maximum performance -march=native Target current CPU Non-container environments ","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/:6:1","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Linux"],"content":"6.2 Security Hardening ./configure \\ # Stack protection --with-cc-opt='-fstack-protector-strong -D_FORTIFY_SOURCE=2' \\ # RELRO (lazy binding protection) --with-ld-opt='-Wl,-z,relro -Wl,-z,now' \\ # PIE (address space randomization) --with-cc-opt='-fPIE' \\ --with-ld-opt='-pie' ","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/:6:2","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Linux"],"content":"6.3 Slim Binary # Remove unneeded modules ./configure \\ --without-http_autoindex_module \\ --without-http_browser_module \\ --without-http_empty_gif_module \\ --without-http_geo_module \\ --without-http_map_module \\ --without-http_split_clients_module \\ --without-http_userid_module # Strip symbol table after compile strip /usr/local/nginx/sbin/nginx # Compare size ls -lh /usr/local/nginx/sbin/nginx # From ~5MB to ~1.5MB ","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/:6:3","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Linux"],"content":"7. Production Deployment ","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/:7:0","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Linux"],"content":"7.1 Systemd Service File # /etc/systemd/system/nginx.service [Unit] Description=Nginx HTTP Server After=network.target [Service] Type=forking PIDFile=/var/run/nginx.pid ExecStartPre=/usr/local/nginx/sbin/nginx -t ExecStart=/usr/local/nginx/sbin/nginx ExecReload=/bin/kill -s HUP $MAINPID ExecStop=/bin/kill -s QUIT $MAINPID PrivateTmp=true [Install] WantedBy=multi-user.target ","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/:7:1","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Linux"],"content":"7.2 Zero-Downtime Upgrade # 1. Compile new version (don't install) ./configure ... \u0026\u0026 make # 2. Backup old binary cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.old # 3. Replace binary cp objs/nginx /usr/local/nginx/sbin/nginx # 4. Send USR2 to old process, start new process kill -USR2 $(cat /var/run/nginx.pid) # 5. Gracefully shut down old workers kill -WINCH $(cat /var/run/nginx.pid.oldbin) # 6. After confirming success, stop old master kill -QUIT $(cat /var/run/nginx.pid.oldbin) ","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/:7:2","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Linux"],"content":"8. Troubleshooting ","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/:8:0","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Linux"],"content":"8.1 Compilation Error Debugging # View detailed errors cat objs/autoconf.err # Common issues # 1. Missing PCRE ./configure: error: the HTTP rewrite module requires the PCRE library # Solution: apt install libpcre3-dev # 2. Missing OpenSSL ./configure: error: SSL modules require the OpenSSL library # Solution: apt install libssl-dev # 3. Third-party module path wrong ./configure: error: no /path/to/module/config was found # Solution: Check if config file exists in module directory ","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/:8:1","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Linux"],"content":"8.2 Runtime Debugging # Test configuration nginx -t # View loaded modules nginx -V 2\u003e\u00261 | tr ' ' '\\n' | grep module # Start in debug mode nginx -g \"daemon off; error_log /dev/stderr debug;\" ","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/:8:2","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Linux"],"content":"9. Summary Topic Takeaway Module mechanism Static compile vs dynamic load Configure Auto-detect + generate Makefile Compile optimization -O2 + security hardening flags Zero-downtime upgrade USR2 + WINCH signals Core insight: Understanding Nginx’s build system not only enables flexible customization, but also deepens understanding of C project build processes — applicable to other system software like Redis and Linux Kernel. ","date":"2021-12-06","objectID":"/posts/211207-compile-nginx-fdfs/:9:0","tags":["Nginx","Compilation","Modular Architecture"],"title":"Compiling Nginx from Source: Understanding Module Architecture and Custom Extensions","uri":"/posts/211207-compile-nginx-fdfs/"},{"categories":["Distributed Systems"],"content":"One night at 2 AM, Kafka message lag alerts fired. Investigation revealed a Zookeeper cluster split-brain — two nodes both thought they were the Leader. This post documents the full debugging and recovery process. ","date":"2021-10-14","objectID":"/posts/211014-kafka-cluester/:0:0","tags":["Zookeeper","Debugging","High Availability"],"title":"Postmortem: Debugging a Zookeeper Split-Brain in Production","uri":"/posts/211014-kafka-cluester/"},{"categories":["Distributed Systems"],"content":"1. Incident Symptoms ","date":"2021-10-14","objectID":"/posts/211014-kafka-cluester/:1:0","tags":["Zookeeper","Debugging","High Availability"],"title":"Postmortem: Debugging a Zookeeper Split-Brain in Production","uri":"/posts/211014-kafka-cluester/"},{"categories":["Distributed Systems"],"content":"1.1 Alert Messages [CRITICAL] Kafka consumer lag \u003e 100000 [WARN] Kafka broker 1 lost connection to zk [WARN] Kafka broker 2 lost connection to zk ","date":"2021-10-14","objectID":"/posts/211014-kafka-cluester/:1:1","tags":["Zookeeper","Debugging","High Availability"],"title":"Postmortem: Debugging a Zookeeper Split-Brain in Production","uri":"/posts/211014-kafka-cluester/"},{"categories":["Distributed Systems"],"content":"1.2 Initial Check # Check Kafka status kafka-consumer-groups.sh --bootstrap-server localhost:9092 --describe --all-groups # Result: Many consumers showing \"UNKNOWN\" Kafka relies on Zookeeper for metadata management and Leader election. If ZK is down, Kafka is dead. ","date":"2021-10-14","objectID":"/posts/211014-kafka-cluester/:1:2","tags":["Zookeeper","Debugging","High Availability"],"title":"Postmortem: Debugging a Zookeeper Split-Brain in Production","uri":"/posts/211014-kafka-cluester/"},{"categories":["Distributed Systems"],"content":"2. Zookeeper State Investigation ","date":"2021-10-14","objectID":"/posts/211014-kafka-cluester/:2:0","tags":["Zookeeper","Debugging","High Availability"],"title":"Postmortem: Debugging a Zookeeper Split-Brain in Production","uri":"/posts/211014-kafka-cluester/"},{"categories":["Distributed Systems"],"content":"2.1 Cluster Topology ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ │ ZK-1 │ │ ZK-2 │ │ ZK-3 │ │ 192.168.1.1 │ │ 192.168.1.2 │ │ 192.168.1.3 │ └─────────────┘ └─────────────┘ └─────────────┘ ↑ ↑ ↑ └─────── Kafka Brokers connect ─────────┘ ","date":"2021-10-14","objectID":"/posts/211014-kafka-cluester/:2:1","tags":["Zookeeper","Debugging","High Availability"],"title":"Postmortem: Debugging a Zookeeper Split-Brain in Production","uri":"/posts/211014-kafka-cluester/"},{"categories":["Distributed Systems"],"content":"2.2 Check Each Node’s Status # Normally should have 1 leader + 2 followers for host in 192.168.1.{1,2,3}; do echo \"=== $host ===\" echo stat | nc $host 2181 | grep Mode done Abnormal output: === 192.168.1.1 === Mode: leader === 192.168.1.2 === Mode: leader ← Two Leaders! Split-brain! === 192.168.1.3 === Error: Connection refused ","date":"2021-10-14","objectID":"/posts/211014-kafka-cluester/:2:2","tags":["Zookeeper","Debugging","High Availability"],"title":"Postmortem: Debugging a Zookeeper Split-Brain in Production","uri":"/posts/211014-kafka-cluester/"},{"categories":["Distributed Systems"],"content":"2.3 Check Logs # ZK-1 logs tail -100 /var/log/zookeeper/zookeeper.log # Found WARN [QuorumPeer] - Cannot open channel to 3 at election address /192.168.1.3:3888 ERROR [QuorumPeer] - Unexpected exception causing shutdown while sock still open # ZK-3 logs # Process was dead systemctl status zookeeper # Active: failed (Result: exit-code) ","date":"2021-10-14","objectID":"/posts/211014-kafka-cluester/:2:3","tags":["Zookeeper","Debugging","High Availability"],"title":"Postmortem: Debugging a Zookeeper Split-Brain in Production","uri":"/posts/211014-kafka-cluester/"},{"categories":["Distributed Systems"],"content":"3. Root Cause Analysis ","date":"2021-10-14","objectID":"/posts/211014-kafka-cluester/:3:0","tags":["Zookeeper","Debugging","High Availability"],"title":"Postmortem: Debugging a Zookeeper Split-Brain in Production","uri":"/posts/211014-kafka-cluester/"},{"categories":["Distributed Systems"],"content":"3.1 What is Split-Brain? Normal Zookeeper elections require Quorum (majority) agreement: 3-node cluster: Quorum = 2 5-node cluster: Quorum = 3 Split-brain scenario: Before network partition: ZK-1(Leader) ←→ ZK-2(Follower) ←→ ZK-3(Follower) After network partition: Partition A: ZK-1, ZK-2 Partition B: ZK-3 ZK-1: \"I have 2 votes, I'm Leader\" ZK-3: \"Can't hear Leader heartbeat, starting election\" → Only 1 vote, can't elect new Leader Correct behavior: ZK-3 goes read-only But this incident was different… ","date":"2021-10-14","objectID":"/posts/211014-kafka-cluester/:3:1","tags":["Zookeeper","Debugging","High Availability"],"title":"Postmortem: Debugging a Zookeeper Split-Brain in Production","uri":"/posts/211014-kafka-cluester/"},{"categories":["Distributed Systems"],"content":"3.2 Root Cause Check why ZK-3 died: # System logs journalctl -u zookeeper --since \"2021-10-14 02:00\" # Found Out of memory: Kill process 12345 (java) score 800 Truth: ZK-3 was killed by OOM Killer, not network partition! Timeline reconstruction: 02:15 ZK-3 killed by OOM 02:16 ZK-1 and ZK-2 notice ZK-3 is gone 02:17 ZK-1 remains Leader (2 nodes still have Quorum) 02:30 Network hiccup between ZK-1 and ZK-2 02:31 ZK-2 loses ZK-1's heartbeat, assumes Leader is dead 02:32 ZK-2 starts election... but no Quorum! 02:33 ZK-1 reconnects, but ZK-2 already thinks it's Leader Key issue: ZK-2 didn’t properly step down after network recovered. ","date":"2021-10-14","objectID":"/posts/211014-kafka-cluester/:3:2","tags":["Zookeeper","Debugging","High Availability"],"title":"Postmortem: Debugging a Zookeeper Split-Brain in Production","uri":"/posts/211014-kafka-cluester/"},{"categories":["Distributed Systems"],"content":"4. Emergency Recovery ","date":"2021-10-14","objectID":"/posts/211014-kafka-cluester/:4:0","tags":["Zookeeper","Debugging","High Availability"],"title":"Postmortem: Debugging a Zookeeper Split-Brain in Production","uri":"/posts/211014-kafka-cluester/"},{"categories":["Distributed Systems"],"content":"4.1 Restore Healthy Cluster # 1. Stop all ZK nodes for host in 192.168.1.{1,2,3}; do ssh $host \"systemctl stop zookeeper\" done # 2. Check data consistency for host in 192.168.1.{1,2}; do ssh $host \"cat /var/lib/zookeeper/version-2/currentEpoch\" done # Ensure epochs are consistent # 3. Restore ZK-3 ssh 192.168.1.3 \"systemctl start zookeeper\" # Wait 10s for startup # 4. Start other nodes sequentially ssh 192.168.1.1 \"systemctl start zookeeper\" sleep 5 ssh 192.168.1.2 \"systemctl start zookeeper\" ","date":"2021-10-14","objectID":"/posts/211014-kafka-cluester/:4:1","tags":["Zookeeper","Debugging","High Availability"],"title":"Postmortem: Debugging a Zookeeper Split-Brain in Production","uri":"/posts/211014-kafka-cluester/"},{"categories":["Distributed Systems"],"content":"4.2 Verify Recovery # Check cluster status for host in 192.168.1.{1,2,3}; do echo \"=== $host ===\" echo stat | nc $host 2181 | grep Mode done # Expected output === 192.168.1.1 === Mode: follower === 192.168.1.2 === Mode: follower === 192.168.1.3 === Mode: leader # Check Kafka recovery kafka-consumer-groups.sh --bootstrap-server localhost:9092 --list ","date":"2021-10-14","objectID":"/posts/211014-kafka-cluester/:4:2","tags":["Zookeeper","Debugging","High Availability"],"title":"Postmortem: Debugging a Zookeeper Split-Brain in Production","uri":"/posts/211014-kafka-cluester/"},{"categories":["Distributed Systems"],"content":"5. Prevention Measures ","date":"2021-10-14","objectID":"/posts/211014-kafka-cluester/:5:0","tags":["Zookeeper","Debugging","High Availability"],"title":"Postmortem: Debugging a Zookeeper Split-Brain in Production","uri":"/posts/211014-kafka-cluester/"},{"categories":["Distributed Systems"],"content":"5.1 Memory Configuration # /etc/zookeeper/java.env export JVMFLAGS=\"-Xmx2g -Xms2g\" # System level # /etc/sysctl.conf vm.swappiness=1 # Avoid swap usage # Set OOM priority echo -1000 \u003e /proc/$(pgrep -f zookeeper)/oom_score_adj ","date":"2021-10-14","objectID":"/posts/211014-kafka-cluester/:5:1","tags":["Zookeeper","Debugging","High Availability"],"title":"Postmortem: Debugging a Zookeeper Split-Brain in Production","uri":"/posts/211014-kafka-cluester/"},{"categories":["Distributed Systems"],"content":"5.2 Monitoring Alerts # Prometheus alert rules groups: - name: zookeeper rules: - alert: ZookeeperDown expr: up{job=\"zookeeper\"} == 0 for: 1m labels: severity: critical - alert: ZookeeperNoLeader expr: zk_server_leader == 0 for: 1m labels: severity: critical - alert: ZookeeperTooManyLeaders expr: sum(zk_server_leader) \u003e 1 for: 30s labels: severity: critical annotations: summary: \"Split-brain! Multiple Leaders detected\" ","date":"2021-10-14","objectID":"/posts/211014-kafka-cluester/:5:2","tags":["Zookeeper","Debugging","High Availability"],"title":"Postmortem: Debugging a Zookeeper Split-Brain in Production","uri":"/posts/211014-kafka-cluester/"},{"categories":["Distributed Systems"],"content":"5.3 Cluster Configuration Tuning # zoo.cfg # Heartbeat interval (ms) tickTime=2000 # Ticks for Leader to wait for Follower connections initLimit=10 # Ticks for Leader-Follower sync syncLimit=5 # 4-letter word whitelist (for monitoring) 4lw.commands.whitelist=stat,ruok,mntr,envi # Enable Leader auto-reelection (prevent zombie Leader) leaderServes=no ","date":"2021-10-14","objectID":"/posts/211014-kafka-cluester/:5:3","tags":["Zookeeper","Debugging","High Availability"],"title":"Postmortem: Debugging a Zookeeper Split-Brain in Production","uri":"/posts/211014-kafka-cluester/"},{"categories":["Distributed Systems"],"content":"5.4 Network Configuration # Ensure ZK node-to-node latency \u003c 100ms ping -c 10 192.168.1.2 # rtt min/avg/max = 0.5/0.8/1.2 ms ✓ # Check firewall for port in 2181 2888 3888; do echo \"Port $port:\" nc -zv 192.168.1.2 $port done ","date":"2021-10-14","objectID":"/posts/211014-kafka-cluester/:5:4","tags":["Zookeeper","Debugging","High Availability"],"title":"Postmortem: Debugging a Zookeeper Split-Brain in Production","uri":"/posts/211014-kafka-cluester/"},{"categories":["Distributed Systems"],"content":"6. Understanding ZAB Protocol ","date":"2021-10-14","objectID":"/posts/211014-kafka-cluester/:6:0","tags":["Zookeeper","Debugging","High Availability"],"title":"Postmortem: Debugging a Zookeeper Split-Brain in Production","uri":"/posts/211014-kafka-cluester/"},{"categories":["Distributed Systems"],"content":"6.1 Election Process Phase 1: Leader Election - Each node votes for itself - Collect votes from other nodes - Compare (epoch, zxid, myid) - Switch to optimal candidate - Node with Quorum votes wins Phase 2: Discovery - Leader collects latest zxid from Followers - Determines data to sync Phase 3: Synchronization - Leader syncs data to Followers - All Followers reach consensus Phase 4: Broadcast - Leader starts accepting client requests - Uses 2PC protocol to broadcast updates ","date":"2021-10-14","objectID":"/posts/211014-kafka-cluester/:6:1","tags":["Zookeeper","Debugging","High Availability"],"title":"Postmortem: Debugging a Zookeeper Split-Brain in Production","uri":"/posts/211014-kafka-cluester/"},{"categories":["Distributed Systems"],"content":"6.2 Why Quorum? 3 nodes, Quorum = 2 5 nodes, Quorum = 3 7 nodes, Quorum = 4 Formula: Quorum = N/2 + 1 Any two Quorums must intersect → Guarantees data consistency → Prevents split-brain ","date":"2021-10-14","objectID":"/posts/211014-kafka-cluester/:6:2","tags":["Zookeeper","Debugging","High Availability"],"title":"Postmortem: Debugging a Zookeeper Split-Brain in Production","uri":"/posts/211014-kafka-cluester/"},{"categories":["Distributed Systems"],"content":"6.3 Best Practices: Node Count Nodes Fault Tolerance Recommended Use 1 0 Dev only 3 1 Small production 5 2 Medium/large production 7 3 Extreme HA requirements ","date":"2021-10-14","objectID":"/posts/211014-kafka-cluester/:6:3","tags":["Zookeeper","Debugging","High Availability"],"title":"Postmortem: Debugging a Zookeeper Split-Brain in Production","uri":"/posts/211014-kafka-cluester/"},{"categories":["Distributed Systems"],"content":"7. Debugging Toolkit ","date":"2021-10-14","objectID":"/posts/211014-kafka-cluester/:7:0","tags":["Zookeeper","Debugging","High Availability"],"title":"Postmortem: Debugging a Zookeeper Split-Brain in Production","uri":"/posts/211014-kafka-cluester/"},{"categories":["Distributed Systems"],"content":"7.1 Four-Letter Commands # Check node status echo stat | nc localhost 2181 # Health check echo ruok | nc localhost 2181 # Returns \"imok\" # Metrics echo mntr | nc localhost 2181 # zk_version 3.6.3 # zk_server_state leader # zk_num_alive_connections 10 # zk_outstanding_requests 0 # Environment info echo envi | nc localhost 2181 ","date":"2021-10-14","objectID":"/posts/211014-kafka-cluester/:7:1","tags":["Zookeeper","Debugging","High Availability"],"title":"Postmortem: Debugging a Zookeeper Split-Brain in Production","uri":"/posts/211014-kafka-cluester/"},{"categories":["Distributed Systems"],"content":"7.2 zkCli Operations # Connect to cluster zkCli.sh -server 192.168.1.1:2181,192.168.1.2:2181,192.168.1.3:2181 # View metadata ls /brokers/ids get /controller # Check ACL getAcl /kafka ","date":"2021-10-14","objectID":"/posts/211014-kafka-cluester/:7:2","tags":["Zookeeper","Debugging","High Availability"],"title":"Postmortem: Debugging a Zookeeper Split-Brain in Production","uri":"/posts/211014-kafka-cluester/"},{"categories":["Distributed Systems"],"content":"7.3 Log Analysis Tips # Find election-related logs grep -E \"LOOKING|LEADING|FOLLOWING|Election\" zookeeper.log # Find connection issues grep \"Cannot open channel\" zookeeper.log # Find session timeouts grep \"Session expired\" zookeeper.log ","date":"2021-10-14","objectID":"/posts/211014-kafka-cluester/:7:3","tags":["Zookeeper","Debugging","High Availability"],"title":"Postmortem: Debugging a Zookeeper Split-Brain in Production","uri":"/posts/211014-kafka-cluester/"},{"categories":["Distributed Systems"],"content":"8. Summary Step Action Detect Monitoring alerts + Kafka anomalies Locate Four-letter commands to check each node’s Mode Analyze ZK logs + system logs to find root cause Fix Ordered restart, prioritize Quorum recovery Prevent Monitoring + memory tuning + network checks Biggest lessons: Zookeeper is memory-sensitive — configure JVM heap properly Set OOM protection so ZK process isn’t easily killed Monitor Leader count — alert if more than 1 Practice failure recovery procedures regularly ","date":"2021-10-14","objectID":"/posts/211014-kafka-cluester/:8:0","tags":["Zookeeper","Debugging","High Availability"],"title":"Postmortem: Debugging a Zookeeper Split-Brain in Production","uri":"/posts/211014-kafka-cluester/"},{"categories":["Distributed Systems"],"content":"Real-world problems encountered in Go microservices: deprecated go get, gRPC version conflicts, service discovery failures, Context leaks, graceful shutdown. Each pitfall comes with a fix.","date":"2021-09-22","objectID":"/posts/210922-go-feature/","tags":["Go","gRPC","Debugging"],"title":"Go Microservices War Stories: 5 Lessons from Dependency Management to Service Discovery","uri":"/posts/210922-go-feature/"},{"categories":["Distributed Systems"],"content":"Microservices isn’t just about splitting up a monolith. This post documents 5 real pitfalls I hit in Go microservices projects, and how to avoid them. ","date":"2021-09-22","objectID":"/posts/210922-go-feature/:0:0","tags":["Go","gRPC","Debugging"],"title":"Go Microservices War Stories: 5 Lessons from Dependency Management to Service Discovery","uri":"/posts/210922-go-feature/"},{"categories":["Distributed Systems"],"content":"1. Deprecated go get Breaking CI Builds ","date":"2021-09-22","objectID":"/posts/210922-go-feature/:1:0","tags":["Go","gRPC","Debugging"],"title":"Go Microservices War Stories: 5 Lessons from Dependency Management to Service Discovery","uri":"/posts/210922-go-feature/"},{"categories":["Distributed Systems"],"content":"1.1 The Problem One day, CI suddenly failed: go get -u github.com/golang/protobuf/protoc-gen-go # go: go get -u github.com/golang/protobuf/protoc-gen-go: # installing executables with 'go get' in module mode is deprecated. ","date":"2021-09-22","objectID":"/posts/210922-go-feature/:1:1","tags":["Go","gRPC","Debugging"],"title":"Go Microservices War Stories: 5 Lessons from Dependency Management to Service Discovery","uri":"/posts/210922-go-feature/"},{"categories":["Distributed Systems"],"content":"1.2 Root Cause Starting with Go 1.17, go get behavior changed: Version go get Behavior 1.16 and earlier Downloads dependencies + installs binaries 1.17+ Only manages go.mod dependencies Future versions -d flag becomes default ","date":"2021-09-22","objectID":"/posts/210922-go-feature/:1:2","tags":["Go","gRPC","Debugging"],"title":"Go Microservices War Stories: 5 Lessons from Dependency Management to Service Discovery","uri":"/posts/210922-go-feature/"},{"categories":["Distributed Systems"],"content":"1.3 Solution # Old way (deprecated) go get -u github.com/golang/protobuf/protoc-gen-go # New way: use go install + version go install google.golang.org/protobuf/cmd/protoc-gen-go@latest go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest ","date":"2021-09-22","objectID":"/posts/210922-go-feature/:1:3","tags":["Go","gRPC","Debugging"],"title":"Go Microservices War Stories: 5 Lessons from Dependency Management to Service Discovery","uri":"/posts/210922-go-feature/"},{"categories":["Distributed Systems"],"content":"1.4 CI Script Fix # .github/workflows/build.yml jobs: build: steps: - name: Install protoc plugins run: | go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.31.0 go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.3.0 Lesson: Pin tool versions, don’t use @latest. ","date":"2021-09-22","objectID":"/posts/210922-go-feature/:1:4","tags":["Go","gRPC","Debugging"],"title":"Go Microservices War Stories: 5 Lessons from Dependency Management to Service Discovery","uri":"/posts/210922-go-feature/"},{"categories":["Distributed Systems"],"content":"2. gRPC Version Conflict Causing Runtime Panic ","date":"2021-09-22","objectID":"/posts/210922-go-feature/:2:0","tags":["Go","gRPC","Debugging"],"title":"Go Microservices War Stories: 5 Lessons from Dependency Management to Service Discovery","uri":"/posts/210922-go-feature/"},{"categories":["Distributed Systems"],"content":"2.1 The Problem Service crashes on startup: panic: proto: extension number 1001 is already registered ","date":"2021-09-22","objectID":"/posts/210922-go-feature/:2:1","tags":["Go","gRPC","Debugging"],"title":"Go Microservices War Stories: 5 Lessons from Dependency Management to Service Discovery","uri":"/posts/210922-go-feature/"},{"categories":["Distributed Systems"],"content":"2.2 Root Cause Project depends on two protobuf library versions: go mod graph | grep protobuf # github.com/golang/protobuf@v1.4.3 # google.golang.org/protobuf@v1.31.0 github.com/golang/protobuf is the old library, google.golang.org/protobuf is the new one. Both register the same extension numbers internally, causing conflicts. ","date":"2021-09-22","objectID":"/posts/210922-go-feature/:2:2","tags":["Go","gRPC","Debugging"],"title":"Go Microservices War Stories: 5 Lessons from Dependency Management to Service Discovery","uri":"/posts/210922-go-feature/"},{"categories":["Distributed Systems"],"content":"2.3 Solutions Option 1: Force unified version // go.mod require ( google.golang.org/protobuf v1.31.0 ) replace github.com/golang/protobuf =\u003e google.golang.org/protobuf v1.31.0 Option 2: Upgrade all dependencies go get -u ./... go mod tidy Option 3: Use go mod why to trace # Find who's pulling in the old version go mod why github.com/golang/protobuf Lesson: Run go mod tidy regularly to keep your dependency graph clean. ","date":"2021-09-22","objectID":"/posts/210922-go-feature/:2:3","tags":["Go","gRPC","Debugging"],"title":"Go Microservices War Stories: 5 Lessons from Dependency Management to Service Discovery","uri":"/posts/210922-go-feature/"},{"categories":["Distributed Systems"],"content":"3. Service Discovery Failure: DNS Resolution Timeout ","date":"2021-09-22","objectID":"/posts/210922-go-feature/:3:0","tags":["Go","gRPC","Debugging"],"title":"Go Microservices War Stories: 5 Lessons from Dependency Management to Service Discovery","uri":"/posts/210922-go-feature/"},{"categories":["Distributed Systems"],"content":"3.1 The Problem Intermittent timeouts on service-to-service calls, logs show: context deadline exceeded (Client.Timeout exceeded while awaiting headers) ","date":"2021-09-22","objectID":"/posts/210922-go-feature/:3:1","tags":["Go","gRPC","Debugging"],"title":"Go Microservices War Stories: 5 Lessons from Dependency Management to Service Discovery","uri":"/posts/210922-go-feature/"},{"categories":["Distributed Systems"],"content":"3.2 Debugging // Problem code conn, err := grpc.Dial( \"user-service:8080\", // Using K8s Service name grpc.WithInsecure(), ) tcpdump showed DNS resolution occasionally taking 5+ seconds. ","date":"2021-09-22","objectID":"/posts/210922-go-feature/:3:2","tags":["Go","gRPC","Debugging"],"title":"Go Microservices War Stories: 5 Lessons from Dependency Management to Service Discovery","uri":"/posts/210922-go-feature/"},{"categories":["Distributed Systems"],"content":"3.3 Root Cause K8s cluster’s CoreDNS was configured with upstream external DNS. When internal resolution fails, it tries external resolution, causing delays. ","date":"2021-09-22","objectID":"/posts/210922-go-feature/:3:3","tags":["Go","gRPC","Debugging"],"title":"Go Microservices War Stories: 5 Lessons from Dependency Management to Service Discovery","uri":"/posts/210922-go-feature/"},{"categories":["Distributed Systems"],"content":"3.4 Solutions Option 1: Use FQDN // Specify full domain name, avoid search domain probing conn, err := grpc.Dial( \"user-service.default.svc.cluster.local:8080\", grpc.WithInsecure(), ) Option 2: K8s DNS config optimization # In Pod spec dnsConfig: options: - name: ndots value: \"2\" # Reduce DNS search attempts Option 3: Client-side DNS caching import \"google.golang.org/grpc/resolver\" func init() { // Use passthrough resolver, bypass gRPC's DNS resolution resolver.SetDefaultScheme(\"passthrough\") } Lesson: Microservice network issues often aren’t in the code layer. ","date":"2021-09-22","objectID":"/posts/210922-go-feature/:3:4","tags":["Go","gRPC","Debugging"],"title":"Go Microservices War Stories: 5 Lessons from Dependency Management to Service Discovery","uri":"/posts/210922-go-feature/"},{"categories":["Distributed Systems"],"content":"4. Context Leak Causing Goroutine Explosion ","date":"2021-09-22","objectID":"/posts/210922-go-feature/:4:0","tags":["Go","gRPC","Debugging"],"title":"Go Microservices War Stories: 5 Lessons from Dependency Management to Service Discovery","uri":"/posts/210922-go-feature/"},{"categories":["Distributed Systems"],"content":"4.1 The Problem After running for a while, memory keeps growing. pprof shows tons of goroutines waiting: go tool pprof http://localhost:6060/debug/pprof/goroutine # 50000 goroutines, 90% in select {} ","date":"2021-09-22","objectID":"/posts/210922-go-feature/:4:1","tags":["Go","gRPC","Debugging"],"title":"Go Microservices War Stories: 5 Lessons from Dependency Management to Service Discovery","uri":"/posts/210922-go-feature/"},{"categories":["Distributed Systems"],"content":"4.2 Problem Code func HandleRequest(ctx context.Context, req *Request) { // Created new context, but didn't cancel newCtx, _ := context.WithTimeout(ctx, 10*time.Second) go func() { // This goroutine waits on newCtx.Done() // But if request returns early, newCtx never gets cancelled \u003c-newCtx.Done() cleanup() }() // ... handle request } ","date":"2021-09-22","objectID":"/posts/210922-go-feature/:4:2","tags":["Go","gRPC","Debugging"],"title":"Go Microservices War Stories: 5 Lessons from Dependency Management to Service Discovery","uri":"/posts/210922-go-feature/"},{"categories":["Distributed Systems"],"content":"4.3 Correct Approach func HandleRequest(ctx context.Context, req *Request) { newCtx, cancel := context.WithTimeout(ctx, 10*time.Second) defer cancel() // Key: ensure context is cancelled done := make(chan struct{}) go func() { defer close(done) // Async work }() select { case \u003c-done: // Normal completion case \u003c-newCtx.Done(): // Timeout } } ","date":"2021-09-22","objectID":"/posts/210922-go-feature/:4:3","tags":["Go","gRPC","Debugging"],"title":"Go Microservices War Stories: 5 Lessons from Dependency Management to Service Discovery","uri":"/posts/210922-go-feature/"},{"categories":["Distributed Systems"],"content":"4.4 Detection Tool // Use goleak to detect goroutine leaks import \"go.uber.org/goleak\" func TestMain(m *testing.M) { goleak.VerifyTestMain(m) } Lesson: The cancel function returned by context.WithCancel/Timeout must be called. ","date":"2021-09-22","objectID":"/posts/210922-go-feature/:4:4","tags":["Go","gRPC","Debugging"],"title":"Go Microservices War Stories: 5 Lessons from Dependency Management to Service Discovery","uri":"/posts/210922-go-feature/"},{"categories":["Distributed Systems"],"content":"5. Graceful Shutdown: Killing Requests Mid-Flight ","date":"2021-09-22","objectID":"/posts/210922-go-feature/:5:0","tags":["Go","gRPC","Debugging"],"title":"Go Microservices War Stories: 5 Lessons from Dependency Management to Service Discovery","uri":"/posts/210922-go-feature/"},{"categories":["Distributed Systems"],"content":"5.1 The Problem During service restarts, users report failed requests. Logs show: http: Server closed ","date":"2021-09-22","objectID":"/posts/210922-go-feature/:5:1","tags":["Go","gRPC","Debugging"],"title":"Go Microservices War Stories: 5 Lessons from Dependency Management to Service Discovery","uri":"/posts/210922-go-feature/"},{"categories":["Distributed Systems"],"content":"5.2 Problem Code func main() { srv := \u0026http.Server{Addr: \":8080\"} go srv.ListenAndServe() quit := make(chan os.Signal, 1) signal.Notify(quit, syscall.SIGTERM) \u003c-quit srv.Close() // Closes immediately, doesn't wait for requests! } ","date":"2021-09-22","objectID":"/posts/210922-go-feature/:5:2","tags":["Go","gRPC","Debugging"],"title":"Go Microservices War Stories: 5 Lessons from Dependency Management to Service Discovery","uri":"/posts/210922-go-feature/"},{"categories":["Distributed Systems"],"content":"5.3 Correct Approach func main() { srv := \u0026http.Server{Addr: \":8080\"} go func() { if err := srv.ListenAndServe(); err != http.ErrServerClosed { log.Fatalf(\"listen: %s\\n\", err) } }() quit := make(chan os.Signal, 1) signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM) \u003c-quit log.Println(\"Shutting down server...\") // Graceful shutdown: wait up to 30 seconds for existing requests ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second) defer cancel() if err := srv.Shutdown(ctx); err != nil { log.Fatal(\"Server forced to shutdown:\", err) } log.Println(\"Server exited\") } ","date":"2021-09-22","objectID":"/posts/210922-go-feature/:5:3","tags":["Go","gRPC","Debugging"],"title":"Go Microservices War Stories: 5 Lessons from Dependency Management to Service Discovery","uri":"/posts/210922-go-feature/"},{"categories":["Distributed Systems"],"content":"5.4 K8s PreStop Hook # Pod spec lifecycle: preStop: exec: command: [\"/bin/sh\", \"-c\", \"sleep 5\"] # Give K8s time to update Endpoints, prevent traffic from coming in ","date":"2021-09-22","objectID":"/posts/210922-go-feature/:5:4","tags":["Go","gRPC","Debugging"],"title":"Go Microservices War Stories: 5 Lessons from Dependency Management to Service Discovery","uri":"/posts/210922-go-feature/"},{"categories":["Distributed Systems"],"content":"5.5 gRPC Graceful Shutdown func main() { srv := grpc.NewServer() // ... register services quit := make(chan os.Signal, 1) signal.Notify(quit, syscall.SIGTERM) \u003c-quit // GracefulStop waits for all RPCs to complete srv.GracefulStop() } Lesson: Graceful shutdown isn’t just code — you also need K8s preStop and terminationGracePeriodSeconds. ","date":"2021-09-22","objectID":"/posts/210922-go-feature/:5:5","tags":["Go","gRPC","Debugging"],"title":"Go Microservices War Stories: 5 Lessons from Dependency Management to Service Discovery","uri":"/posts/210922-go-feature/"},{"categories":["Distributed Systems"],"content":"6. Summary Problem Root Cause Solution go get deprecated Go 1.17 behavior change Use go install @version protobuf panic Old/new library conflict Unify versions + go mod tidy DNS timeout K8s DNS config Use FQDN + adjust ndots Goroutine leak Context not cancelled defer cancel() Request interrupted No graceful shutdown srv.Shutdown() + preStop Core lesson: Microservice complexity isn’t in the split — it’s in the edge cases that distributed environments bring. Every problem requires thinking across code, config, and infrastructure layers. ","date":"2021-09-22","objectID":"/posts/210922-go-feature/:6:0","tags":["Go","gRPC","Debugging"],"title":"Go Microservices War Stories: 5 Lessons from Dependency Management to Service Discovery","uri":"/posts/210922-go-feature/"},{"categories":["Linux"],"content":"Using FUSE framework and Go to implement a simple userspace filesystem from scratch. Deep dive into core concepts like inode, block, and file operations.","date":"2021-08-10","objectID":"/posts/210810-fuse-filesystem/","tags":["Filesystem","FUSE","Go"],"title":"Building a Mini Filesystem: Custom FS with FUSE + Go","uri":"/posts/210810-fuse-filesystem/"},{"categories":["Linux"],"content":"The best way to learn filesystems is to write one yourself. This post uses FUSE + Go to implement an in-memory filesystem with basic read/write operations, deep-diving into core concepts like inode and block. ","date":"2021-08-10","objectID":"/posts/210810-fuse-filesystem/:0:0","tags":["Filesystem","FUSE","Go"],"title":"Building a Mini Filesystem: Custom FS with FUSE + Go","uri":"/posts/210810-fuse-filesystem/"},{"categories":["Linux"],"content":"1. Why Build Your Own Filesystem? ","date":"2021-08-10","objectID":"/posts/210810-fuse-filesystem/:1:0","tags":["Filesystem","FUSE","Go"],"title":"Building a Mini Filesystem: Custom FS with FUSE + Go","uri":"/posts/210810-fuse-filesystem/"},{"categories":["Linux"],"content":"1.1 Learning Goals Understanding filesystems is foundational for: Container storage volumes Distributed storage (Ceph, GlusterFS) Object storage (S3 FUSE) Database storage engines ","date":"2021-08-10","objectID":"/posts/210810-fuse-filesystem/:1:1","tags":["Filesystem","FUSE","Go"],"title":"Building a Mini Filesystem: Custom FS with FUSE + Go","uri":"/posts/210810-fuse-filesystem/"},{"categories":["Linux"],"content":"1.2 FUSE Advantages FUSE (Filesystem in Userspace) allows implementing filesystems in userspace: No kernel modules needed Easy development and debugging Can use high-level languages (Go, Python, Rust) ","date":"2021-08-10","objectID":"/posts/210810-fuse-filesystem/:1:2","tags":["Filesystem","FUSE","Go"],"title":"Building a Mini Filesystem: Custom FS with FUSE + Go","uri":"/posts/210810-fuse-filesystem/"},{"categories":["Linux"],"content":"2. Filesystem Core Concepts ","date":"2021-08-10","objectID":"/posts/210810-fuse-filesystem/:2:0","tags":["Filesystem","FUSE","Go"],"title":"Building a Mini Filesystem: Custom FS with FUSE + Go","uri":"/posts/210810-fuse-filesystem/"},{"categories":["Linux"],"content":"2.1 Inode Inode (Index Node) is the core data structure storing file metadata: type Inode struct { ID uint64 // inode number Type InodeType // file or directory Size uint64 // file size Mode os.FileMode // permissions Uid, Gid uint32 // owner Atime time.Time // access time Mtime time.Time // modification time Ctime time.Time // creation time Links uint32 // hard link count Blocks []uint64 // data block indices } Key points: Filename is NOT in inode! Filenames are in directory entries One inode can have multiple filenames (hard links) ls -i shows inode numbers ","date":"2021-08-10","objectID":"/posts/210810-fuse-filesystem/:2:1","tags":["Filesystem","FUSE","Go"],"title":"Building a Mini Filesystem: Custom FS with FUSE + Go","uri":"/posts/210810-fuse-filesystem/"},{"categories":["Linux"],"content":"2.2 Block Block is the basic storage unit, typically 4KB: const BlockSize = 4096 type Block struct { Data [BlockSize]byte } File contents are split into multiple Blocks. ","date":"2021-08-10","objectID":"/posts/210810-fuse-filesystem/:2:2","tags":["Filesystem","FUSE","Go"],"title":"Building a Mini Filesystem: Custom FS with FUSE + Go","uri":"/posts/210810-fuse-filesystem/"},{"categories":["Linux"],"content":"2.3 Directory A directory is essentially a file whose contents are a list of “directory entries”: type DirEntry struct { Name string // filename Inode uint64 // points to inode } // Directory content is []DirEntry ","date":"2021-08-10","objectID":"/posts/210810-fuse-filesystem/:2:3","tags":["Filesystem","FUSE","Go"],"title":"Building a Mini Filesystem: Custom FS with FUSE + Go","uri":"/posts/210810-fuse-filesystem/"},{"categories":["Linux"],"content":"2.4 Relationship Diagram ┌─────────────────────────────────────────┐ │ Superblock │ │ (FS metadata: block count, inode count) │ └─────────────────────────────────────────┘ │ ┌────────────────────────┼────────────────────────┐ ▼ ▼ ▼ ┌─────────┐ ┌─────────┐ ┌─────────┐ │ Inode 1 │ │ Inode 2 │ │ Inode 3 │ │ (root) │ │ (file a)│ │ (file b)│ │ Type=Dir│ │ Type=Reg│ │ Type=Reg│ └────┬────┘ └────┬────┘ └────┬────┘ │ │ │ ▼ ▼ ▼ ┌─────────┐ ┌─────────┐ ┌─────────┐ │ Block 0 │ │ Block 1 │ │ Block 2 │ │ DirEntry│ │ content │ │ content │ │ a→Inode2│ │ \"hello\"│ │ \"world\" │ │ b→Inode3│ └─────────┘ └─────────┘ └─────────┘ ","date":"2021-08-10","objectID":"/posts/210810-fuse-filesystem/:2:4","tags":["Filesystem","FUSE","Go"],"title":"Building a Mini Filesystem: Custom FS with FUSE + Go","uri":"/posts/210810-fuse-filesystem/"},{"categories":["Linux"],"content":"3. FUSE Architecture ","date":"2021-08-10","objectID":"/posts/210810-fuse-filesystem/:3:0","tags":["Filesystem","FUSE","Go"],"title":"Building a Mini Filesystem: Custom FS with FUSE + Go","uri":"/posts/210810-fuse-filesystem/"},{"categories":["Linux"],"content":"3.1 How It Works ┌──────────────────────────────────────────────────────────┐ │ User Space │ │ ┌──────────┐ ┌──────────┐ ┌──────────────────┐ │ │ │ Your App │───▶│ glibc │───▶│ FUSE userspace │ │ │ │ (cat, ls)│ │ open/read│ │ (your code) │ │ │ └──────────┘ └────┬─────┘ └────────▲─────────┘ │ │ │ │ │ └───────────────────────│────────────────────│──────────────┘ │ VFS │ /dev/fuse ▼ │ ┌───────────────────────────────────────────────────────────┐ │ Kernel │ │ ┌──────────────────────────────────────────────────┐ │ │ │ FUSE kernel module │ │ │ │ (forwards VFS calls to userspace, returns result)│ │ │ └──────────────────────────────────────────────────┘ │ └───────────────────────────────────────────────────────────┘ ","date":"2021-08-10","objectID":"/posts/210810-fuse-filesystem/:3:1","tags":["Filesystem","FUSE","Go"],"title":"Building a Mini Filesystem: Custom FS with FUSE + Go","uri":"/posts/210810-fuse-filesystem/"},{"categories":["Linux"],"content":"3.2 Operations to Implement Operation System Call Description Lookup open(dir) Find file in directory Getattr stat Get file attributes Readdir readdir List directory contents Read read Read file content Write write Write file content Create creat/open Create new file Mkdir mkdir Create directory Unlink unlink Delete file Rmdir rmdir Delete directory ","date":"2021-08-10","objectID":"/posts/210810-fuse-filesystem/:3:2","tags":["Filesystem","FUSE","Go"],"title":"Building a Mini Filesystem: Custom FS with FUSE + Go","uri":"/posts/210810-fuse-filesystem/"},{"categories":["Linux"],"content":"4. Go Implementation ","date":"2021-08-10","objectID":"/posts/210810-fuse-filesystem/:4:0","tags":["Filesystem","FUSE","Go"],"title":"Building a Mini Filesystem: Custom FS with FUSE + Go","uri":"/posts/210810-fuse-filesystem/"},{"categories":["Linux"],"content":"4.1 Dependencies Using bazil.org/fuse library: go get bazil.org/fuse ","date":"2021-08-10","objectID":"/posts/210810-fuse-filesystem/:4:1","tags":["Filesystem","FUSE","Go"],"title":"Building a Mini Filesystem: Custom FS with FUSE + Go","uri":"/posts/210810-fuse-filesystem/"},{"categories":["Linux"],"content":"4.2 Data Structures package main import ( \"os\" \"sync\" \"time\" ) type InodeType int const ( TypeFile InodeType = iota TypeDir ) type MemFS struct { mu sync.RWMutex inodes map[uint64]*Inode data map[uint64][]byte // inode -\u003e file content nextIno uint64 } type Inode struct { ID uint64 Type InodeType Mode os.FileMode Size uint64 Atime time.Time Mtime time.Time Children map[string]uint64 // dir entries: name -\u003e inode } func NewMemFS() *MemFS { fs := \u0026MemFS{ inodes: make(map[uint64]*Inode), data: make(map[uint64][]byte), nextIno: 2, } // Create root directory (inode 1) fs.inodes[1] = \u0026Inode{ ID: 1, Type: TypeDir, Mode: os.ModeDir | 0755, Atime: time.Now(), Mtime: time.Now(), Children: make(map[string]uint64), } return fs } ","date":"2021-08-10","objectID":"/posts/210810-fuse-filesystem/:4:2","tags":["Filesystem","FUSE","Go"],"title":"Building a Mini Filesystem: Custom FS with FUSE + Go","uri":"/posts/210810-fuse-filesystem/"},{"categories":["Linux"],"content":"4.3 Implementing FUSE Interface import ( \"bazil.org/fuse\" \"bazil.org/fuse/fs\" \"context\" ) // Dir implements directory node type Dir struct { fs *MemFS inode *Inode } func (d *Dir) Attr(ctx context.Context, attr *fuse.Attr) error { attr.Inode = d.inode.ID attr.Mode = d.inode.Mode attr.Atime = d.inode.Atime attr.Mtime = d.inode.Mtime return nil } func (d *Dir) Lookup(ctx context.Context, name string) (fs.Node, error) { d.fs.mu.RLock() defer d.fs.mu.RUnlock() childIno, ok := d.inode.Children[name] if !ok { return nil, fuse.ENOENT } child := d.fs.inodes[childIno] if child.Type == TypeDir { return \u0026Dir{fs: d.fs, inode: child}, nil } return \u0026File{fs: d.fs, inode: child}, nil } func (d *Dir) ReadDirAll(ctx context.Context) ([]fuse.Dirent, error) { d.fs.mu.RLock() defer d.fs.mu.RUnlock() var entries []fuse.Dirent for name, ino := range d.inode.Children { child := d.fs.inodes[ino] var t fuse.DirentType if child.Type == TypeDir { t = fuse.DT_Dir } else { t = fuse.DT_File } entries = append(entries, fuse.Dirent{ Inode: ino, Name: name, Type: t, }) } return entries, nil } func (d *Dir) Create(ctx context.Context, req *fuse.CreateRequest, resp *fuse.CreateResponse) (fs.Node, fs.Handle, error) { d.fs.mu.Lock() defer d.fs.mu.Unlock() ino := d.fs.nextIno d.fs.nextIno++ now := time.Now() inode := \u0026Inode{ ID: ino, Type: TypeFile, Mode: req.Mode, Atime: now, Mtime: now, } d.fs.inodes[ino] = inode d.fs.data[ino] = []byte{} d.inode.Children[req.Name] = ino file := \u0026File{fs: d.fs, inode: inode} return file, file, nil } func (d *Dir) Mkdir(ctx context.Context, req *fuse.MkdirRequest) (fs.Node, error) { d.fs.mu.Lock() defer d.fs.mu.Unlock() ino := d.fs.nextIno d.fs.nextIno++ now := time.Now() inode := \u0026Inode{ ID: ino, Type: TypeDir, Mode: req.Mode | os.ModeDir, Atime: now, Mtime: now, Children: make(map[string]uint64), } d.fs.inodes[ino] = inode d.inode.Children[req.Name] = ino return \u0026Dir{fs: d.fs, inode: inode}, nil } ","date":"2021-08-10","objectID":"/posts/210810-fuse-filesystem/:4:3","tags":["Filesystem","FUSE","Go"],"title":"Building a Mini Filesystem: Custom FS with FUSE + Go","uri":"/posts/210810-fuse-filesystem/"},{"categories":["Linux"],"content":"4.4 File Operations // File implements file node type File struct { fs *MemFS inode *Inode } func (f *File) Attr(ctx context.Context, attr *fuse.Attr) error { attr.Inode = f.inode.ID attr.Mode = f.inode.Mode attr.Size = f.inode.Size attr.Atime = f.inode.Atime attr.Mtime = f.inode.Mtime return nil } func (f *File) Read(ctx context.Context, req *fuse.ReadRequest, resp *fuse.ReadResponse) error { f.fs.mu.RLock() defer f.fs.mu.RUnlock() data := f.fs.data[f.inode.ID] if req.Offset \u003e= int64(len(data)) { return nil } end := req.Offset + int64(req.Size) if end \u003e int64(len(data)) { end = int64(len(data)) } resp.Data = data[req.Offset:end] return nil } func (f *File) Write(ctx context.Context, req *fuse.WriteRequest, resp *fuse.WriteResponse) error { f.fs.mu.Lock() defer f.fs.mu.Unlock() data := f.fs.data[f.inode.ID] // Extend file size newLen := int(req.Offset) + len(req.Data) if newLen \u003e len(data) { newData := make([]byte, newLen) copy(newData, data) data = newData } copy(data[req.Offset:], req.Data) f.fs.data[f.inode.ID] = data f.inode.Size = uint64(len(data)) f.inode.Mtime = time.Now() resp.Size = len(req.Data) return nil } ","date":"2021-08-10","objectID":"/posts/210810-fuse-filesystem/:4:4","tags":["Filesystem","FUSE","Go"],"title":"Building a Mini Filesystem: Custom FS with FUSE + Go","uri":"/posts/210810-fuse-filesystem/"},{"categories":["Linux"],"content":"4.5 Main Program func main() { mountpoint := \"/tmp/memfs\" os.MkdirAll(mountpoint, 0755) c, err := fuse.Mount(mountpoint, fuse.FSName(\"memfs\"), fuse.Subtype(\"memfs\")) if err != nil { log.Fatal(err) } defer c.Close() fmt.Printf(\"Mounted at %s\\n\", mountpoint) fmt.Println(\"Press Ctrl+C to exit\") memfs := NewMemFS() // Handle signals for graceful unmount go func() { sigChan := make(chan os.Signal, 1) signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM) \u003c-sigChan fuse.Unmount(mountpoint) }() err = fs.Serve(c, \u0026FS{memfs: memfs}) if err != nil { log.Fatal(err) } } type FS struct { memfs *MemFS } func (f *FS) Root() (fs.Node, error) { return \u0026Dir{fs: f.memfs, inode: f.memfs.inodes[1]}, nil } ","date":"2021-08-10","objectID":"/posts/210810-fuse-filesystem/:4:5","tags":["Filesystem","FUSE","Go"],"title":"Building a Mini Filesystem: Custom FS with FUSE + Go","uri":"/posts/210810-fuse-filesystem/"},{"categories":["Linux"],"content":"5. Test Run # Build and run go build -o memfs ./memfs \u0026 # Test file operations cd /tmp/memfs echo \"hello world\" \u003e test.txt cat test.txt mkdir subdir ls -la # Unmount fusermount -u /tmp/memfs ","date":"2021-08-10","objectID":"/posts/210810-fuse-filesystem/:5:0","tags":["Filesystem","FUSE","Go"],"title":"Building a Mini Filesystem: Custom FS with FUSE + Go","uri":"/posts/210810-fuse-filesystem/"},{"categories":["Linux"],"content":"6. Advanced Extensions ","date":"2021-08-10","objectID":"/posts/210810-fuse-filesystem/:6:0","tags":["Filesystem","FUSE","Go"],"title":"Building a Mini Filesystem: Custom FS with FUSE + Go","uri":"/posts/210810-fuse-filesystem/"},{"categories":["Linux"],"content":"6.1 Persist to Disk // Serialize inodes and data to disk func (fs *MemFS) SaveToDisk(path string) error { f, _ := os.Create(path) defer f.Close() return gob.NewEncoder(f).Encode(fs) } func LoadFromDisk(path string) (*MemFS, error) { f, _ := os.Open(path) defer f.Close() var fs MemFS err := gob.NewDecoder(f).Decode(\u0026fs) return \u0026fs, err } ","date":"2021-08-10","objectID":"/posts/210810-fuse-filesystem/:6:1","tags":["Filesystem","FUSE","Go"],"title":"Building a Mini Filesystem: Custom FS with FUSE + Go","uri":"/posts/210810-fuse-filesystem/"},{"categories":["Linux"],"content":"6.2 Network Filesystem // Forward read/write to remote server func (f *File) Read(ctx context.Context, req *fuse.ReadRequest, resp *fuse.ReadResponse) error { // Read from remote via gRPC data, err := f.client.ReadFile(ctx, \u0026pb.ReadRequest{ Inode: f.inode.ID, Offset: req.Offset, Size: int64(req.Size), }) resp.Data = data.Content return err } ","date":"2021-08-10","objectID":"/posts/210810-fuse-filesystem/:6:2","tags":["Filesystem","FUSE","Go"],"title":"Building a Mini Filesystem: Custom FS with FUSE + Go","uri":"/posts/210810-fuse-filesystem/"},{"categories":["Linux"],"content":"7. Summary Concept Implementation Inode Struct storing metadata Block byte slice storing data Directory map[name]inode FUSE Implement Attr/Read/Write interfaces Takeaways: Deep understanding of inode and directory entry relationship Learned VFS to FUSE call chain Foundation for understanding distributed storage Related Posts Linux Boot Process: Complete Guide from Power Button to Login ","date":"2021-08-10","objectID":"/posts/210810-fuse-filesystem/:7:0","tags":["Filesystem","FUSE","Go"],"title":"Building a Mini Filesystem: Custom FS with FUSE + Go","uri":"/posts/210810-fuse-filesystem/"},{"categories":["Performance"],"content":"Textbook LRU uses a doubly-linked list + HashMap. But why does Redis use “approximate LRU”? This post dives into Redis source code to analyze the engineering trade-offs behind different eviction strategies. ","date":"2021-07-03","objectID":"/posts/210703-lru-learning/:0:0","tags":["Redis","Caching","Source Code Analysis"],"title":"Redis Eviction Deep Dive: LRU vs LFU vs TTL Engineering Trade-offs","uri":"/posts/210703-lru-learning/"},{"categories":["Performance"],"content":"1. Redis Memory Eviction Strategies ","date":"2021-07-03","objectID":"/posts/210703-lru-learning/:1:0","tags":["Redis","Caching","Source Code Analysis"],"title":"Redis Eviction Deep Dive: LRU vs LFU vs TTL Engineering Trade-offs","uri":"/posts/210703-lru-learning/"},{"categories":["Performance"],"content":"1.1 Configuration Options # redis.conf maxmemory 1gb maxmemory-policy allkeys-lru Available policies: Policy Scope Algorithm noeviction - Reject writes allkeys-lru All keys Approximate LRU volatile-lru Keys with TTL Approximate LRU allkeys-lfu All keys Approximate LFU volatile-lfu Keys with TTL Approximate LFU allkeys-random All keys Random volatile-random Keys with TTL Random volatile-ttl Keys with TTL Evict by TTL ","date":"2021-07-03","objectID":"/posts/210703-lru-learning/:1:1","tags":["Redis","Caching","Source Code Analysis"],"title":"Redis Eviction Deep Dive: LRU vs LFU vs TTL Engineering Trade-offs","uri":"/posts/210703-lru-learning/"},{"categories":["Performance"],"content":"1.2 Why Not Use Exact LRU? Textbook LRU: type LRUCache struct { capacity int cache map[string]*Node head *Node // Most recently used tail *Node // Least recently used } // On every access, move node to head // On eviction, delete tail node The problems: Memory overhead: Each key needs 2 extra pointers (prev/next), 64-bit system = 16 bytes/key Concurrency overhead: Every read mutates the list, requiring locks CPU cache unfriendly: Linked list nodes aren’t contiguous in memory Redis can have millions or even billions of keys. These overheads are unacceptable. ","date":"2021-07-03","objectID":"/posts/210703-lru-learning/:1:2","tags":["Redis","Caching","Source Code Analysis"],"title":"Redis Eviction Deep Dive: LRU vs LFU vs TTL Engineering Trade-offs","uri":"/posts/210703-lru-learning/"},{"categories":["Performance"],"content":"2. Redis Approximate LRU Implementation ","date":"2021-07-03","objectID":"/posts/210703-lru-learning/:2:0","tags":["Redis","Caching","Source Code Analysis"],"title":"Redis Eviction Deep Dive: LRU vs LFU vs TTL Engineering Trade-offs","uri":"/posts/210703-lru-learning/"},{"categories":["Performance"],"content":"2.1 Core Idea Redis’s approach: No global linked list Each key stores last access timestamp (24 bits = 3 bytes) On eviction, randomly sample keys and evict the oldest ","date":"2021-07-03","objectID":"/posts/210703-lru-learning/:2:1","tags":["Redis","Caching","Source Code Analysis"],"title":"Redis Eviction Deep Dive: LRU vs LFU vs TTL Engineering Trade-offs","uri":"/posts/210703-lru-learning/"},{"categories":["Performance"],"content":"2.2 Source Code Analysis // src/evict.c int freeMemoryIfNeeded(void) { // Called when memory exceeds limit while (mem_used \u003e maxmemory) { // Sample N keys struct evictionPoolEntry pool[EVPOOL_SIZE]; for (int i = 0; i \u003c server.maxmemory_samples; i++) { // Randomly pick a key dictEntry *de = dictGetRandomKey(dict); // Get access time unsigned long idle = estimateObjectIdleTime(o); // Add to sorted pool evictionPoolPopulate(pool, de, idle); } // Evict the oldest in pool bestkey = pool[0].key; deleteKey(bestkey); } } ","date":"2021-07-03","objectID":"/posts/210703-lru-learning/:2:2","tags":["Redis","Caching","Source Code Analysis"],"title":"Redis Eviction Deep Dive: LRU vs LFU vs TTL Engineering Trade-offs","uri":"/posts/210703-lru-learning/"},{"categories":["Performance"],"content":"2.3 Timestamp Storage // src/object.c typedef struct redisObject { unsigned type:4; unsigned encoding:4; unsigned lru:LRU_BITS; // 24 bits int refcount; void *ptr; } robj; // Update access time void touchObject(robj *o) { o-\u003elru = LRU_CLOCK(); // Lower 24 bits of current time } // Estimate idle time unsigned long estimateObjectIdleTime(robj *o) { unsigned long lruclock = LRU_CLOCK(); if (lruclock \u003e= o-\u003elru) { return lruclock - o-\u003elru; } else { // Clock wraparound return (lruclock + (1 \u003c\u003c LRU_BITS)) - o-\u003elru; } } Precision: 24 bits representing seconds wraps around every ~194 days. Good enough. ","date":"2021-07-03","objectID":"/posts/210703-lru-learning/:2:3","tags":["Redis","Caching","Source Code Analysis"],"title":"Redis Eviction Deep Dive: LRU vs LFU vs TTL Engineering Trade-offs","uri":"/posts/210703-lru-learning/"},{"categories":["Performance"],"content":"2.4 Impact of Sample Size # Default: sample 5 keys maxmemory-samples 5 Samples Hit Rate CPU Overhead 1 ~80% Very low 5 ~93% Low 10 ~97% Medium Full scan 100% Unacceptable Engineering trade-off: Sampling 5-10 keys gets you close enough to exact LRU. ","date":"2021-07-03","objectID":"/posts/210703-lru-learning/:2:4","tags":["Redis","Caching","Source Code Analysis"],"title":"Redis Eviction Deep Dive: LRU vs LFU vs TTL Engineering Trade-offs","uri":"/posts/210703-lru-learning/"},{"categories":["Performance"],"content":"3. LFU: Frequency-Based Eviction ","date":"2021-07-03","objectID":"/posts/210703-lru-learning/:3:0","tags":["Redis","Caching","Source Code Analysis"],"title":"Redis Eviction Deep Dive: LRU vs LFU vs TTL Engineering Trade-offs","uri":"/posts/210703-lru-learning/"},{"categories":["Performance"],"content":"3.1 The Problem with LRU Assume cache capacity of 3: Access sequence: A A A A B B C D E LRU state: [A] [A] (accessed A 4 times) [B, A] [B, A] (accessed B 2 times) [C, B, A] [D, C, B] ← A gets evicted! [E, D, C] A was accessed 4 times but got evicted just because it wasn’t accessed “recently”. That’s not ideal for many use cases. ","date":"2021-07-03","objectID":"/posts/210703-lru-learning/:3:1","tags":["Redis","Caching","Source Code Analysis"],"title":"Redis Eviction Deep Dive: LRU vs LFU vs TTL Engineering Trade-offs","uri":"/posts/210703-lru-learning/"},{"categories":["Performance"],"content":"3.2 Redis LFU Implementation Redis 4.0 introduced LFU, reusing the same 24-bit lru field: +--------+--------+ | 16 bits | 8 bits | | timestamp | counter | +--------+--------+ Counter decay: // On each access unsigned long LFUDecrAndReturn(robj *o) { // Get last access time unsigned long ldt = o-\u003elru \u003e\u003e 8; unsigned long counter = o-\u003elru \u0026 255; // Calculate time elapsed (in minutes) unsigned long minutes = LFUTimeElapsed(ldt); // Decay every N minutes if (minutes \u003e 0) { unsigned long decay = minutes / lfu_decay_time; if (counter \u003e decay) { counter -= decay; } else { counter = 0; } } return counter; } Probabilistic counter increment: // Don't increment on every access, use probability unsigned long LFULogIncr(unsigned long counter) { if (counter == 255) return 255; // Max cap double r = (double)rand() / RAND_MAX; double p = 1.0 / ((counter - LFU_INIT_VAL) * lfu_log_factor + 1); if (r \u003c p) { counter++; } return counter; } Why probabilistic increment? Counter is only 8 bits, max 255 Hot keys might be accessed millions of times Probabilistic increment implements “logarithmic counting” — counter=10 roughly equals 1000 accesses ","date":"2021-07-03","objectID":"/posts/210703-lru-learning/:3:2","tags":["Redis","Caching","Source Code Analysis"],"title":"Redis Eviction Deep Dive: LRU vs LFU vs TTL Engineering Trade-offs","uri":"/posts/210703-lru-learning/"},{"categories":["Performance"],"content":"3.3 LFU Configuration # Decay time (minutes) lfu-decay-time 1 # Logarithm factor lfu-log-factor 10 ","date":"2021-07-03","objectID":"/posts/210703-lru-learning/:3:3","tags":["Redis","Caching","Source Code Analysis"],"title":"Redis Eviction Deep Dive: LRU vs LFU vs TTL Engineering Trade-offs","uri":"/posts/210703-lru-learning/"},{"categories":["Performance"],"content":"4. Benchmark Comparison ","date":"2021-07-03","objectID":"/posts/210703-lru-learning/:4:0","tags":["Redis","Caching","Source Code Analysis"],"title":"Redis Eviction Deep Dive: LRU vs LFU vs TTL Engineering Trade-offs","uri":"/posts/210703-lru-learning/"},{"categories":["Performance"],"content":"4.1 Test Method func benchmark(policy string) { client := redis.NewClient(\u0026redis.Options{...}) // Warmup: write 1 million keys for i := 0; i \u003c 1_000_000; i++ { client.Set(ctx, fmt.Sprintf(\"key:%d\", i), \"value\", 0) } // Simulate real access (Zipf distribution: few keys accessed frequently) zipf := rand.NewZipf(rand.NewSource(42), 1.1, 10, 1_000_000) hits := 0 for i := 0; i \u003c 1_000_000; i++ { key := fmt.Sprintf(\"key:%d\", zipf.Uint64()) if client.Get(ctx, key).Err() == nil { hits++ } } fmt.Printf(\"%s: hit rate = %.2f%%\\n\", policy, float64(hits)/10000) } ","date":"2021-07-03","objectID":"/posts/210703-lru-learning/:4:1","tags":["Redis","Caching","Source Code Analysis"],"title":"Redis Eviction Deep Dive: LRU vs LFU vs TTL Engineering Trade-offs","uri":"/posts/210703-lru-learning/"},{"categories":["Performance"],"content":"4.2 Results Policy Uniform Access Zipf Distribution Burst Hotspots allkeys-random 50% 52% 51% allkeys-lru 65% 78% 60% allkeys-lfu 62% 85% 82% Conclusions: Uniform access → LRU slightly better Hot data → LFU significantly better Burst hotspots → LFU protects existing hot keys ","date":"2021-07-03","objectID":"/posts/210703-lru-learning/:4:2","tags":["Redis","Caching","Source Code Analysis"],"title":"Redis Eviction Deep Dive: LRU vs LFU vs TTL Engineering Trade-offs","uri":"/posts/210703-lru-learning/"},{"categories":["Performance"],"content":"5. Source-Level Optimization Details ","date":"2021-07-03","objectID":"/posts/210703-lru-learning/:5:0","tags":["Redis","Caching","Source Code Analysis"],"title":"Redis Eviction Deep Dive: LRU vs LFU vs TTL Engineering Trade-offs","uri":"/posts/210703-lru-learning/"},{"categories":["Performance"],"content":"5.1 Lazy Deletion vs Periodic Deletion // Lazy deletion: check on access robj *lookupKeyRead(redisDb *db, robj *key) { expireIfNeeded(db, key); // Check expiration first return lookupKey(db, key); } // Periodic deletion: background timer task void activeExpireCycle(int type) { for (int j = 0; j \u003c dbs; j++) { // Sample 20 keys randomly each time // Delete expired ones // If \u003e25% expired, continue loop } } ","date":"2021-07-03","objectID":"/posts/210703-lru-learning/:5:1","tags":["Redis","Caching","Source Code Analysis"],"title":"Redis Eviction Deep Dive: LRU vs LFU vs TTL Engineering Trade-offs","uri":"/posts/210703-lru-learning/"},{"categories":["Performance"],"content":"5.2 Memory Reclaim Strategy // Don't free immediately, free asynchronously void freeObjAsync(robj *o) { size_t size = objectComputeSize(o); if (size \u003e LAZYFREE_THRESHOLD) { // Large object: queue for background deletion bioCreateLazyFreeJob(lazyfreeFreeObject, 1, o); } else { // Small object: delete immediately decrRefCount(o); } } ","date":"2021-07-03","objectID":"/posts/210703-lru-learning/:5:2","tags":["Redis","Caching","Source Code Analysis"],"title":"Redis Eviction Deep Dive: LRU vs LFU vs TTL Engineering Trade-offs","uri":"/posts/210703-lru-learning/"},{"categories":["Performance"],"content":"6. Best Practices ","date":"2021-07-03","objectID":"/posts/210703-lru-learning/:6:0","tags":["Redis","Caching","Source Code Analysis"],"title":"Redis Eviction Deep Dive: LRU vs LFU vs TTL Engineering Trade-offs","uri":"/posts/210703-lru-learning/"},{"categories":["Performance"],"content":"6.1 Choosing a Policy if access_pattern == \"uniform\": use \"allkeys-lru\" elif access_pattern == \"hot_data\": use \"allkeys-lfu\" elif data_has_explicit_ttl: use \"volatile-ttl\" else: use \"allkeys-lru\" # Safe default ","date":"2021-07-03","objectID":"/posts/210703-lru-learning/:6:1","tags":["Redis","Caching","Source Code Analysis"],"title":"Redis Eviction Deep Dive: LRU vs LFU vs TTL Engineering Trade-offs","uri":"/posts/210703-lru-learning/"},{"categories":["Performance"],"content":"6.2 Monitoring # Check eviction stats redis-cli info stats | grep evicted # evicted_keys:12345 # Check memory usage redis-cli info memory # used_memory:1073741824 # maxmemory:2147483648 ","date":"2021-07-03","objectID":"/posts/210703-lru-learning/:6:2","tags":["Redis","Caching","Source Code Analysis"],"title":"Redis Eviction Deep Dive: LRU vs LFU vs TTL Engineering Trade-offs","uri":"/posts/210703-lru-learning/"},{"categories":["Performance"],"content":"6.3 Preventing Mass Evictions # Leave 10-20% headroom when setting maxmemory maxmemory 1.8gb # If machine has 2gb # Alert monitoring if memory_usage \u003e 80%: alert() ","date":"2021-07-03","objectID":"/posts/210703-lru-learning/:6:3","tags":["Redis","Caching","Source Code Analysis"],"title":"Redis Eviction Deep Dive: LRU vs LFU vs TTL Engineering Trade-offs","uri":"/posts/210703-lru-learning/"},{"categories":["Performance"],"content":"7. Summary Concept Redis Implementation Rationale LRU Approximate LRU (sampling) Avoid linked list overhead Timestamp 24 bits storage Save memory LFU counter 8 bits + probabilistic increment Logarithmic compression Deletion Lazy + periodic Balance latency and memory Key takeaways: Production systems often trade exact algorithms for approximate ones to gain efficiency Sampling is good enough to approximate optimal results Memory optimization is everywhere (24 bits instead of 64 bits) LFU works better when you have clear hot-spot patterns ","date":"2021-07-03","objectID":"/posts/210703-lru-learning/:7:0","tags":["Redis","Caching","Source Code Analysis"],"title":"Redis Eviction Deep Dive: LRU vs LFU vs TTL Engineering Trade-offs","uri":"/posts/210703-lru-learning/"},{"categories":["Linux"],"content":"Deep dive into every stage of Linux boot: BIOS/UEFI, Bootloader (GRUB2), Kernel loading, initramfs to rootfs transition, Systemd initialization, and debugging tips for each stage.","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"To be a solid systems engineer, you need to deeply understand the Linux boot process. Only by knowing “what normal looks like” can you quickly troubleshoot when things go wrong. This post walks through every stage from power button to login screen. ","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/:0:0","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"1. Boot Process Overview ┌─────────────────────────────────────────────────────────────────────────┐ │ POWER ON │ └───────────────────────────────┬─────────────────────────────────────────┘ ▼ ┌─────────────────────────────────────────────────────────────────────────┐ │ 1. BIOS/UEFI │ │ - Hardware self-test (POST) │ │ - Load Bootloader │ └───────────────────────────────┬─────────────────────────────────────────┘ ▼ ┌─────────────────────────────────────────────────────────────────────────┐ │ 2. Bootloader (GRUB2) │ │ - Display boot menu │ │ - Load Kernel + initramfs into memory │ │ - Pass boot parameters │ └───────────────────────────────┬─────────────────────────────────────────┘ ▼ ┌─────────────────────────────────────────────────────────────────────────┐ │ 3. Kernel Init │ │ - Decompress itself │ │ - Initialize hardware/interrupts/memory │ │ - Mount initramfs as temporary root │ │ - Execute /init │ └───────────────────────────────┬─────────────────────────────────────────┘ ▼ ┌─────────────────────────────────────────────────────────────────────────┐ │ 4. initramfs │ │ - Load essential drivers (disk, filesystem) │ │ - Find real root partition │ │ - pivot_root to actual root filesystem │ └───────────────────────────────┬─────────────────────────────────────────┘ ▼ ┌─────────────────────────────────────────────────────────────────────────┐ │ 5. Systemd (PID 1) │ │ - Start system services in parallel │ │ - Mount other filesystems │ │ - Reach target (default.target) │ └───────────────────────────────┬─────────────────────────────────────────┘ ▼ ┌─────────────────────────────────────────────────────────────────────────┐ │ 6. Login │ │ - getty (TTY) or Display Manager (GUI) │ └─────────────────────────────────────────────────────────────────────────┘ ","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/:1:0","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"2. Stage 1: BIOS/UEFI ","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/:2:0","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"2.1 BIOS vs UEFI Feature BIOS (Legacy) UEFI Era 1981 2005+ Boot method MBR (Master Boot Record) GPT + EFI System Partition Max disk size 2TB 9.4ZB (effectively unlimited) Boot speed Slower Faster Secure Boot No Yes ","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/:2:1","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"2.2 What It Does POST (Power-On Self-Test) Check CPU, memory, graphics One short beep = OK, continuous beeps = hardware failure Read boot device order Configured in BIOS settings Try hard drive, USB, network boot in sequence Load Bootloader BIOS: Read first 512 bytes of MBR UEFI: Read .efi file from ESP partition ","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/:2:2","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"2.3 Troubleshooting Symptom: No response on boot or error messages # Check boot mode [ -d /sys/firmware/efi ] \u0026\u0026 echo \"UEFI\" || echo \"BIOS\" # UEFI boot entry management efibootmgr -v ","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/:2:3","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"3. Stage 2: GRUB2 ","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/:3:0","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"3.1 GRUB2’s Job Provide boot menu (multi-OS selection) Load Kernel image into memory Load initramfs into memory Pass boot parameters to Kernel ","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/:3:1","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"3.2 Key Files /boot/grub/grub.cfg # Main config (auto-generated, don't edit directly) /etc/default/grub # User config /etc/grub.d/ # Config scripts /boot/vmlinuz-* # Kernel image /boot/initrd.img-* or initramfs-* # initramfs ","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/:3:2","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"3.3 grub.cfg Example menuentry 'Ubuntu' --class ubuntu { set root='hd0,gpt2' linux /vmlinuz-5.15.0-generic root=UUID=xxxxx ro quiet splash initrd /initrd.img-5.15.0-generic } Breakdown: set root: Partition containing Kernel linux: Kernel path + boot parameters root=UUID=xxx: Tells Kernel where real root partition is initrd: initramfs path ","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/:3:3","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"3.4 Modify and Update # Edit default parameters sudo vim /etc/default/grub # Regenerate grub.cfg sudo update-grub # Debian/Ubuntu sudo grub2-mkconfig -o /boot/grub2/grub.cfg # RHEL/CentOS ","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/:3:4","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"3.5 Troubleshooting Symptom: Stuck at GRUB menu or grub rescue\u003e # At GRUB command line grub\u003e ls # List partitions grub\u003e ls (hd0,gpt2)/ # View partition contents grub\u003e set root=(hd0,gpt2) # Set root grub\u003e linux /vmlinuz root=/dev/sda2 grub\u003e initrd /initrd.img grub\u003e boot ","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/:3:5","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"4. Stage 3: Kernel Initialization ","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/:4:0","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"4.1 What Does the Kernel Do? Decompress itself (if compressed vmlinuz) Set CPU mode (real mode → protected mode → 64-bit long mode) Initialize memory management (page tables) Initialize interrupts (IDT) Initialize scheduler Mount initramfs as root Execute /init or /sbin/init ","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/:4:1","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"4.2 Boot Parameters # View current boot parameters cat /proc/cmdline # Common parameters root=UUID=xxx # Root partition ro / rw # Read-only/read-write mount quiet # Reduce output init=/bin/bash # Specify init program (rescue mode) single / 1 # Single-user mode ","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/:4:2","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"4.3 Troubleshooting Symptom: Kernel panic # Common causes 1. root= points to non-existent device 2. initramfs corrupted 3. Required driver not compiled in kernel and not in initramfs Solutions: Enter GRUB command line, modify root parameter Use Live CD to regenerate initramfs # Using Live CD mount /dev/sda2 /mnt mount --bind /dev /mnt/dev mount --bind /proc /mnt/proc mount --bind /sys /mnt/sys chroot /mnt update-initramfs -u -k all ","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/:4:3","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"5. Stage 4: initramfs ","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/:5:0","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"5.1 Why Do We Need initramfs? Chicken and egg problem: To mount root filesystem, need drivers Drivers are in root filesystem Root filesystem isn’t mounted yet… Solution: initramfs is a temporary in-memory filesystem containing the minimal driver set needed to mount the real root. ","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/:5:1","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"5.2 initramfs Contents # View initramfs contents lsinitramfs /boot/initrd.img-$(uname -r) | head -50 # Typical structure /init # Startup script /bin/ # busybox tools /lib/modules/ # Driver modules /etc/ # Config /scripts/ # Init scripts ","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/:5:2","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"5.3 Workflow 1. Kernel decompresses initramfs into memory 2. Mounts as temporary root (/) 3. Executes /init script 4. Loads essential drivers (SATA/NVMe/LVM/encryption etc) 5. Finds real root partition 6. pivot_root or switch_root to real root 7. Executes /sbin/init (Systemd) on real root ","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/:5:3","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"5.4 Troubleshooting Symptom: Dropped to initramfs shell # initramfs gives you a busybox shell (initramfs) # Check devices (initramfs) blkid (initramfs) ls /dev/sd* # Manually try mounting root partition (initramfs) mount /dev/sda2 /root (initramfs) ls /root Regenerate: # Debian/Ubuntu update-initramfs -u # RHEL/CentOS dracut -f ","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/:5:4","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"6. Stage 5: Systemd ","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/:6:0","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"6.1 What is Systemd? Systemd is the init system for modern Linux distros, PID is always 1. It handles: Starting and managing system services Mounting filesystems Managing user logins Log management (journald) ","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/:6:1","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"6.2 Targets Systemd uses targets instead of traditional runlevels: Runlevel Target Purpose 0 poweroff.target Shutdown 1 rescue.target Single-user/rescue mode 3 multi-user.target Multi-user CLI 5 graphical.target GUI 6 reboot.target Reboot # View default target systemctl get-default # Set default target systemctl set-default multi-user.target # Temporarily switch target systemctl isolate rescue.target ","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/:6:2","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"6.3 Service Dependencies # View service dependencies systemctl list-dependencies sshd.service # View startup order systemctl list-dependencies --before sshd.service systemctl list-dependencies --after sshd.service ","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/:6:3","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"6.4 Troubleshooting # View failed services systemctl --failed # View service logs journalctl -u sshd.service -b # View boot logs journalctl -b # Analyze boot time systemd-analyze systemd-analyze blame systemd-analyze critical-chain ","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/:6:4","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"7. Practical: Customizing Boot Process ","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/:7:0","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"7.1 Add Script to Run at Boot Method 1: rc.local (compatibility) # Create rc-local.service cat \u003e /etc/systemd/system/rc-local.service \u003c\u003c 'EOF' [Unit] Description=rc.local Compatibility After=network.target [Service] Type=oneshot ExecStart=/etc/rc.local RemainAfterExit=yes [Install] WantedBy=multi-user.target EOF # Create script echo '#!/bin/bash echo \"Hello from rc.local\" \u003e /tmp/boot-test ' \u003e /etc/rc.local chmod +x /etc/rc.local # Enable systemctl enable rc-local.service Method 2: Create Systemd Service (recommended) cat \u003e /etc/systemd/system/my-startup.service \u003c\u003c 'EOF' [Unit] Description=My Startup Script After=network.target [Service] Type=oneshot ExecStart=/usr/local/bin/my-startup.sh [Install] WantedBy=multi-user.target EOF systemctl enable my-startup.service ","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/:7:1","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"7.2 Debugging Boot Issues Strategy 1: Increase output Remove quiet splash from GRUB, add debug parameter. Strategy 2: Use serial console # GRUB parameter console=ttyS0,115200n8 console=tty0 Strategy 3: Enter rescue mode At GRUB menu press e, append init=/bin/bash to linux line. ","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/:7:2","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"8. Summary Stage Key Component Debug Entry Point BIOS/UEFI Firmware settings F2/DEL to enter setup GRUB /boot/grub/grub.cfg GRUB command line Kernel vmlinuz + parameters Boot parameter debugging initramfs /init script initramfs shell Systemd service/target journalctl Key insight: Each stage does one thing — prepare the environment for the next stage. Once you understand this chain, you’ll know where to look when things break. ","date":"2021-05-20","objectID":"/posts/210520-linux-boot-process/:8:0","tags":["Boot Process","Systemd","Debugging"],"title":"Linux Boot Process: Complete Guide from Power Button to Login","uri":"/posts/210520-linux-boot-process/"},{"categories":["Linux"],"content":"From manual deployment to GitHub Actions automation: A complete CI/CD pipeline for Hugo blogs, covering multi-branch strategies, caching, and multi-target deployment (GitHub Pages + self-hosted server).","date":"2021-03-21","objectID":"/posts/210321-hugo-auto-deployment/","tags":["CI/CD","GitHub Actions","Automation"],"title":"Hugo Blog CI/CD: GitHub Actions Auto-Build and Multi-Environment Deployment","uri":"/posts/210321-hugo-auto-deployment/"},{"categories":["Linux"],"content":"From the early days of hugo \u0026\u0026 scp to Git Push-triggered auto-deployment — this post documents the evolution of my Hugo blog CI/CD setup, along with production-grade GitHub Actions best practices. ","date":"2021-03-21","objectID":"/posts/210321-hugo-auto-deployment/:0:0","tags":["CI/CD","GitHub Actions","Automation"],"title":"Hugo Blog CI/CD: GitHub Actions Auto-Build and Multi-Environment Deployment","uri":"/posts/210321-hugo-auto-deployment/"},{"categories":["Linux"],"content":"1. Deployment Evolution ","date":"2021-03-21","objectID":"/posts/210321-hugo-auto-deployment/:1:0","tags":["CI/CD","GitHub Actions","Automation"],"title":"Hugo Blog CI/CD: GitHub Actions Auto-Build and Multi-Environment Deployment","uri":"/posts/210321-hugo-auto-deployment/"},{"categories":["Linux"],"content":"1.1 Bronze Tier: Manual Deployment hugo # Build tar -czf public.tar.gz public/ scp public.tar.gz server:/tmp/ ssh server \"cd /var/www \u0026\u0026 tar -xzf /tmp/public.tar.gz\" Pain points: Manual every time, easy to miss steps, no version history. ","date":"2021-03-21","objectID":"/posts/210321-hugo-auto-deployment/:1:1","tags":["CI/CD","GitHub Actions","Automation"],"title":"Hugo Blog CI/CD: GitHub Actions Auto-Build and Multi-Environment Deployment","uri":"/posts/210321-hugo-auto-deployment/"},{"categories":["Linux"],"content":"1.2 Silver Tier: Shell Script #!/bin/bash hugo \u0026\u0026 git add . \u0026\u0026 git commit -m \"update\" \u0026\u0026 git push ssh server \"cd ~/blog \u0026\u0026 git pull \u0026\u0026 cp -r public/* /var/www/\" Pain points: Depends on local environment, builds might differ across machines. ","date":"2021-03-21","objectID":"/posts/210321-hugo-auto-deployment/:1:2","tags":["CI/CD","GitHub Actions","Automation"],"title":"Hugo Blog CI/CD: GitHub Actions Auto-Build and Multi-Environment Deployment","uri":"/posts/210321-hugo-auto-deployment/"},{"categories":["Linux"],"content":"1.3 Gold Tier: GitHub Actions # Push triggers cloud build and auto-deploy on: push: branches: [main] Benefits: Environment consistency (containerized builds) Version tracking Multi-target deployment Automated testing ","date":"2021-03-21","objectID":"/posts/210321-hugo-auto-deployment/:1:3","tags":["CI/CD","GitHub Actions","Automation"],"title":"Hugo Blog CI/CD: GitHub Actions Auto-Build and Multi-Environment Deployment","uri":"/posts/210321-hugo-auto-deployment/"},{"categories":["Linux"],"content":"2. Complete GitHub Actions Configuration ","date":"2021-03-21","objectID":"/posts/210321-hugo-auto-deployment/:2:0","tags":["CI/CD","GitHub Actions","Automation"],"title":"Hugo Blog CI/CD: GitHub Actions Auto-Build and Multi-Environment Deployment","uri":"/posts/210321-hugo-auto-deployment/"},{"categories":["Linux"],"content":"2.1 Directory Structure .github/ └── workflows/ ├── deploy.yml # Main deploy pipeline └── preview.yml # PR preview ","date":"2021-03-21","objectID":"/posts/210321-hugo-auto-deployment/:2:1","tags":["CI/CD","GitHub Actions","Automation"],"title":"Hugo Blog CI/CD: GitHub Actions Auto-Build and Multi-Environment Deployment","uri":"/posts/210321-hugo-auto-deployment/"},{"categories":["Linux"],"content":"2.2 Main Deploy Pipeline # .github/workflows/deploy.yml name: Deploy Hugo Blog on: push: branches: - main workflow_dispatch: # Manual trigger support # Permissions (required for GitHub Pages) permissions: contents: read pages: write id-token: write # Prevent concurrent deployment conflicts concurrency: group: \"pages\" cancel-in-progress: true jobs: # ========== Build Stage ========== build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: submodules: recursive # Pull theme submodules fetch-depth: 0 # Full history (for lastmod) - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: '0.139.0' extended: true # Extended version (SCSS support) - name: Cache Hugo modules uses: actions/cache@v4 with: path: /tmp/hugo_cache key: ${{ runner.os }}-hugo-${{ hashFiles('**/go.sum') }} restore-keys: | ${{ runner.os }}-hugo- - name: Build env: HUGO_ENVIRONMENT: production HUGO_ENV: production run: | hugo \\ --gc \\ --minify \\ --baseURL \"${{ vars.SITE_URL }}\" - name: Upload artifact uses: actions/upload-pages-artifact@v3 with: path: ./public # ========== Deploy to GitHub Pages ========== deploy-pages: environment: name: github-pages url: ${{ steps.deployment.outputs.page_url }} runs-on: ubuntu-latest needs: build steps: - name: Deploy to GitHub Pages id: deployment uses: actions/deploy-pages@v4 # ========== Deploy to Self-Hosted Server ========== deploy-server: runs-on: ubuntu-latest needs: build if: github.ref == 'refs/heads/main' # Only main branch steps: - name: Download artifact uses: actions/download-artifact@v4 with: name: github-pages path: ./public - name: Extract artifact run: | cd public tar -xf artifact.tar rm artifact.tar - name: Deploy via rsync uses: burnett01/rsync-deployments@7.0.1 with: switches: -avzr --delete path: public/ remote_path: /var/www/blog/ remote_host: ${{ secrets.DEPLOY_HOST }} remote_port: ${{ secrets.DEPLOY_PORT }} remote_user: ${{ secrets.DEPLOY_USER }} remote_key: ${{ secrets.DEPLOY_KEY }} ","date":"2021-03-21","objectID":"/posts/210321-hugo-auto-deployment/:2:2","tags":["CI/CD","GitHub Actions","Automation"],"title":"Hugo Blog CI/CD: GitHub Actions Auto-Build and Multi-Environment Deployment","uri":"/posts/210321-hugo-auto-deployment/"},{"categories":["Linux"],"content":"2.3 PR Preview Pipeline # .github/workflows/preview.yml name: PR Preview on: pull_request: types: [opened, synchronize, reopened] jobs: preview: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 with: submodules: recursive - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: '0.139.0' extended: true - name: Build (Draft mode) run: | hugo --buildDrafts --baseURL \"/\" - name: Deploy Preview uses: peaceiris/actions-gh-pages@v4 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public destination_dir: pr-${{ github.event.number }} - name: Comment PR uses: actions/github-script@v7 with: script: | github.rest.issues.createComment({ issue_number: context.issue.number, owner: context.repo.owner, repo: context.repo.repo, body: 'Preview URL: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/pr-${{ github.event.number }}/' }) ","date":"2021-03-21","objectID":"/posts/210321-hugo-auto-deployment/:2:3","tags":["CI/CD","GitHub Actions","Automation"],"title":"Hugo Blog CI/CD: GitHub Actions Auto-Build and Multi-Environment Deployment","uri":"/posts/210321-hugo-auto-deployment/"},{"categories":["Linux"],"content":"3. Secrets Configuration Add these in GitHub repository settings: Secret Name Description Example DEPLOY_HOST Server IP 1.2.3.4 DEPLOY_PORT SSH port 22 DEPLOY_USER SSH user deploy DEPLOY_KEY SSH private key -----BEGIN... ","date":"2021-03-21","objectID":"/posts/210321-hugo-auto-deployment/:3:0","tags":["CI/CD","GitHub Actions","Automation"],"title":"Hugo Blog CI/CD: GitHub Actions Auto-Build and Multi-Environment Deployment","uri":"/posts/210321-hugo-auto-deployment/"},{"categories":["Linux"],"content":"Generating Deploy Keys # Generate locally ssh-keygen -t ed25519 -C \"github-actions-deploy\" -f deploy_key # Add public key to server cat deploy_key.pub \u003e\u003e ~/.ssh/authorized_keys # Add private key to GitHub Secrets cat deploy_key # Copy content to DEPLOY_KEY ","date":"2021-03-21","objectID":"/posts/210321-hugo-auto-deployment/:3:1","tags":["CI/CD","GitHub Actions","Automation"],"title":"Hugo Blog CI/CD: GitHub Actions Auto-Build and Multi-Environment Deployment","uri":"/posts/210321-hugo-auto-deployment/"},{"categories":["Linux"],"content":"4. Advanced Configuration ","date":"2021-03-21","objectID":"/posts/210321-hugo-auto-deployment/:4:0","tags":["CI/CD","GitHub Actions","Automation"],"title":"Hugo Blog CI/CD: GitHub Actions Auto-Build and Multi-Environment Deployment","uri":"/posts/210321-hugo-auto-deployment/"},{"categories":["Linux"],"content":"4.1 Scheduled Rebuilds (Update lastmod) on: schedule: - cron: '0 2 * * *' # Daily at 2 AM push: branches: [main] ","date":"2021-03-21","objectID":"/posts/210321-hugo-auto-deployment/:4:1","tags":["CI/CD","GitHub Actions","Automation"],"title":"Hugo Blog CI/CD: GitHub Actions Auto-Build and Multi-Environment Deployment","uri":"/posts/210321-hugo-auto-deployment/"},{"categories":["Linux"],"content":"4.2 Multi-Environment Deployment jobs: build: # ...build steps... deploy-staging: needs: build if: github.ref == 'refs/heads/develop' environment: staging # Deploy to staging deploy-production: needs: build if: github.ref == 'refs/heads/main' environment: production # Deploy to production ","date":"2021-03-21","objectID":"/posts/210321-hugo-auto-deployment/:4:2","tags":["CI/CD","GitHub Actions","Automation"],"title":"Hugo Blog CI/CD: GitHub Actions Auto-Build and Multi-Environment Deployment","uri":"/posts/210321-hugo-auto-deployment/"},{"categories":["Linux"],"content":"4.3 Build Cache Optimization - name: Cache Hugo modules uses: actions/cache@v4 with: path: | /tmp/hugo_cache node_modules key: ${{ runner.os }}-hugo-${{ hashFiles('**/go.sum', '**/package-lock.json') }} ","date":"2021-03-21","objectID":"/posts/210321-hugo-auto-deployment/:4:3","tags":["CI/CD","GitHub Actions","Automation"],"title":"Hugo Blog CI/CD: GitHub Actions Auto-Build and Multi-Environment Deployment","uri":"/posts/210321-hugo-auto-deployment/"},{"categories":["Linux"],"content":"4.4 Dockerfile Build (More Control) # Dockerfile FROM hugomods/hugo:exts-0.139.0 WORKDIR /src COPY . . RUN hugo --gc --minify # GitHub Actions - name: Build with Docker run: | docker build -t blog-builder . docker run --rm -v $PWD/public:/src/public blog-builder ","date":"2021-03-21","objectID":"/posts/210321-hugo-auto-deployment/:4:4","tags":["CI/CD","GitHub Actions","Automation"],"title":"Hugo Blog CI/CD: GitHub Actions Auto-Build and Multi-Environment Deployment","uri":"/posts/210321-hugo-auto-deployment/"},{"categories":["Linux"],"content":"5. Monitoring \u0026 Alerts ","date":"2021-03-21","objectID":"/posts/210321-hugo-auto-deployment/:5:0","tags":["CI/CD","GitHub Actions","Automation"],"title":"Hugo Blog CI/CD: GitHub Actions Auto-Build and Multi-Environment Deployment","uri":"/posts/210321-hugo-auto-deployment/"},{"categories":["Linux"],"content":"5.1 Deployment Status Badge ![Deploy Status](https://github.com/username/blog/actions/workflows/deploy.yml/badge.svg) ","date":"2021-03-21","objectID":"/posts/210321-hugo-auto-deployment/:5:1","tags":["CI/CD","GitHub Actions","Automation"],"title":"Hugo Blog CI/CD: GitHub Actions Auto-Build and Multi-Environment Deployment","uri":"/posts/210321-hugo-auto-deployment/"},{"categories":["Linux"],"content":"5.2 Failure Notifications - name: Notify on failure if: failure() uses: 8398a7/action-slack@v3 with: status: ${{ job.status }} fields: repo,message,commit,author env: SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }} ","date":"2021-03-21","objectID":"/posts/210321-hugo-auto-deployment/:5:2","tags":["CI/CD","GitHub Actions","Automation"],"title":"Hugo Blog CI/CD: GitHub Actions Auto-Build and Multi-Environment Deployment","uri":"/posts/210321-hugo-auto-deployment/"},{"categories":["Linux"],"content":"6. Common Issues ","date":"2021-03-21","objectID":"/posts/210321-hugo-auto-deployment/:6:0","tags":["CI/CD","GitHub Actions","Automation"],"title":"Hugo Blog CI/CD: GitHub Actions Auto-Build and Multi-Environment Deployment","uri":"/posts/210321-hugo-auto-deployment/"},{"categories":["Linux"],"content":"6.1 Theme Submodule Not Pulled - uses: actions/checkout@v4 with: submodules: recursive # Key config ","date":"2021-03-21","objectID":"/posts/210321-hugo-auto-deployment/:6:1","tags":["CI/CD","GitHub Actions","Automation"],"title":"Hugo Blog CI/CD: GitHub Actions Auto-Build and Multi-Environment Deployment","uri":"/posts/210321-hugo-auto-deployment/"},{"categories":["Linux"],"content":"6.2 Hugo Version Mismatch # Pin the version to avoid surprises - uses: peaceiris/actions-hugo@v3 with: hugo-version: '0.139.0' # Explicit version ","date":"2021-03-21","objectID":"/posts/210321-hugo-auto-deployment/:6:2","tags":["CI/CD","GitHub Actions","Automation"],"title":"Hugo Blog CI/CD: GitHub Actions Auto-Build and Multi-Environment Deployment","uri":"/posts/210321-hugo-auto-deployment/"},{"categories":["Linux"],"content":"6.3 Build Running Out of Memory jobs: build: runs-on: ubuntu-latest env: HUGO_CACHEDIR: /tmp/hugo_cache HUGO_NUMWORKERMULTIPLIER: 1 # Reduce concurrency ","date":"2021-03-21","objectID":"/posts/210321-hugo-auto-deployment/:6:3","tags":["CI/CD","GitHub Actions","Automation"],"title":"Hugo Blog CI/CD: GitHub Actions Auto-Build and Multi-Environment Deployment","uri":"/posts/210321-hugo-auto-deployment/"},{"categories":["Linux"],"content":"7. Complete Workflow ┌─────────────┐ ┌──────────────┐ ┌─────────────────┐ │ Git Push │────▶│ GitHub │────▶│ Build Hugo │ │ (main) │ │ Actions │ │ (Container) │ └─────────────┘ └──────────────┘ └────────┬────────┘ │ ┌────────────────────────┼────────────────────────┐ ▼ ▼ ▼ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ │ GitHub Pages│ │ Self-Hosted │ │ CDN Purge │ │ (Backup) │ │ (Primary) │ │ (Optional) │ └─────────────┘ └─────────────┘ └─────────────┘ ","date":"2021-03-21","objectID":"/posts/210321-hugo-auto-deployment/:7:0","tags":["CI/CD","GitHub Actions","Automation"],"title":"Hugo Blog CI/CD: GitHub Actions Auto-Build and Multi-Environment Deployment","uri":"/posts/210321-hugo-auto-deployment/"},{"categories":["Linux"],"content":"8. Summary Evolution Stage Deploy Time Traceability Environment Consistency Manual 5 min None Poor Shell script 1 min None Fair GitHub Actions 2 min Full Consistent Key takeaways: Git = Deploy: Push triggers deployment, no extra steps Environment isolation: Containerized builds eliminate “works on my machine” Multi-target deployment: Ship to GitHub Pages and self-hosted server simultaneously Observability: Every deployment is logged, failures trigger notifications ","date":"2021-03-21","objectID":"/posts/210321-hugo-auto-deployment/:8:0","tags":["CI/CD","GitHub Actions","Automation"],"title":"Hugo Blog CI/CD: GitHub Actions Auto-Build and Multi-Environment Deployment","uri":"/posts/210321-hugo-auto-deployment/"},{"categories":["Linux"],"content":"Starting from a PDF reader dark mode requirement, deep-diving into Flatpak's sandbox mechanism, filesystem isolation, and proper theme override configuration. These concepts parallel containerized application configuration.","date":"2021-01-26","objectID":"/posts/210126-flatpak-theme/","tags":["Containers","Sandbox","Namespaces"],"title":"Linux Desktop Customization: Flatpak Theme Integration and Container Isolation Principles","uri":"/posts/210126-flatpak-theme/"},{"categories":["Linux"],"content":"A simple requirement: make a Flatpak-installed PDF reader support dark mode. But solving it involves Flatpak’s sandbox mechanism, filesystem mounts, and environment variable injection — concepts highly similar to Docker/K8s containerization. ","date":"2021-01-26","objectID":"/posts/210126-flatpak-theme/:0:0","tags":["Containers","Sandbox","Namespaces"],"title":"Linux Desktop Customization: Flatpak Theme Integration and Container Isolation Principles","uri":"/posts/210126-flatpak-theme/"},{"categories":["Linux"],"content":"1. Problem Background After installing Okular (PDF reader) via Flatpak on Linux desktop, it doesn’t follow the system dark theme. Reason: Flatpak apps run in a sandbox, isolated from the host system. ","date":"2021-01-26","objectID":"/posts/210126-flatpak-theme/:1:0","tags":["Containers","Sandbox","Namespaces"],"title":"Linux Desktop Customization: Flatpak Theme Integration and Container Isolation Principles","uri":"/posts/210126-flatpak-theme/"},{"categories":["Linux"],"content":"1.1 Flatpak Sandbox Mechanism ┌─────────────────────────────────────────────────────────┐ │ Host System │ │ /home/user/.config/ │ │ /usr/share/themes/ │ │ System GTK/Qt Theme │ └─────────────────────────────────────────────────────────┘ │ ❌ Isolated by default │ ┌─────────────────────────────────────────────────────────┐ │ Flatpak Sandbox │ │ /app/ (read-only application) │ │ ~/.var/app/org.kde.okular/ (app private data) │ │ Limited privileges and filesystem access │ └─────────────────────────────────────────────────────────┘ This matches Docker container isolation philosophy: default minimal permissions, grant on demand. ","date":"2021-01-26","objectID":"/posts/210126-flatpak-theme/:1:1","tags":["Containers","Sandbox","Namespaces"],"title":"Linux Desktop Customization: Flatpak Theme Integration and Container Isolation Principles","uri":"/posts/210126-flatpak-theme/"},{"categories":["Linux"],"content":"1.2 Docker Analogy Flatpak Concept Docker Equivalent --filesystem= -v volume mount --env= -e environment variable flatpak override docker-compose override /app Image read-only layer ~/.var/app/\u003cid\u003e Container writable layer ","date":"2021-01-26","objectID":"/posts/210126-flatpak-theme/:1:2","tags":["Containers","Sandbox","Namespaces"],"title":"Linux Desktop Customization: Flatpak Theme Integration and Container Isolation Principles","uri":"/posts/210126-flatpak-theme/"},{"categories":["Linux"],"content":"2. Solution ","date":"2021-01-26","objectID":"/posts/210126-flatpak-theme/:2:0","tags":["Containers","Sandbox","Namespaces"],"title":"Linux Desktop Customization: Flatpak Theme Integration and Container Isolation Principles","uri":"/posts/210126-flatpak-theme/"},{"categories":["Linux"],"content":"2.1 Install Kvantum Theme Engine Kvantum is a Qt theme engine, install on host system: # Fedora sudo dnf install kvantum # Ubuntu/Debian sudo apt install qt5-style-kvantum # Arch sudo pacman -S kvantum ","date":"2021-01-26","objectID":"/posts/210126-flatpak-theme/:2:1","tags":["Containers","Sandbox","Namespaces"],"title":"Linux Desktop Customization: Flatpak Theme Integration and Container Isolation Principles","uri":"/posts/210126-flatpak-theme/"},{"categories":["Linux"],"content":"2.2 Configure Dark Theme # Launch theme manager kvantummanager Select KvDark or another dark theme and apply. ","date":"2021-01-26","objectID":"/posts/210126-flatpak-theme/:2:2","tags":["Containers","Sandbox","Namespaces"],"title":"Linux Desktop Customization: Flatpak Theme Integration and Container Isolation Principles","uri":"/posts/210126-flatpak-theme/"},{"categories":["Linux"],"content":"2.3 Key: Grant Flatpak Access to Theme Config # Temporary test (single run) flatpak run \\ --env=QT_STYLE_OVERRIDE=kvantum \\ --filesystem=xdg-config/Kvantum:ro \\ org.kde.okular # Permanent flatpak override \\ --user \\ --env=QT_STYLE_OVERRIDE=kvantum \\ --filesystem=xdg-config/Kvantum:ro \\ org.kde.okular Command breakdown: Parameter Purpose Docker Analogy --env=QT_STYLE_OVERRIDE=kvantum Inject environment variable -e VAR=value --filesystem=xdg-config/Kvantum:ro Read-only mount theme config dir -v /path:/path:ro --user User-level config (not global) ~/.docker/config.json ","date":"2021-01-26","objectID":"/posts/210126-flatpak-theme/:2:3","tags":["Containers","Sandbox","Namespaces"],"title":"Linux Desktop Customization: Flatpak Theme Integration and Container Isolation Principles","uri":"/posts/210126-flatpak-theme/"},{"categories":["Linux"],"content":"2.4 Verify Mount # View app permissions flatpak info --show-permissions org.kde.okular # View override config cat ~/.local/share/flatpak/overrides/org.kde.okular ","date":"2021-01-26","objectID":"/posts/210126-flatpak-theme/:2:4","tags":["Containers","Sandbox","Namespaces"],"title":"Linux Desktop Customization: Flatpak Theme Integration and Container Isolation Principles","uri":"/posts/210126-flatpak-theme/"},{"categories":["Linux"],"content":"3. Deep Dive: Flatpak Sandbox ","date":"2021-01-26","objectID":"/posts/210126-flatpak-theme/:3:0","tags":["Containers","Sandbox","Namespaces"],"title":"Linux Desktop Customization: Flatpak Theme Integration and Container Isolation Principles","uri":"/posts/210126-flatpak-theme/"},{"categories":["Linux"],"content":"3.1 Namespace Isolation Flatpak uses Linux kernel namespaces for isolation: # View Flatpak process namespaces ls -la /proc/$(pgrep okular)/ns/ # Output lrwxrwxrwx 1 user user 0 Dec 11 01:00 mnt -\u003e 'mnt:[4026532xxx]' lrwxrwxrwx 1 user user 0 Dec 11 01:00 net -\u003e 'net:[4026532xxx]' lrwxrwxrwx 1 user user 0 Dec 11 01:00 pid -\u003e 'pid:[4026532xxx]' This is the core of container technology! Docker, K8s Pods use the same kernel mechanisms. ","date":"2021-01-26","objectID":"/posts/210126-flatpak-theme/:3:1","tags":["Containers","Sandbox","Namespaces"],"title":"Linux Desktop Customization: Flatpak Theme Integration and Container Isolation Principles","uri":"/posts/210126-flatpak-theme/"},{"categories":["Linux"],"content":"3.2 Filesystem Isolation # Enter Flatpak app's sandbox perspective flatpak run --command=sh org.kde.okular # View filesystem inside sandbox $ ls / app dev etc home proc run sys tmp usr var # /app is the application (read-only) $ ls /app bin lib share # User data at ~/.var/app/ $ ls ~/.var/app/org.kde.okular/ cache config data ","date":"2021-01-26","objectID":"/posts/210126-flatpak-theme/:3:2","tags":["Containers","Sandbox","Namespaces"],"title":"Linux Desktop Customization: Flatpak Theme Integration and Container Isolation Principles","uri":"/posts/210126-flatpak-theme/"},{"categories":["Linux"],"content":"3.3 Portal Mechanism For accessing host resources (opening files, printing), Flatpak uses Portals: App → Portal (DBus) → Host System Example: okular requests to open file → Calls host file picker via Portal → User selects file → Portal grants that file to okular This is least privilege principle in practice: apps can’t directly access all files, only those explicitly authorized by user. ","date":"2021-01-26","objectID":"/posts/210126-flatpak-theme/:3:3","tags":["Containers","Sandbox","Namespaces"],"title":"Linux Desktop Customization: Flatpak Theme Integration and Container Isolation Principles","uri":"/posts/210126-flatpak-theme/"},{"categories":["Linux"],"content":"4. Batch Configuration ","date":"2021-01-26","objectID":"/posts/210126-flatpak-theme/:4:0","tags":["Containers","Sandbox","Namespaces"],"title":"Linux Desktop Customization: Flatpak Theme Integration and Container Isolation Principles","uri":"/posts/210126-flatpak-theme/"},{"categories":["Linux"],"content":"4.1 Global Theme Config # Set theme for all Flatpak Qt apps flatpak override --user \\ --env=QT_STYLE_OVERRIDE=kvantum \\ --filesystem=xdg-config/Kvantum:ro # View global config cat ~/.local/share/flatpak/overrides/global ","date":"2021-01-26","objectID":"/posts/210126-flatpak-theme/:4:1","tags":["Containers","Sandbox","Namespaces"],"title":"Linux Desktop Customization: Flatpak Theme Integration and Container Isolation Principles","uri":"/posts/210126-flatpak-theme/"},{"categories":["Linux"],"content":"4.2 Config File Format # ~/.local/share/flatpak/overrides/org.kde.okular [Context] filesystems=xdg-config/Kvantum:ro [Environment] QT_STYLE_OVERRIDE=kvantum ","date":"2021-01-26","objectID":"/posts/210126-flatpak-theme/:4:2","tags":["Containers","Sandbox","Namespaces"],"title":"Linux Desktop Customization: Flatpak Theme Integration and Container Isolation Principles","uri":"/posts/210126-flatpak-theme/"},{"categories":["Linux"],"content":"4.3 Reset Configuration # Remove specific app override flatpak override --user --reset org.kde.okular # Remove global override rm ~/.local/share/flatpak/overrides/global ","date":"2021-01-26","objectID":"/posts/210126-flatpak-theme/:4:3","tags":["Containers","Sandbox","Namespaces"],"title":"Linux Desktop Customization: Flatpak Theme Integration and Container Isolation Principles","uri":"/posts/210126-flatpak-theme/"},{"categories":["Linux"],"content":"5. Connection to Container Configuration ","date":"2021-01-26","objectID":"/posts/210126-flatpak-theme/:5:0","tags":["Containers","Sandbox","Namespaces"],"title":"Linux Desktop Customization: Flatpak Theme Integration and Container Isolation Principles","uri":"/posts/210126-flatpak-theme/"},{"categories":["Linux"],"content":"5.1 Configuration Injection Patterns Scenario Flatpak Docker/K8s Env vars --env=KEY=VALUE -e KEY=VALUE / env: Config file mount --filesystem=path:ro -v /path:/path:ro / volumeMounts: Persistent data ~/.var/app/\u003cid\u003e Named volume / PVC Network access --share=network --network / hostNetwork: ","date":"2021-01-26","objectID":"/posts/210126-flatpak-theme/:5:1","tags":["Containers","Sandbox","Namespaces"],"title":"Linux Desktop Customization: Flatpak Theme Integration and Container Isolation Principles","uri":"/posts/210126-flatpak-theme/"},{"categories":["Linux"],"content":"5.2 Least Privilege Principle # K8s Pod security context - same concept securityContext: readOnlyRootFilesystem: true runAsNonRoot: true capabilities: drop: [\"ALL\"] Flatpak’s sandbox, Docker’s seccomp, K8s PodSecurityPolicy — all practice default deny, explicit grant. ","date":"2021-01-26","objectID":"/posts/210126-flatpak-theme/:5:2","tags":["Containers","Sandbox","Namespaces"],"title":"Linux Desktop Customization: Flatpak Theme Integration and Container Isolation Principles","uri":"/posts/210126-flatpak-theme/"},{"categories":["Linux"],"content":"6. Troubleshooting ","date":"2021-01-26","objectID":"/posts/210126-flatpak-theme/:6:0","tags":["Containers","Sandbox","Namespaces"],"title":"Linux Desktop Customization: Flatpak Theme Integration and Container Isolation Principles","uri":"/posts/210126-flatpak-theme/"},{"categories":["Linux"],"content":"6.1 View App Actual Permissions flatpak info --show-permissions org.kde.okular ","date":"2021-01-26","objectID":"/posts/210126-flatpak-theme/:6:1","tags":["Containers","Sandbox","Namespaces"],"title":"Linux Desktop Customization: Flatpak Theme Integration and Container Isolation Principles","uri":"/posts/210126-flatpak-theme/"},{"categories":["Linux"],"content":"6.2 View Runtime Environment flatpak run --command=env org.kde.okular | grep -E \"QT_|XDG_\" ","date":"2021-01-26","objectID":"/posts/210126-flatpak-theme/:6:2","tags":["Containers","Sandbox","Namespaces"],"title":"Linux Desktop Customization: Flatpak Theme Integration and Container Isolation Principles","uri":"/posts/210126-flatpak-theme/"},{"categories":["Linux"],"content":"6.3 Check File Accessibility flatpak run --command=ls org.kde.okular ~/.config/Kvantum/ ","date":"2021-01-26","objectID":"/posts/210126-flatpak-theme/:6:3","tags":["Containers","Sandbox","Namespaces"],"title":"Linux Desktop Customization: Flatpak Theme Integration and Container Isolation Principles","uri":"/posts/210126-flatpak-theme/"},{"categories":["Linux"],"content":"7. Summary Concept Flatpak Practice Container Connection Namespace isolation Process/filesystem/network isolation Docker/K8s core mechanism Filesystem mount --filesystem= Volume Mount Env var injection --env= ConfigMap/Secret Least privilege Portal mechanism RBAC / SecurityContext Core insight: A seemingly simple theme configuration problem reveals complete containerization isolation concepts. Understanding Flatpak’s sandbox mechanism helps understand Docker/K8s fundamentals. ","date":"2021-01-26","objectID":"/posts/210126-flatpak-theme/:7:0","tags":["Containers","Sandbox","Namespaces"],"title":"Linux Desktop Customization: Flatpak Theme Integration and Container Isolation Principles","uri":"/posts/210126-flatpak-theme/"},{"categories":["Go"],"content":"Bit operations aren’t just interview questions. From Redis Bitmaps and Kafka ACLs to Linux file permissions, bit operations are fundamental to high-performance systems. This post demonstrates bit operations in real systems through practical examples. ","date":"2021-01-11","objectID":"/posts/210111-shift-operation/:0:0","tags":["Bit Operations","Performance","System Design"],"title":"Bit Operations in Practice: From Bitmap Indexes to High-Performance Permission Systems","uri":"/posts/210111-shift-operation/"},{"categories":["Go"],"content":"1. Bit Operations Quick Review ","date":"2021-01-11","objectID":"/posts/210111-shift-operation/:1:0","tags":["Bit Operations","Performance","System Design"],"title":"Bit Operations in Practice: From Bitmap Indexes to High-Performance Permission Systems","uri":"/posts/210111-shift-operation/"},{"categories":["Go"],"content":"1.1 Basic Operations Operation Symbol Example Result AND \u0026 1010 \u0026 1100 1000 OR | 1010 | 1100 1110 XOR ^ 1010 ^ 1100 0110 NOT ~ ~1010 0101 Left shift « 0001 « 2 0100 Right shift » 1000 » 2 0010 ","date":"2021-01-11","objectID":"/posts/210111-shift-operation/:1:1","tags":["Bit Operations","Performance","System Design"],"title":"Bit Operations in Practice: From Bitmap Indexes to High-Performance Permission Systems","uri":"/posts/210111-shift-operation/"},{"categories":["Go"],"content":"1.2 Common Tricks // Set bit n to 1 x |= (1 \u003c\u003c n) // Clear bit n x \u0026= ^(1 \u003c\u003c n) // Toggle bit n x ^= (1 \u003c\u003c n) // Check bit n (x \u003e\u003e n) \u0026 1 // Get lowest set bit x \u0026 (-x) // Clear lowest set bit x \u0026 (x - 1) ","date":"2021-01-11","objectID":"/posts/210111-shift-operation/:1:2","tags":["Bit Operations","Performance","System Design"],"title":"Bit Operations in Practice: From Bitmap Indexes to High-Performance Permission Systems","uri":"/posts/210111-shift-operation/"},{"categories":["Go"],"content":"2. Case 1: Linux File Permissions ","date":"2021-01-11","objectID":"/posts/210111-shift-operation/:2:0","tags":["Bit Operations","Performance","System Design"],"title":"Bit Operations in Practice: From Bitmap Indexes to High-Performance Permission Systems","uri":"/posts/210111-shift-operation/"},{"categories":["Go"],"content":"2.1 Permission Model -rwxr-xr-- 1 user group 4096 Dec 10 10:00 file.txt ^^^ 421 (owner: read + write + execute = 7) ^^^ 421 (group: read + execute = 5) ^^^ 421 (others: read = 4) # Permission value: 754 ","date":"2021-01-11","objectID":"/posts/210111-shift-operation/:2:1","tags":["Bit Operations","Performance","System Design"],"title":"Bit Operations in Practice: From Bitmap Indexes to High-Performance Permission Systems","uri":"/posts/210111-shift-operation/"},{"categories":["Go"],"content":"2.2 Go Implementation type Permission uint32 const ( PermRead Permission = 1 \u003c\u003c 0 // 001 = 1 PermWrite Permission = 1 \u003c\u003c 1 // 010 = 2 PermExecute Permission = 1 \u003c\u003c 2 // 100 = 4 ) // Check permission func (p Permission) Has(perm Permission) bool { return p\u0026perm == perm } // Grant permission func (p *Permission) Grant(perm Permission) { *p |= perm } // Revoke permission func (p *Permission) Revoke(perm Permission) { *p \u0026= ^perm } // Usage example func main() { var perm Permission = PermRead | PermWrite // 011 = 3 fmt.Println(perm.Has(PermRead)) // true fmt.Println(perm.Has(PermExecute)) // false perm.Grant(PermExecute) fmt.Printf(\"%03b\\n\", perm) // 111 perm.Revoke(PermWrite) fmt.Printf(\"%03b\\n\", perm) // 101 } ","date":"2021-01-11","objectID":"/posts/210111-shift-operation/:2:2","tags":["Bit Operations","Performance","System Design"],"title":"Bit Operations in Practice: From Bitmap Indexes to High-Performance Permission Systems","uri":"/posts/210111-shift-operation/"},{"categories":["Go"],"content":"3. Case 2: RBAC Permission System ","date":"2021-01-11","objectID":"/posts/210111-shift-operation/:3:0","tags":["Bit Operations","Performance","System Design"],"title":"Bit Operations in Practice: From Bitmap Indexes to High-Performance Permission Systems","uri":"/posts/210111-shift-operation/"},{"categories":["Go"],"content":"3.1 Scenario Analysis Imagine a SaaS system with these permissions: const ( PermViewDashboard uint64 = 1 \u003c\u003c 0 PermEditProfile uint64 = 1 \u003c\u003c 1 PermCreateProject uint64 = 1 \u003c\u003c 2 PermDeleteProject uint64 = 1 \u003c\u003c 3 PermInviteUser uint64 = 1 \u003c\u003c 4 PermRemoveUser uint64 = 1 \u003c\u003c 5 PermManageBilling uint64 = 1 \u003c\u003c 6 PermAccessAdmin uint64 = 1 \u003c\u003c 7 // ... up to 64 permissions ) // Predefined roles const ( RoleViewer uint64 = PermViewDashboard RoleEditor uint64 = PermViewDashboard | PermEditProfile | PermCreateProject RoleAdmin uint64 = PermViewDashboard | PermEditProfile | PermCreateProject | PermDeleteProject | PermInviteUser | PermRemoveUser RoleOwner uint64 = 0xFFFFFFFFFFFFFFFF // All permissions ) ","date":"2021-01-11","objectID":"/posts/210111-shift-operation/:3:1","tags":["Bit Operations","Performance","System Design"],"title":"Bit Operations in Practice: From Bitmap Indexes to High-Performance Permission Systems","uri":"/posts/210111-shift-operation/"},{"categories":["Go"],"content":"3.2 High-Performance Permission Checks type User struct { ID int64 Permissions uint64 // Only 8 bytes stores all permissions! } // O(1) permission check func (u *User) Can(perm uint64) bool { return u.Permissions\u0026perm == perm } // Check multiple permissions (all must match) func (u *User) CanAll(perms ...uint64) bool { var required uint64 for _, p := range perms { required |= p } return u.Permissions\u0026required == required } // Check multiple permissions (any matches) func (u *User) CanAny(perms ...uint64) bool { var required uint64 for _, p := range perms { required |= p } return u.Permissions\u0026required != 0 } ","date":"2021-01-11","objectID":"/posts/210111-shift-operation/:3:2","tags":["Bit Operations","Performance","System Design"],"title":"Bit Operations in Practice: From Bitmap Indexes to High-Performance Permission Systems","uri":"/posts/210111-shift-operation/"},{"categories":["Go"],"content":"3.3 Comparison with Traditional Approach Traditional (relational tables): -- Query user permissions SELECT p.name FROM user_roles ur JOIN role_permissions rp ON ur.role_id = rp.role_id JOIN permissions p ON rp.permission_id = p.id WHERE ur.user_id = ? -- Check permission SELECT COUNT(*) FROM user_roles ur JOIN role_permissions rp ON ur.role_id = rp.role_id WHERE ur.user_id = ? AND rp.permission_id = ? Performance comparison: Aspect Relational Bitmap Storage 3 tables + indexes 1 uint64 field Check permission JOIN query Bit operation O(1) Grant permission INSERT OR operation Network overhead Multiple DB roundtrips None (already in memory) ","date":"2021-01-11","objectID":"/posts/210111-shift-operation/:3:3","tags":["Bit Operations","Performance","System Design"],"title":"Bit Operations in Practice: From Bitmap Indexes to High-Performance Permission Systems","uri":"/posts/210111-shift-operation/"},{"categories":["Go"],"content":"3.4 Database Storage // Save to database func (u *User) Save(db *sql.DB) error { _, err := db.Exec( \"UPDATE users SET permissions = ? WHERE id = ?\", u.Permissions, // Store uint64 directly u.ID, ) return err } // Load from database func LoadUser(db *sql.DB, id int64) (*User, error) { var u User err := db.QueryRow( \"SELECT id, permissions FROM users WHERE id = ?\", id, ).Scan(\u0026u.ID, \u0026u.Permissions) return \u0026u, err } ","date":"2021-01-11","objectID":"/posts/210111-shift-operation/:3:4","tags":["Bit Operations","Performance","System Design"],"title":"Bit Operations in Practice: From Bitmap Indexes to High-Performance Permission Systems","uri":"/posts/210111-shift-operation/"},{"categories":["Go"],"content":"4. Case 3: Bitmap Index ","date":"2021-01-11","objectID":"/posts/210111-shift-operation/:4:0","tags":["Bit Operations","Performance","System Design"],"title":"Bit Operations in Practice: From Bitmap Indexes to High-Performance Permission Systems","uri":"/posts/210111-shift-operation/"},{"categories":["Go"],"content":"4.1 Scenario: User Tag System // User tags (up to 64) const ( TagPremium uint64 = 1 \u003c\u003c 0 TagVerified uint64 = 1 \u003c\u003c 1 TagNewUser uint64 = 1 \u003c\u003c 2 TagHighValue uint64 = 1 \u003c\u003c 3 TagChurningRisk uint64 = 1 \u003c\u003c 4 // ... ) type UserIndex struct { // Each tag has a bitmap // bitmap[i] bit j means user j has tag i bitmaps [64][]uint64 userCount int } ","date":"2021-01-11","objectID":"/posts/210111-shift-operation/:4:1","tags":["Bit Operations","Performance","System Design"],"title":"Bit Operations in Practice: From Bitmap Indexes to High-Performance Permission Systems","uri":"/posts/210111-shift-operation/"},{"categories":["Go"],"content":"4.2 Fast Filtering // Find all \"Premium AND Verified AND NOT ChurningRisk\" users func (idx *UserIndex) Query(must, mustNot uint64) []int { var result []int // Calculate match for each block blocks := (idx.userCount + 63) / 64 for b := 0; b \u003c blocks; b++ { var match uint64 = 0xFFFFFFFFFFFFFFFF // AND conditions for i := 0; i \u003c 64; i++ { if must\u0026(1\u003c\u003ci) != 0 { match \u0026= idx.bitmaps[i][b] } } // NOT conditions for i := 0; i \u003c 64; i++ { if mustNot\u0026(1\u003c\u003ci) != 0 { match \u0026= ^idx.bitmaps[i][b] } } // Extract matching user IDs for match != 0 { pos := bits.TrailingZeros64(match) result = append(result, b*64+pos) match \u0026= match - 1 // Clear lowest set bit } } return result } ","date":"2021-01-11","objectID":"/posts/210111-shift-operation/:4:2","tags":["Bit Operations","Performance","System Design"],"title":"Bit Operations in Practice: From Bitmap Indexes to High-Performance Permission Systems","uri":"/posts/210111-shift-operation/"},{"categories":["Go"],"content":"4.3 Performance Analysis For 10 million users, 64 tags: Approach Storage Query Complexity Traditional table 10M × 64 rows O(n) scan Bitmap 64 × 1.25MB = 80MB O(n/64) bit ops Actual speed: Modern CPUs process 64 bits at once; with SIMD it’s even faster. ","date":"2021-01-11","objectID":"/posts/210111-shift-operation/:4:3","tags":["Bit Operations","Performance","System Design"],"title":"Bit Operations in Practice: From Bitmap Indexes to High-Performance Permission Systems","uri":"/posts/210111-shift-operation/"},{"categories":["Go"],"content":"5. Case 4: Bloom Filter ","date":"2021-01-11","objectID":"/posts/210111-shift-operation/:5:0","tags":["Bit Operations","Performance","System Design"],"title":"Bit Operations in Practice: From Bitmap Indexes to High-Performance Permission Systems","uri":"/posts/210111-shift-operation/"},{"categories":["Go"],"content":"5.1 Principle Bloom filters use multiple hashes + bitmap for efficient “might exist” checks: type BloomFilter struct { bits []uint64 numHash int } func (bf *BloomFilter) Add(item string) { for i := 0; i \u003c bf.numHash; i++ { hash := bf.hash(item, i) idx := hash / 64 bit := hash % 64 bf.bits[idx] |= 1 \u003c\u003c bit } } func (bf *BloomFilter) MayContain(item string) bool { for i := 0; i \u003c bf.numHash; i++ { hash := bf.hash(item, i) idx := hash / 64 bit := hash % 64 if bf.bits[idx]\u0026(1\u003c\u003cbit) == 0 { return false // Definitely doesn't exist } } return true // Might exist } ","date":"2021-01-11","objectID":"/posts/210111-shift-operation/:5:1","tags":["Bit Operations","Performance","System Design"],"title":"Bit Operations in Practice: From Bitmap Indexes to High-Performance Permission Systems","uri":"/posts/210111-shift-operation/"},{"categories":["Go"],"content":"5.2 Use Cases Redis: Check if key exists Databases: Skip SSTables without target data Crawlers: URL deduplication Recommendation systems: Filter already recommended content ","date":"2021-01-11","objectID":"/posts/210111-shift-operation/:5:2","tags":["Bit Operations","Performance","System Design"],"title":"Bit Operations in Practice: From Bitmap Indexes to High-Performance Permission Systems","uri":"/posts/210111-shift-operation/"},{"categories":["Go"],"content":"6. Practical Techniques ","date":"2021-01-11","objectID":"/posts/210111-shift-operation/:6:0","tags":["Bit Operations","Performance","System Design"],"title":"Bit Operations in Practice: From Bitmap Indexes to High-Performance Permission Systems","uri":"/posts/210111-shift-operation/"},{"categories":["Go"],"content":"6.1 More Than 64 Permissions type LargePermission struct { bits []uint64 } func (p *LargePermission) Set(n int) { idx := n / 64 bit := n % 64 // Dynamic expansion for len(p.bits) \u003c= idx { p.bits = append(p.bits, 0) } p.bits[idx] |= 1 \u003c\u003c bit } func (p *LargePermission) Has(n int) bool { idx := n / 64 bit := n % 64 if idx \u003e= len(p.bits) { return false } return p.bits[idx]\u0026(1\u003c\u003cbit) != 0 } ","date":"2021-01-11","objectID":"/posts/210111-shift-operation/:6:1","tags":["Bit Operations","Performance","System Design"],"title":"Bit Operations in Practice: From Bitmap Indexes to High-Performance Permission Systems","uri":"/posts/210111-shift-operation/"},{"categories":["Go"],"content":"6.2 Atomic Operations (Concurrent-Safe) import \"sync/atomic\" type AtomicPermission struct { bits uint64 } func (p *AtomicPermission) Grant(perm uint64) { for { old := atomic.LoadUint64(\u0026p.bits) new := old | perm if atomic.CompareAndSwapUint64(\u0026p.bits, old, new) { return } } } func (p *AtomicPermission) Has(perm uint64) bool { return atomic.LoadUint64(\u0026p.bits)\u0026perm == perm } ","date":"2021-01-11","objectID":"/posts/210111-shift-operation/:6:2","tags":["Bit Operations","Performance","System Design"],"title":"Bit Operations in Practice: From Bitmap Indexes to High-Performance Permission Systems","uri":"/posts/210111-shift-operation/"},{"categories":["Go"],"content":"6.3 JSON Serialization type Permission uint64 func (p Permission) MarshalJSON() ([]byte, error) { // Convert to permission name list for readability names := []string{} if p\u0026PermRead != 0 { names = append(names, \"read\") } if p\u0026PermWrite != 0 { names = append(names, \"write\") } // ... return json.Marshal(names) } ","date":"2021-01-11","objectID":"/posts/210111-shift-operation/:6:3","tags":["Bit Operations","Performance","System Design"],"title":"Bit Operations in Practice: From Bitmap Indexes to High-Performance Permission Systems","uri":"/posts/210111-shift-operation/"},{"categories":["Go"],"content":"7. Summary Use Case Bit Operation Advantage Permission system O(1) check, 8 bytes stores 64 permissions Tags/Categories Fast filtering, compound conditions Bloom filter Space-efficient existence check State machines Compact multi-state representation Key takeaways: Bit operations bring CPU instruction-level optimization to application layer Space compression + constant time = win-win Great for “one of many” or “many of many” scenarios Combined with atomics enables lock-free concurrency ","date":"2021-01-11","objectID":"/posts/210111-shift-operation/:7:0","tags":["Bit Operations","Performance","System Design"],"title":"Bit Operations in Practice: From Bitmap Indexes to High-Performance Permission Systems","uri":"/posts/210111-shift-operation/"},{"categories":["Go"],"content":"Textbook quicksort is just the starting point. Real-world sorting algorithms have undergone decades of engineering optimization. This post deep-dives into Python’s TimSort and Go/Rust’s pdqsort, revealing the gap between “industrial-grade” and “textbook-grade”. ","date":"2018-06-21","objectID":"/posts/180621-the-sort-algorithm/:0:0","tags":["Sorting Algorithms","Source Code Analysis","Performance"],"title":"From TimSort to pdqsort: Engineering Optimizations in Production Sorting","uri":"/posts/180621-the-sort-algorithm/"},{"categories":["Go"],"content":"1. Limitations of Textbook Sorting ","date":"2018-06-21","objectID":"/posts/180621-the-sort-algorithm/:1:0","tags":["Sorting Algorithms","Source Code Analysis","Performance"],"title":"From TimSort to pdqsort: Engineering Optimizations in Production Sorting","uri":"/posts/180621-the-sort-algorithm/"},{"categories":["Go"],"content":"1.1 Quicksort: Theory vs Reality Textbook quicksort: func quickSort(arr []int, low, high int) { if low \u003c high { pivot := partition(arr, low, high) quickSort(arr, low, pivot-1) quickSort(arr, pivot+1, high) } } Theory: Average O(n log n), in-place, perfect. Reality problems: Worst case O(n²): Sorted/reversed arrays degrade Recursion overhead: Depth can reach n, stack overflow risk Cache unfriendly: Random access pattern Unstable: Equal element order may change ","date":"2018-06-21","objectID":"/posts/180621-the-sort-algorithm/:1:1","tags":["Sorting Algorithms","Source Code Analysis","Performance"],"title":"From TimSort to pdqsort: Engineering Optimizations in Production Sorting","uri":"/posts/180621-the-sort-algorithm/"},{"categories":["Go"],"content":"1.2 Language Choices Language Default Sort Characteristics Python TimSort Stable, exploits existing order Go 1.19+ pdqsort Fast, unstable, avoids worst case Rust pdqsort Same as Go Java TimSort (objects) / DualPivot (primitives) Optimized per type C++ IntroSort Quicksort + heapsort hybrid ","date":"2018-06-21","objectID":"/posts/180621-the-sort-algorithm/:1:2","tags":["Sorting Algorithms","Source Code Analysis","Performance"],"title":"From TimSort to pdqsort: Engineering Optimizations in Production Sorting","uri":"/posts/180621-the-sort-algorithm/"},{"categories":["Go"],"content":"2. TimSort: Designed for Real Data ","date":"2018-06-21","objectID":"/posts/180621-the-sort-algorithm/:2:0","tags":["Sorting Algorithms","Source Code Analysis","Performance"],"title":"From TimSort to pdqsort: Engineering Optimizations in Production Sorting","uri":"/posts/180621-the-sort-algorithm/"},{"categories":["Go"],"content":"2.1 Core Insight TimSort’s designer Tim Peters (Python core dev) observed: “Real-world data is often partially sorted” Logs sorted by time, database records by ID, append-only data — all have “run” characteristics. ","date":"2018-06-21","objectID":"/posts/180621-the-sort-algorithm/:2:1","tags":["Sorting Algorithms","Source Code Analysis","Performance"],"title":"From TimSort to pdqsort: Engineering Optimizations in Production Sorting","uri":"/posts/180621-the-sort-algorithm/"},{"categories":["Go"],"content":"2.2 Algorithm Structure Input: [1, 2, 3, 8, 7, 6, 5, 10, 11, 12] Step 1: Identify runs Run 1: [1, 2, 3] (ascending) Run 2: [8, 7, 6, 5] → reverse to [5, 6, 7, 8] Run 3: [10, 11, 12] (ascending) Step 2: Merge runs (merge sort) [1, 2, 3] + [5, 6, 7, 8] → [1, 2, 3, 5, 6, 7, 8] + [10, 11, 12] → [1, 2, 3, 5, 6, 7, 8, 10, 11, 12] ","date":"2018-06-21","objectID":"/posts/180621-the-sort-algorithm/:2:2","tags":["Sorting Algorithms","Source Code Analysis","Performance"],"title":"From TimSort to pdqsort: Engineering Optimizations in Production Sorting","uri":"/posts/180621-the-sort-algorithm/"},{"categories":["Go"],"content":"2.3 Key Optimizations 1. Minimum run length If run is too short, use insertion sort to extend to minrun (typically 32-64). # CPython source (simplified) def binary_insertion_sort(arr, lo, hi, start): \"\"\"Binary insertion sort in [lo, hi)\"\"\" for i in range(start, hi): pivot = arr[i] # Binary search for insert position left, right = lo, i while left \u003c right: mid = (left + right) // 2 if arr[mid] \u003e pivot: right = mid else: left = mid + 1 # Move elements arr[left+1:i+1] = arr[left:i] arr[left] = pivot Why insertion sort for small arrays? Small constant factor Cache friendly (sequential access) O(n) for nearly-sorted data 2. Galloping Mode When merging two runs, if one run keeps “winning”, data distribution is uneven: # Normal merge: compare one by one [1, 2, 3, 4, 100] + [50, 51, 52, 53, 54] # After detecting run1 consistently smaller, switch to galloping: # Exponential search to find where 100 should insert in [50, 51, 52, 53, 54] 3. Run stack balancing TimSort maintains a run stack, following “merge policy” to ensure balanced merging: Rules (counting from stack top): A \u003e B + C B \u003e C Violation triggers merge, guarantees stack height O(log n) ","date":"2018-06-21","objectID":"/posts/180621-the-sort-algorithm/:2:3","tags":["Sorting Algorithms","Source Code Analysis","Performance"],"title":"From TimSort to pdqsort: Engineering Optimizations in Production Sorting","uri":"/posts/180621-the-sort-algorithm/"},{"categories":["Go"],"content":"2.4 Performance Characteristics Scenario Time Complexity Fully sorted O(n) Reversed O(n) (reverse) Random O(n log n) Partially sorted Between O(n) and O(n log n) Stability: Guarantees equal elements keep order, friendly for object sorting. ","date":"2018-06-21","objectID":"/posts/180621-the-sort-algorithm/:2:4","tags":["Sorting Algorithms","Source Code Analysis","Performance"],"title":"From TimSort to pdqsort: Engineering Optimizations in Production Sorting","uri":"/posts/180621-the-sort-algorithm/"},{"categories":["Go"],"content":"3. pdqsort: Modern Quicksort’s Peak ","date":"2018-06-21","objectID":"/posts/180621-the-sort-algorithm/:3:0","tags":["Sorting Algorithms","Source Code Analysis","Performance"],"title":"From TimSort to pdqsort: Engineering Optimizations in Production Sorting","uri":"/posts/180621-the-sort-algorithm/"},{"categories":["Go"],"content":"3.1 Design Goals pdqsort (Pattern-Defeating Quicksort) goals: Average performance close to quicksort Worst case O(n log n) Detect special patterns to accelerate Unstable but extremely fast ","date":"2018-06-21","objectID":"/posts/180621-the-sort-algorithm/:3:1","tags":["Sorting Algorithms","Source Code Analysis","Performance"],"title":"From TimSort to pdqsort: Engineering Optimizations in Production Sorting","uri":"/posts/180621-the-sort-algorithm/"},{"categories":["Go"],"content":"3.2 Core Techniques 1. Adaptive pivot selection // Go source (sort package) simplified func choosePivot(data []int, a, b int) int { l := b - a // Small array: take middle if l \u003c 8 { return a + l/2 } // Medium array: median of three if l \u003c 50 { m := a + l/2 return medianOfThree(data, a, m, b-1) } // Large array: ninther (median of 9) m := a + l/2 return ninther(data, a, m, b-1) } 2. Bad pivot detection If pivot splits too unevenly (\u003c1/8), might be “killer input”: if partitionSize \u003c length/8 { badPivotCount++ if badPivotCount \u003e= maxBadPivots { // Switch to heapsort, guarantee O(n log n) heapSort(data, a, b) return } } This is what “Pattern-Defeating” means: detect and defeat inputs trying to trigger worst case. 3. Equal element partition (Dutch National Flag) Input: [5, 3, 5, 7, 5, 2, 5] pivot = 5 Three-way partition: [2, 3] [5, 5, 5, 5] [7] \u003c 5 = 5 \u003e 5 For arrays with many duplicates, skip the middle section entirely. 4. Small array optimization // Less than 12 elements, use insertion sort if b-a \u003c 12 { insertionSort(data, a, b) return } ","date":"2018-06-21","objectID":"/posts/180621-the-sort-algorithm/:3:2","tags":["Sorting Algorithms","Source Code Analysis","Performance"],"title":"From TimSort to pdqsort: Engineering Optimizations in Production Sorting","uri":"/posts/180621-the-sort-algorithm/"},{"categories":["Go"],"content":"3.3 Go 1.19 sort Package Source // src/sort/zsortinterface.go func pdqsort(data Interface, a, b, limit int) { const maxInsertion = 12 for { length := b - a // Small arrays use insertion sort if length \u003c maxInsertion { insertionSort(data, a, b) return } // Too many bad pivots, switch to heapsort if limit == 0 { heapSort(data, a, b) return } // Choose pivot and partition pivot := choosePivot(data, a, b) mid := partition(data, a, b, pivot) // Detect bad partition if mid-a \u003c length/8 || b-mid \u003c length/8 { limit-- } // Recurse (tail call optimization: recurse small, loop large) if mid-a \u003c b-mid { pdqsort(data, a, mid, limit) a = mid + 1 } else { pdqsort(data, mid+1, b, limit) b = mid } } } ","date":"2018-06-21","objectID":"/posts/180621-the-sort-algorithm/:3:3","tags":["Sorting Algorithms","Source Code Analysis","Performance"],"title":"From TimSort to pdqsort: Engineering Optimizations in Production Sorting","uri":"/posts/180621-the-sort-algorithm/"},{"categories":["Go"],"content":"4. Performance Comparison ","date":"2018-06-21","objectID":"/posts/180621-the-sort-algorithm/:4:0","tags":["Sorting Algorithms","Source Code Analysis","Performance"],"title":"From TimSort to pdqsort: Engineering Optimizations in Production Sorting","uri":"/posts/180621-the-sort-algorithm/"},{"categories":["Go"],"content":"4.1 Test Code func BenchmarkSorts(b *testing.B) { sizes := []int{100, 1000, 10000, 100000} patterns := []string{\"random\", \"sorted\", \"reversed\", \"partial\", \"duplicates\"} for _, size := range sizes { for _, pattern := range patterns { b.Run(fmt.Sprintf(\"%s-%d\", pattern, size), func(b *testing.B) { data := generateData(pattern, size) b.ResetTimer() for i := 0; i \u003c b.N; i++ { arr := make([]int, len(data)) copy(arr, data) sort.Ints(arr) } }) } } } ","date":"2018-06-21","objectID":"/posts/180621-the-sort-algorithm/:4:1","tags":["Sorting Algorithms","Source Code Analysis","Performance"],"title":"From TimSort to pdqsort: Engineering Optimizations in Production Sorting","uri":"/posts/180621-the-sort-algorithm/"},{"categories":["Go"],"content":"4.2 Typical Results Data Pattern 100K elements Winner Random 6ms pdqsort (quicksort genes) Sorted 0.5ms TimSort (direct detection) Reversed 0.5ms TimSort (reverse) Partially sorted 2ms TimSort Many duplicates 2ms pdqsort (3-way partition) ","date":"2018-06-21","objectID":"/posts/180621-the-sort-algorithm/:4:2","tags":["Sorting Algorithms","Source Code Analysis","Performance"],"title":"From TimSort to pdqsort: Engineering Optimizations in Production Sorting","uri":"/posts/180621-the-sort-algorithm/"},{"categories":["Go"],"content":"5. Engineering Insights ","date":"2018-06-21","objectID":"/posts/180621-the-sort-algorithm/:5:0","tags":["Sorting Algorithms","Source Code Analysis","Performance"],"title":"From TimSort to pdqsort: Engineering Optimizations in Production Sorting","uri":"/posts/180621-the-sort-algorithm/"},{"categories":["Go"],"content":"5.1 No Silver Bullet // Need stable sort? sort.SliceStable(data, less) // TimSort-inspired stable sort // Maximum performance? sort.Slice(data, less) // pdqsort ","date":"2018-06-21","objectID":"/posts/180621-the-sort-algorithm/:5:1","tags":["Sorting Algorithms","Source Code Analysis","Performance"],"title":"From TimSort to pdqsort: Engineering Optimizations in Production Sorting","uri":"/posts/180621-the-sort-algorithm/"},{"categories":["Go"],"content":"5.2 Custom Sort Gotchas // Wrong: inconsistent comparison sort.Slice(users, func(i, j int) bool { return users[i].Name \u003c= users[j].Name // \u003c= instead of \u003c }) // May cause infinite loop! // Correct sort.Slice(users, func(i, j int) bool { return users[i].Name \u003c users[j].Name }) ","date":"2018-06-21","objectID":"/posts/180621-the-sort-algorithm/:5:2","tags":["Sorting Algorithms","Source Code Analysis","Performance"],"title":"From TimSort to pdqsort: Engineering Optimizations in Production Sorting","uri":"/posts/180621-the-sort-algorithm/"},{"categories":["Go"],"content":"5.3 When to Write Your Own Sort? Almost never. Standard library is already optimal. Exceptions: Ultra-large distributed sorting (MapReduce) Hardware-specific optimization (GPU sorting) External sorting (disk merge) ","date":"2018-06-21","objectID":"/posts/180621-the-sort-algorithm/:5:3","tags":["Sorting Algorithms","Source Code Analysis","Performance"],"title":"From TimSort to pdqsort: Engineering Optimizations in Production Sorting","uri":"/posts/180621-the-sort-algorithm/"},{"categories":["Go"],"content":"6. Summary Algorithm Design Philosophy Use Case TimSort Exploit existing runs Python/Java object sorting pdqsort Defend against worst case Go/Rust high-performance IntroSort Quicksort + heapsort hybrid C++ STL Key takeaways: Real data is often partially sorted — TimSort exploits this Malicious input can attack quicksort — pdqsort detects and defends Insertion sort for small arrays — every implementation agrees Engineering optimization matters more than algorithm choice ","date":"2018-06-21","objectID":"/posts/180621-the-sort-algorithm/:6:0","tags":["Sorting Algorithms","Source Code Analysis","Performance"],"title":"From TimSort to pdqsort: Engineering Optimizations in Production Sorting","uri":"/posts/180621-the-sort-algorithm/"}]