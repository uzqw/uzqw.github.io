<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>State Machine on zqw's notes</title><link>https://uzqw.github.io/tags/state-machine/</link><description>Recent content in State Machine on zqw's notes</description><generator>Hugo</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Thu, 14 Apr 2022 12:00:00 +0800</lastBuildDate><atom:link href="https://uzqw.github.io/tags/state-machine/index.xml" rel="self" type="application/rss+xml"/><item><title>Production-Grade String Parsing: From atoi to State Machine</title><link>https://uzqw.github.io/posts/220414-atoi/</link><pubDate>Thu, 14 Apr 2022 12:00:00 +0800</pubDate><guid>https://uzqw.github.io/posts/220414-atoi/</guid><description>&lt;p&gt;LeetCode&amp;rsquo;s atoi is a classic interview problem, but production-grade implementations are far more complex. This post starts from the interview version and gradually analyzes Go and Rust standard library implementations to understand &amp;ldquo;production-grade&amp;rdquo; code design.&lt;/p&gt;</description></item></channel></rss>