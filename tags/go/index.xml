<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on zqw's notes</title><link>https://uzqw.github.io/tags/go/</link><description>Recent content in Go on zqw's notes</description><generator>Hugo</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Mon, 16 Feb 2026 10:00:00 +0800</lastBuildDate><atom:link href="https://uzqw.github.io/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Six Pitfalls Implementing HNSW: A Debug Journal from 0% to 98%+ Recall</title><link>https://uzqw.github.io/posts/260216-hnsw-implementation/</link><pubDate>Mon, 16 Feb 2026 10:00:00 +0800</pubDate><guid>https://uzqw.github.io/posts/260216-hnsw-implementation/</guid><description>&lt;p&gt;While implementing the HNSW algorithm for my vector database project &lt;a href="https://github.com/uzqw/vex" target="_blank" rel="noopener noreffer "&gt;vex&lt;/a&gt; (initial code AI-assisted, debugging and optimization done by hand), I ran my first Recall test — &lt;strong&gt;every single metric was 0%&lt;/strong&gt;. Not 50%, not 30%. Zero. The HNSW results and BruteForce results had absolutely no overlap. This post documents the entire journey from 0% to 98%+ recall, cross-referencing each bug with the original HNSW paper.&lt;/p&gt;</description></item><item><title>Temporal Single-Node Reliability Deep Dive: How It Survives Server Crashes, Network Failures, and Rollback Errors</title><link>https://uzqw.github.io/posts/260213-temporal-reliability/</link><pubDate>Fri, 13 Feb 2026 10:00:00 +0800</pubDate><guid>https://uzqw.github.io/posts/260213-temporal-reliability/</guid><description>&lt;p&gt;Writing business logic with Temporal is pure joy — &amp;ldquo;code like a single-machine program, get distributed fault tolerance for free.&amp;rdquo; But after the honeymoon phase, a nagging question remains: &lt;strong&gt;Is it really reliable?&lt;/strong&gt; What if the Server crashes? What about network partitions? What if the rollback itself fails? This article tears apart these questions from the ground up.&lt;/p&gt;</description></item><item><title>Temporal in Practice: From Saga Pattern to Self-Healing Distributed Transactions</title><link>https://uzqw.github.io/posts/250710-temporal-saga/</link><pubDate>Thu, 10 Jul 2025 10:00:00 +0800</pubDate><guid>https://uzqw.github.io/posts/250710-temporal-saga/</guid><description>&lt;p&gt;While building a trading system backend, I used Temporal to solve the classic distributed transaction consistency problem. This post breaks down Temporal&amp;rsquo;s core mechanisms and explores its applications in AI task scheduling.&lt;/p&gt;</description></item><item><title>NAS Disk Health Monitoring: From smartctl to Custom Agent</title><link>https://uzqw.github.io/posts/220815-disk-health-agent/</link><pubDate>Mon, 15 Aug 2022 10:00:00 +0800</pubDate><guid>https://uzqw.github.io/posts/220815-disk-health-agent/</guid><description>&lt;p&gt;A NAS&amp;rsquo;s most important job is protecting user data. Disk failures often have warning signs, and SMART technology can detect problems early. This post documents how to build a disk health monitoring agent.&lt;/p&gt;</description></item><item><title>Go Microservices War Stories: 5 Lessons from Dependency Management to Service Discovery</title><link>https://uzqw.github.io/posts/210922-go-feature/</link><pubDate>Wed, 22 Sep 2021 21:56:00 +0800</pubDate><guid>https://uzqw.github.io/posts/210922-go-feature/</guid><description>&lt;p&gt;Microservices isn&amp;rsquo;t just about splitting up a monolith. This post documents 5 real pitfalls I hit in Go microservices projects, and how to avoid them.&lt;/p&gt;</description></item><item><title>Building a Mini Filesystem: Custom FS with FUSE + Go</title><link>https://uzqw.github.io/posts/210810-fuse-filesystem/</link><pubDate>Tue, 10 Aug 2021 10:00:00 +0800</pubDate><guid>https://uzqw.github.io/posts/210810-fuse-filesystem/</guid><description>&lt;p&gt;The best way to learn filesystems is to write one yourself. This post uses FUSE + Go to implement an in-memory filesystem with basic read/write operations, deep-diving into core concepts like inode and block.&lt;/p&gt;</description></item></channel></rss>